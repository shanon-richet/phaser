/* Phaser v2.8.2 - http://phaser.io - @photonstorm - (c) 2016 Photon Storm Ltd. */ !function(a) {
    if ("object" == typeof exports) module.exports = a();
    else {
        var b;
        "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self), b.p2 = a();
    }
}(function() {
    return (function a1(b, c1, d) {
        function e(g, h) {
            if (!c1[g]) {
                if (!b[g]) {
                    var i = "function" == typeof require && undefined;
                    if (!h && i) return i(g, !0);
                    if (f) return f(g, !0);
                    throw new Error("Cannot find module '" + g + "'");
                }
                var j = c1[g] = {
                    exports: {}
                };
                b[g][0].call(j.exports, function(a) {
                    var c = b[g][1][a];
                    return e(c || a);
                }, j, j.exports, a1, b, c1, d);
            }
            return c1[g].exports;
        }
        for(var f = "function" == typeof require && undefined, g1 = 0; g1 < d.length; g1++)e(d[g1]);
        return e;
    })({
        1: [
            function(a2, b1, c2) {
                function d1() {}
                var e1 = a2("./Scalar");
                b1.exports = d1, d1.lineInt = function(a, b, c) {
                    c = c || 0;
                    var d, f, g, h, i, j, k, l = [
                        0,
                        0
                    ];
                    return d = a[1][1] - a[0][1], f = a[0][0] - a[1][0], g = d * a[0][0] + f * a[0][1], h = b[1][1] - b[0][1], i = b[0][0] - b[1][0], j = h * b[0][0] + i * b[0][1], k = d * i - h * f, e1.eq(k, 0, c) || (l[0] = (i * g - f * j) / k, l[1] = (d * j - h * g) / k), l;
                }, d1.segmentsIntersect = function(a, b, c, d) {
                    var e = b[0] - a[0], f = b[1] - a[1], g = d[0] - c[0], h = d[1] - c[1];
                    if (g * f - h * e == 0) return !1;
                    var i = (e * (c[1] - a[1]) + f * (a[0] - c[0])) / (g * f - h * e), j = (g * (a[1] - c[1]) + h * (c[0] - a[0])) / (h * e - g * f);
                    return i >= 0 && i <= 1 && j >= 0 && j <= 1;
                };
            },
            {
                "./Scalar": 4
            }
        ],
        2: [
            function(a3, b2, c3) {
                function d2() {}
                b2.exports = d2, d2.area = function(a, b, c) {
                    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
                }, d2.left = function(a, b, c) {
                    return d2.area(a, b, c) > 0;
                }, d2.leftOn = function(a, b, c) {
                    return d2.area(a, b, c) >= 0;
                }, d2.right = function(a, b, c) {
                    return d2.area(a, b, c) < 0;
                }, d2.rightOn = function(a, b, c) {
                    return d2.area(a, b, c) <= 0;
                };
                var e = [], f = [];
                d2.collinear = function(a, b, c, g) {
                    if (g) {
                        var h = e, i = f;
                        h[0] = b[0] - a[0], h[1] = b[1] - a[1], i[0] = c[0] - b[0], i[1] = c[1] - b[1];
                        var j = h[0] * i[0] + h[1] * i[1], k = Math.sqrt(h[0] * h[0] + h[1] * h[1]), l = Math.sqrt(i[0] * i[0] + i[1] * i[1]);
                        return Math.acos(j / (k * l)) < g;
                    }
                    return 0 == d2.area(a, b, c);
                }, d2.sqdist = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1];
                    return c * c + d * d;
                };
            },
            {}
        ],
        3: [
            function(a4, b3, c4) {
                function d3() {
                    this.vertices = [];
                }
                function e2(a, b, c, d, e) {
                    e = e || 0;
                    var f = b[1] - a[1], g = a[0] - b[0], i = f * a[0] + g * a[1], j = d[1] - c[1], k = c[0] - d[0], l = j * c[0] + k * c[1], m = f * k - j * g;
                    return h1.eq(m, 0, e) ? [
                        0,
                        0
                    ] : [
                        (k * i - g * l) / m,
                        (f * l - j * i) / m
                    ];
                }
                var f1 = a4("./Line"), g2 = a4("./Point"), h1 = a4("./Scalar");
                b3.exports = d3, d3.prototype.at = function(a) {
                    var b = this.vertices, c = b.length;
                    return b[a < 0 ? a % c + c : a % c];
                }, d3.prototype.first = function() {
                    return this.vertices[0];
                }, d3.prototype.last = function() {
                    return this.vertices[this.vertices.length - 1];
                }, d3.prototype.clear = function() {
                    this.vertices.length = 0;
                }, d3.prototype.append = function(a, b, c) {
                    if (void 0 === b) throw new Error("From is not given!");
                    if (void 0 === c) throw new Error("To is not given!");
                    if (c - 1 < b) throw new Error("lol1");
                    if (c > a.vertices.length) throw new Error("lol2");
                    if (b < 0) throw new Error("lol3");
                    for(var d = b; d < c; d++)this.vertices.push(a.vertices[d]);
                }, d3.prototype.makeCCW = function() {
                    for(var a = 0, b = this.vertices, c = 1; c < this.vertices.length; ++c)(b[c][1] < b[a][1] || b[c][1] == b[a][1] && b[c][0] > b[a][0]) && (a = c);
                    g2.left(this.at(a - 1), this.at(a), this.at(a + 1)) || this.reverse();
                }, d3.prototype.reverse = function() {
                    for(var a = [], b = 0, c = this.vertices.length; b !== c; b++)a.push(this.vertices.pop());
                    this.vertices = a;
                }, d3.prototype.isReflex = function(a) {
                    return g2.right(this.at(a - 1), this.at(a), this.at(a + 1));
                };
                var i1 = [], j1 = [];
                d3.prototype.canSee = function(a, b) {
                    var c, d, e = i1, h = j1;
                    if (g2.leftOn(this.at(a + 1), this.at(a), this.at(b)) && g2.rightOn(this.at(a - 1), this.at(a), this.at(b))) return !1;
                    d = g2.sqdist(this.at(a), this.at(b));
                    for(var k = 0; k !== this.vertices.length; ++k)if ((k + 1) % this.vertices.length !== a && k !== a && g2.leftOn(this.at(a), this.at(b), this.at(k + 1)) && g2.rightOn(this.at(a), this.at(b), this.at(k)) && (e[0] = this.at(a), e[1] = this.at(b), h[0] = this.at(k), h[1] = this.at(k + 1), c = f1.lineInt(e, h), g2.sqdist(this.at(a), c) < d)) return !1;
                    return !0;
                }, d3.prototype.copy = function(a, b, c) {
                    var e = c || new d3;
                    if (e.clear(), a < b) for(var f = a; f <= b; f++)e.vertices.push(this.vertices[f]);
                    else {
                        for(var f = 0; f <= b; f++)e.vertices.push(this.vertices[f]);
                        for(var f = a; f < this.vertices.length; f++)e.vertices.push(this.vertices[f]);
                    }
                    return e;
                }, d3.prototype.getCutEdges = function() {
                    for(var a = [], b = [], c = [], e = new d3, f = Number.MAX_VALUE, g = 0; g < this.vertices.length; ++g)if (this.isReflex(g)) {
                        for(var h = 0; h < this.vertices.length; ++h)if (this.canSee(g, h)) {
                            b = this.copy(g, h, e).getCutEdges(), c = this.copy(h, g, e).getCutEdges();
                            for(var i = 0; i < c.length; i++)b.push(c[i]);
                            b.length < f && (a = b, f = b.length, a.push([
                                this.at(g),
                                this.at(h)
                            ]));
                        }
                    }
                    return a;
                }, d3.prototype.decomp = function() {
                    var a = this.getCutEdges();
                    return a.length > 0 ? this.slice(a) : [
                        this
                    ];
                }, d3.prototype.slice = function(a) {
                    if (0 == a.length) return [
                        this
                    ];
                    if (a instanceof Array && a.length && a[0] instanceof Array && 2 == a[0].length && a[0][0] instanceof Array) {
                        for(var b = [
                            this
                        ], c = 0; c < a.length; c++)for(var d = a[c], e = 0; e < b.length; e++){
                            var f = b[e], g = f.slice(d);
                            if (g) {
                                b.splice(e, 1), b.push(g[0], g[1]);
                                break;
                            }
                        }
                        return b;
                    }
                    var d = a, c = this.vertices.indexOf(d[0]), e = this.vertices.indexOf(d[1]);
                    return -1 != c && -1 != e && [
                        this.copy(c, e),
                        this.copy(e, c)
                    ];
                }, d3.prototype.isSimple = function() {
                    for(var a = this.vertices, b = 0; b < a.length - 1; b++)for(var c = 0; c < b - 1; c++)if (f1.segmentsIntersect(a[b], a[b + 1], a[c], a[c + 1])) return !1;
                    for(var b = 1; b < a.length - 2; b++)if (f1.segmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1])) return !1;
                    return !0;
                }, d3.prototype.quickDecomp = function(a, b, c, f, h, i) {
                    h = h || 100, i = i || 0, f = f || 25, a = void 0 !== a ? a : [], b = b || [], c = c || [];
                    var j = [
                        0,
                        0
                    ], k = [
                        0,
                        0
                    ], l = [
                        0,
                        0
                    ], m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = new d3, u = new d3, v = this, w = this.vertices;
                    if (w.length < 3) return a;
                    if (++i > h) return console.warn("quickDecomp: max level (" + h + ") reached."), a;
                    for(var x = 0; x < this.vertices.length; ++x)if (v.isReflex(x)) {
                        b.push(v.vertices[x]), m = n = Number.MAX_VALUE;
                        for(var y = 0; y < this.vertices.length; ++y)g2.left(v.at(x - 1), v.at(x), v.at(y)) && g2.rightOn(v.at(x - 1), v.at(x), v.at(y - 1)) && (l = e2(v.at(x - 1), v.at(x), v.at(y), v.at(y - 1)), g2.right(v.at(x + 1), v.at(x), l) && (o = g2.sqdist(v.vertices[x], l)) < n && (n = o, k = l, r = y)), g2.left(v.at(x + 1), v.at(x), v.at(y + 1)) && g2.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (l = e2(v.at(x + 1), v.at(x), v.at(y), v.at(y + 1)), g2.left(v.at(x - 1), v.at(x), l) && (o = g2.sqdist(v.vertices[x], l)) < m && (m = o, j = l, q = y));
                        if (r == (q + 1) % this.vertices.length) l[0] = (k[0] + j[0]) / 2, l[1] = (k[1] + j[1]) / 2, c.push(l), x < q ? (t.append(v, x, q + 1), t.vertices.push(l), u.vertices.push(l), 0 != r && u.append(v, r, v.vertices.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, v.vertices.length), t.append(v, 0, q + 1), t.vertices.push(l), u.vertices.push(l), u.append(v, r, x + 1));
                        else {
                            if (r > q && (q += this.vertices.length), p = Number.MAX_VALUE, q < r) return a;
                            for(var y = r; y <= q; ++y)g2.leftOn(v.at(x - 1), v.at(x), v.at(y)) && g2.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (o = g2.sqdist(v.at(x), v.at(y))) < p && (p = o, s = y % this.vertices.length);
                            x < s ? (t.append(v, x, s + 1), 0 != s && u.append(v, s, w.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, w.length), t.append(v, 0, s + 1), u.append(v, s, x + 1));
                        }
                        return t.vertices.length < u.vertices.length ? (t.quickDecomp(a, b, c, f, h, i), u.quickDecomp(a, b, c, f, h, i)) : (u.quickDecomp(a, b, c, f, h, i), t.quickDecomp(a, b, c, f, h, i)), a;
                    }
                    return a.push(this), a;
                }, d3.prototype.removeCollinearPoints = function(a) {
                    for(var b = 0, c = this.vertices.length - 1; this.vertices.length > 3 && c >= 0; --c)g2.collinear(this.at(c - 1), this.at(c), this.at(c + 1), a) && (this.vertices.splice(c % this.vertices.length, 1), c--, b++);
                    return b;
                };
            },
            {
                "./Line": 1,
                "./Point": 2,
                "./Scalar": 4
            }
        ],
        4: [
            function(a5, b4, c5) {
                function d() {}
                b4.exports = d, d.eq = function(a, b, c) {
                    return c = c || 0, Math.abs(a - b) < c;
                };
            },
            {}
        ],
        5: [
            function(a, b, c) {
                b.exports = {
                    Polygon: a("./Polygon"),
                    Point: a("./Point")
                };
            },
            {
                "./Point": 2,
                "./Polygon": 3
            }
        ],
        6: [
            function(a, b, c) {
                b.exports = {
                    name: "p2",
                    version: "0.7.1",
                    description: "A JavaScript 2D physics engine.",
                    author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                    keywords: [
                        "p2.js",
                        "p2",
                        "physics",
                        "engine",
                        "2d"
                    ],
                    main: "./src/p2.js",
                    engines: {
                        node: "*"
                    },
                    repository: {
                        type: "git",
                        url: "https://github.com/schteppe/p2.js.git"
                    },
                    bugs: {
                        url: "https://github.com/schteppe/p2.js/issues"
                    },
                    licenses: [
                        {
                            type: "MIT"
                        }
                    ],
                    devDependencies: {
                        grunt: "^0.4.5",
                        "grunt-contrib-jshint": "^0.11.2",
                        "grunt-contrib-nodeunit": "^0.4.1",
                        "grunt-contrib-uglify": "~0.4.0",
                        "grunt-contrib-watch": "~0.5.0",
                        "grunt-browserify": "~2.0.1",
                        "grunt-contrib-concat": "^0.4.0"
                    },
                    dependencies: {
                        "poly-decomp": "0.1.1"
                    }
                };
            },
            {}
        ],
        7: [
            function(a6, b5, c6) {
                function d4(a) {
                    this.lowerBound = e3.create(), a && a.lowerBound && e3.copy(this.lowerBound, a.lowerBound), this.upperBound = e3.create(), a && a.upperBound && e3.copy(this.upperBound, a.upperBound);
                }
                var e3 = a6("../math/vec2");
                a6("../utils/Utils");
                b5.exports = d4;
                var f2 = e3.create();
                d4.prototype.setFromPoints = function(a, b, c, d) {
                    var g = this.lowerBound, h = this.upperBound;
                    "number" != typeof c && (c = 0), 0 !== c ? e3.rotate(g, a[0], c) : e3.copy(g, a[0]), e3.copy(h, g);
                    for(var i = Math.cos(c), j = Math.sin(c), k = 1; k < a.length; k++){
                        var l = a[k];
                        if (0 !== c) {
                            var m = l[0], n = l[1];
                            f2[0] = i * m - j * n, f2[1] = j * m + i * n, l = f2;
                        }
                        for(var o = 0; o < 2; o++)l[o] > h[o] && (h[o] = l[o]), l[o] < g[o] && (g[o] = l[o]);
                    }
                    b && (e3.add(this.lowerBound, this.lowerBound, b), e3.add(this.upperBound, this.upperBound, b)), d && (this.lowerBound[0] -= d, this.lowerBound[1] -= d, this.upperBound[0] += d, this.upperBound[1] += d);
                }, d4.prototype.copy = function(a) {
                    e3.copy(this.lowerBound, a.lowerBound), e3.copy(this.upperBound, a.upperBound);
                }, d4.prototype.extend = function(a) {
                    for(var b = 2; b--;){
                        var c = a.lowerBound[b];
                        this.lowerBound[b] > c && (this.lowerBound[b] = c);
                        var d = a.upperBound[b];
                        this.upperBound[b] < d && (this.upperBound[b] = d);
                    }
                }, d4.prototype.overlaps = function(a) {
                    var b = this.lowerBound, c = this.upperBound, d = a.lowerBound, e = a.upperBound;
                    return (d[0] <= c[0] && c[0] <= e[0] || b[0] <= e[0] && e[0] <= c[0]) && (d[1] <= c[1] && c[1] <= e[1] || b[1] <= e[1] && e[1] <= c[1]);
                }, d4.prototype.containsPoint = function(a) {
                    var b = this.lowerBound, c = this.upperBound;
                    return b[0] <= a[0] && a[0] <= c[0] && b[1] <= a[1] && a[1] <= c[1];
                }, d4.prototype.overlapsRay = function(a) {
                    var b = 1 / a.direction[0], c = 1 / a.direction[1], d = (this.lowerBound[0] - a.from[0]) * b, e = (this.upperBound[0] - a.from[0]) * b, f = (this.lowerBound[1] - a.from[1]) * c, g = (this.upperBound[1] - a.from[1]) * c, h = Math.max(Math.max(Math.min(d, e), Math.min(f, g))), i = Math.min(Math.min(Math.max(d, e), Math.max(f, g)));
                    return i < 0 ? -1 : h > i ? -1 : h;
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }
        ],
        8: [
            function(a7, b6, c7) {
                function d5(a) {
                    this.type = a, this.result = [], this.world = null, this.boundingVolumeType = d5.AABB;
                }
                var e = a7("../math/vec2"), f = a7("../objects/Body");
                b6.exports = d5, d5.AABB = 1, d5.BOUNDING_CIRCLE = 2, d5.prototype.setWorld = function(a) {
                    this.world = a;
                }, d5.prototype.getCollisionPairs = function(a) {};
                var g = e.create();
                d5.boundingRadiusCheck = function(a, b) {
                    e.sub(g, a.position, b.position);
                    var c = e.squaredLength(g), d = a.boundingRadius + b.boundingRadius;
                    return c <= d * d;
                }, d5.aabbCheck = function(a, b) {
                    return a.getAABB().overlaps(b.getAABB());
                }, d5.prototype.boundingVolumeCheck = function(a, b) {
                    var c;
                    switch(this.boundingVolumeType){
                        case d5.BOUNDING_CIRCLE:
                            c = d5.boundingRadiusCheck(a, b);
                            break;
                        case d5.AABB:
                            c = d5.aabbCheck(a, b);
                            break;
                        default:
                            throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType);
                    }
                    return c;
                }, d5.canCollide = function(a, b) {
                    var c = f.KINEMATIC, d = f.STATIC;
                    return (a.type !== d || b.type !== d) && !(a.type === c && b.type === d || a.type === d && b.type === c) && (a.type !== c || b.type !== c) && (a.sleepState !== f.SLEEPING || b.sleepState !== f.SLEEPING) && !(a.sleepState === f.SLEEPING && b.type === d || b.sleepState === f.SLEEPING && a.type === d);
                }, d5.NAIVE = 1, d5.SAP = 2;
            },
            {
                "../math/vec2": 30,
                "../objects/Body": 31
            }
        ],
        9: [
            function(a8, b7, c8) {
                function d6() {
                    e4.call(this, e4.NAIVE);
                }
                var e4 = (a8("../shapes/Circle"), a8("../shapes/Plane"), a8("../shapes/Shape"), a8("../shapes/Particle"), a8("../collision/Broadphase"));
                a8("../math/vec2");
                b7.exports = d6, d6.prototype = new e4, d6.prototype.constructor = d6, d6.prototype.getCollisionPairs = function(a) {
                    var b = a.bodies, c = this.result;
                    c.length = 0;
                    for(var d = 0, f = b.length; d !== f; d++)for(var g = b[d], h = 0; h < d; h++){
                        var i = b[h];
                        e4.canCollide(g, i) && this.boundingVolumeCheck(g, i) && c.push(g, i);
                    }
                    return c;
                }, d6.prototype.aabbQuery = function(a, b, c) {
                    c = c || [];
                    for(var d = a.bodies, e = 0; e < d.length; e++){
                        var f = d[e];
                        f.aabbNeedsUpdate && f.updateAABB(), f.aabb.overlaps(b) && c.push(f);
                    }
                    return c;
                };
            },
            {
                "../collision/Broadphase": 8,
                "../math/vec2": 30,
                "../shapes/Circle": 39,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45
            }
        ],
        10: [
            function(a9, b8, c9) {
                function d7() {
                    this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = 0.3, this.surfaceVelocity = 0, this.contactEquationPool = new k1({
                        size: 32
                    }), this.frictionEquationPool = new l1({
                        size: 64
                    }), this.restitution = 0, this.stiffness = n1.DEFAULT_STIFFNESS, this.relaxation = n1.DEFAULT_RELAXATION, this.frictionStiffness = n1.DEFAULT_STIFFNESS, this.frictionRelaxation = n1.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new m1, this.contactSkinSize = 0.01;
                }
                function e5(a, b) {
                    g3.set(a.vertices[0], 0.5 * -b.length, -b.radius), g3.set(a.vertices[1], 0.5 * b.length, -b.radius), g3.set(a.vertices[2], 0.5 * b.length, b.radius), g3.set(a.vertices[3], 0.5 * -b.length, b.radius);
                }
                function f3(a, b, c, d) {
                    for(var e = T1, f = U1, j = V1, k = W1, l = a, m = b.vertices, n = null, o = 0; o !== m.length + 1; o++){
                        var p = m[o % m.length], q = m[(o + 1) % m.length];
                        g3.rotate(e, p, d), g3.rotate(f, q, d), i2(e, e, c), i2(f, f, c), h2(j, e, l), h2(k, f, l);
                        var r = g3.crossLength(j, k);
                        if (null === n && (n = r), r * n <= 0) return !1;
                        n = r;
                    }
                    return !0;
                }
                var g3 = a9("../math/vec2"), h2 = g3.sub, i2 = g3.add, j2 = g3.dot, k1 = (a9("../utils/Utils"), a9("../utils/ContactEquationPool")), l1 = a9("../utils/FrictionEquationPool"), m1 = a9("../utils/TupleDictionary"), n1 = a9("../equations/Equation"), o1 = (a9("../equations/ContactEquation"), a9("../equations/FrictionEquation"), a9("../shapes/Circle")), p1 = a9("../shapes/Convex"), q1 = a9("../shapes/Shape"), r1 = (a9("../objects/Body"), a9("../shapes/Box"));
                b8.exports = d7;
                var s1 = g3.fromValues(0, 1), t1 = g3.fromValues(0, 0), u1 = g3.fromValues(0, 0), v1 = g3.fromValues(0, 0), w1 = g3.fromValues(0, 0), x1 = g3.fromValues(0, 0), y1 = g3.fromValues(0, 0), z1 = g3.fromValues(0, 0), A1 = g3.fromValues(0, 0), B1 = g3.fromValues(0, 0), C1 = g3.fromValues(0, 0), D1 = g3.fromValues(0, 0), E1 = g3.fromValues(0, 0), F1 = g3.fromValues(0, 0), G1 = g3.fromValues(0, 0), H1 = g3.fromValues(0, 0), I1 = g3.fromValues(0, 0), J1 = g3.fromValues(0, 0), K1 = g3.fromValues(0, 0), L1 = [], M1 = g3.create(), N1 = g3.create();
                d7.prototype.bodiesOverlap = function(a, b) {
                    for(var c = M1, d = N1, e = 0, f = a.shapes.length; e !== f; e++){
                        var g = a.shapes[e];
                        a.toWorldFrame(c, g.position);
                        for(var h = 0, i = b.shapes.length; h !== i; h++){
                            var j = b.shapes[h];
                            if (b.toWorldFrame(d, j.position), this[g.type | j.type](a, g, c, g.angle + a.angle, b, j, d, j.angle + b.angle, !0)) return !0;
                        }
                    }
                    return !1;
                }, d7.prototype.collidedLastStep = function(a, b) {
                    var c = 0 | a.id, d = 0 | b.id;
                    return !!this.collidingBodiesLastStep.get(c, d);
                }, d7.prototype.reset = function() {
                    this.collidingBodiesLastStep.reset();
                    for(var a = this.contactEquations, b = a.length; b--;){
                        var c = a[b], d = c.bodyA.id, e = c.bodyB.id;
                        this.collidingBodiesLastStep.set(d, e, !0);
                    }
                    for(var f = this.contactEquations, g = this.frictionEquations, h = 0; h < f.length; h++)this.contactEquationPool.release(f[h]);
                    for(var h = 0; h < g.length; h++)this.frictionEquationPool.release(g[h]);
                    this.contactEquations.length = this.frictionEquations.length = 0;
                }, d7.prototype.createContactEquation = function(a, b, c, d) {
                    var e = this.contactEquationPool.get();
                    return e.bodyA = a, e.bodyB = b, e.shapeA = c, e.shapeB = d, e.restitution = this.restitution, e.firstImpact = !this.collidedLastStep(a, b), e.stiffness = this.stiffness, e.relaxation = this.relaxation, e.needsUpdate = !0, e.enabled = this.enabledEquations, e.offset = this.contactSkinSize, e;
                }, d7.prototype.createFrictionEquation = function(a, b, c, d) {
                    var e = this.frictionEquationPool.get();
                    return e.bodyA = a, e.bodyB = b, e.shapeA = c, e.shapeB = d, e.setSlipForce(this.slipForce), e.frictionCoefficient = this.frictionCoefficient, e.relativeVelocity = this.surfaceVelocity, e.enabled = this.enabledEquations, e.needsUpdate = !0, e.stiffness = this.frictionStiffness, e.relaxation = this.frictionRelaxation, e.contactEquations.length = 0, e;
                }, d7.prototype.createFrictionFromContact = function(a) {
                    var b = this.createFrictionEquation(a.bodyA, a.bodyB, a.shapeA, a.shapeB);
                    return g3.copy(b.contactPointA, a.contactPointA), g3.copy(b.contactPointB, a.contactPointB), g3.rotate90cw(b.t, a.normalA), b.contactEquations.push(a), b;
                }, d7.prototype.createFrictionFromAverage = function(a) {
                    var b = this.contactEquations[this.contactEquations.length - 1], c = this.createFrictionEquation(b.bodyA, b.bodyB, b.shapeA, b.shapeB), d = b.bodyA;
                    b.bodyB;
                    g3.set(c.contactPointA, 0, 0), g3.set(c.contactPointB, 0, 0), g3.set(c.t, 0, 0);
                    for(var e = 0; e !== a; e++)b = this.contactEquations[this.contactEquations.length - 1 - e], b.bodyA === d ? (g3.add(c.t, c.t, b.normalA), g3.add(c.contactPointA, c.contactPointA, b.contactPointA), g3.add(c.contactPointB, c.contactPointB, b.contactPointB)) : (g3.sub(c.t, c.t, b.normalA), g3.add(c.contactPointA, c.contactPointA, b.contactPointB), g3.add(c.contactPointB, c.contactPointB, b.contactPointA)), c.contactEquations.push(b);
                    var f = 1 / a;
                    return g3.scale(c.contactPointA, c.contactPointA, f), g3.scale(c.contactPointB, c.contactPointB, f), g3.normalize(c.t, c.t), g3.rotate90cw(c.t, c.t), c;
                }, d7.prototype[q1.LINE | q1.CONVEX] = d7.prototype.convexLine = function(a, b, c, d, e, f, g, h, i) {
                    return !i && 0;
                }, d7.prototype[q1.LINE | q1.BOX] = d7.prototype.lineBox = function(a, b, c, d, e, f, g, h, i) {
                    return !i && 0;
                };
                var O1 = new r1({
                    width: 1,
                    height: 1
                }), P1 = g3.create();
                d7.prototype[q1.CAPSULE | q1.CONVEX] = d7.prototype[q1.CAPSULE | q1.BOX] = d7.prototype.convexCapsule = function(a, b, c, d, f, h, i, j, k) {
                    var l = P1;
                    g3.set(l, h.length / 2, 0), g3.rotate(l, l, j), g3.add(l, l, i);
                    var m = this.circleConvex(f, h, l, j, a, b, c, d, k, h.radius);
                    g3.set(l, -h.length / 2, 0), g3.rotate(l, l, j), g3.add(l, l, i);
                    var n = this.circleConvex(f, h, l, j, a, b, c, d, k, h.radius);
                    if (k && (m || n)) return !0;
                    var o = O1;
                    return e5(o, h), this.convexConvex(a, b, c, d, f, o, i, j, k) + m + n;
                }, d7.prototype[q1.CAPSULE | q1.LINE] = d7.prototype.lineCapsule = function(a, b, c, d, e, f, g, h, i) {
                    return !i && 0;
                };
                var Q1 = g3.create(), R1 = g3.create(), S1 = new r1({
                    width: 1,
                    height: 1
                });
                d7.prototype[q1.CAPSULE | q1.CAPSULE] = d7.prototype.capsuleCapsule = function(a, b, c, d, f, h, i, j, k) {
                    for(var l, m = Q1, n = R1, o = 0, p = 0; p < 2; p++){
                        g3.set(m, (0 === p ? -1 : 1) * b.length / 2, 0), g3.rotate(m, m, d), g3.add(m, m, c);
                        for(var q = 0; q < 2; q++){
                            g3.set(n, (0 === q ? -1 : 1) * h.length / 2, 0), g3.rotate(n, n, j), g3.add(n, n, i), this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                            var r = this.circleCircle(a, b, m, d, f, h, n, j, k, b.radius, h.radius);
                            if (this.enableFrictionReduction && (this.enableFriction = l), k && r) return !0;
                            o += r;
                        }
                    }
                    this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                    var s = S1;
                    e5(s, b);
                    var t = this.convexCapsule(a, s, c, d, f, h, i, j, k);
                    if (this.enableFrictionReduction && (this.enableFriction = l), k && t) return !0;
                    if (o += t, this.enableFrictionReduction) {
                        var l = this.enableFriction;
                        this.enableFriction = !1;
                    }
                    e5(s, h);
                    var u = this.convexCapsule(f, s, i, j, a, b, c, d, k);
                    return this.enableFrictionReduction && (this.enableFriction = l), !(!k || !u) || (o += u, this.enableFrictionReduction && o && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(o)), o);
                }, d7.prototype[q1.LINE | q1.LINE] = d7.prototype.lineLine = function(a, b, c, d, e, f, g, h, i) {
                    return !i && 0;
                }, d7.prototype[q1.PLANE | q1.LINE] = d7.prototype.planeLine = function(a, b, c, d, e, f, k, l, m) {
                    var n = t1, o = u1, p = v1, q = w1, r = x1, C = y1, D = z1, E = A1, F = B1, G = L1, H = 0;
                    g3.set(n, -f.length / 2, 0), g3.set(o, f.length / 2, 0), g3.rotate(p, n, l), g3.rotate(q, o, l), i2(p, p, k), i2(q, q, k), g3.copy(n, p), g3.copy(o, q), h2(r, o, n), g3.normalize(C, r), g3.rotate90cw(F, C), g3.rotate(E, s1, d), G[0] = n, G[1] = o;
                    for(var I = 0; I < G.length; I++){
                        var J = G[I];
                        h2(D, J, c);
                        var K = j2(D, E);
                        if (K < 0) {
                            if (m) return !0;
                            var M = this.createContactEquation(a, e, b, f);
                            H++, g3.copy(M.normalA, E), g3.normalize(M.normalA, M.normalA), g3.scale(D, E, K), h2(M.contactPointA, J, D), h2(M.contactPointA, M.contactPointA, a.position), h2(M.contactPointB, J, k), i2(M.contactPointB, M.contactPointB, k), h2(M.contactPointB, M.contactPointB, e.position), this.contactEquations.push(M), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M));
                        }
                    }
                    return !m && (this.enableFrictionReduction || H && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(H)), H);
                }, d7.prototype[q1.PARTICLE | q1.CAPSULE] = d7.prototype.particleCapsule = function(a, b, c, d, e, f, g, h, i) {
                    return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius, 0);
                }, d7.prototype[q1.CIRCLE | q1.LINE] = d7.prototype.circleLine = function(a, b, c, d, e, f, k, l, m, n, o) {
                    var n = n || 0, o = void 0 !== o ? o : b.radius, p = t1, q = u1, r = v1, s = w1, H = x1, I = y1, J = z1, K = A1, M = B1, N = C1, O = D1, P = E1, Q = F1, R = G1, S = L1;
                    g3.set(K, -f.length / 2, 0), g3.set(M, f.length / 2, 0), g3.rotate(N, K, l), g3.rotate(O, M, l), i2(N, N, k), i2(O, O, k), g3.copy(K, N), g3.copy(M, O), h2(I, M, K), g3.normalize(J, I), g3.rotate90cw(H, J), h2(P, c, K);
                    var T = j2(P, H);
                    h2(s, K, k), h2(Q, c, k);
                    var U = o + n;
                    if (Math.abs(T) < U) {
                        g3.scale(p, H, T), h2(r, c, p), g3.scale(q, H, j2(H, Q)), g3.normalize(q, q), g3.scale(q, q, n), i2(r, r, q);
                        var V = j2(J, r), W = j2(J, K), X = j2(J, M);
                        if (V > W && V < X) {
                            if (m) return !0;
                            var Y = this.createContactEquation(a, e, b, f);
                            return g3.scale(Y.normalA, p, -1), g3.normalize(Y.normalA, Y.normalA), g3.scale(Y.contactPointA, Y.normalA, o), i2(Y.contactPointA, Y.contactPointA, c), h2(Y.contactPointA, Y.contactPointA, a.position), h2(Y.contactPointB, r, k), i2(Y.contactPointB, Y.contactPointB, k), h2(Y.contactPointB, Y.contactPointB, e.position), this.contactEquations.push(Y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)), 1;
                        }
                    }
                    S[0] = K, S[1] = M;
                    for(var Z = 0; Z < S.length; Z++){
                        var $ = S[Z];
                        if (h2(P, $, c), g3.squaredLength(P) < Math.pow(U, 2)) {
                            if (m) return !0;
                            var Y = this.createContactEquation(a, e, b, f);
                            return g3.copy(Y.normalA, P), g3.normalize(Y.normalA, Y.normalA), g3.scale(Y.contactPointA, Y.normalA, o), i2(Y.contactPointA, Y.contactPointA, c), h2(Y.contactPointA, Y.contactPointA, a.position), h2(Y.contactPointB, $, k), g3.scale(R, Y.normalA, -n), i2(Y.contactPointB, Y.contactPointB, R), i2(Y.contactPointB, Y.contactPointB, k), h2(Y.contactPointB, Y.contactPointB, e.position), this.contactEquations.push(Y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)), 1;
                        }
                    }
                    return 0;
                }, d7.prototype[q1.CIRCLE | q1.CAPSULE] = d7.prototype.circleCapsule = function(a, b, c, d, e, f, g, h, i) {
                    return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius);
                }, d7.prototype[q1.CIRCLE | q1.CONVEX] = d7.prototype[q1.CIRCLE | q1.BOX] = d7.prototype.circleConvex = function(a, b, c, d, e, j, k, l, m, n) {
                    for(var n = "number" == typeof n ? n : b.radius, o = t1, p = u1, q = v1, r = w1, s = x1, y = C1, z = D1, A = F1, B = G1, E = H1, J = I1, K = !1, L = Number.MAX_VALUE, M = j.vertices, N = 0; N !== M.length + 1; N++){
                        var O = M[N % M.length], P = M[(N + 1) % M.length];
                        if (g3.rotate(o, O, l), g3.rotate(p, P, l), i2(o, o, k), i2(p, p, k), h2(q, p, o), g3.normalize(r, q), g3.rotate90cw(s, r), g3.scale(B, s, -b.radius), i2(B, B, c), f3(B, j, k, l)) {
                            g3.sub(E, o, B);
                            var Q = Math.abs(g3.dot(E, s));
                            Q < L && (g3.copy(J, B), L = Q, g3.scale(A, s, Q), g3.add(A, A, B), K = !0);
                        }
                    }
                    if (K) {
                        if (m) return !0;
                        var R = this.createContactEquation(a, e, b, j);
                        return g3.sub(R.normalA, J, c), g3.normalize(R.normalA, R.normalA), g3.scale(R.contactPointA, R.normalA, n), i2(R.contactPointA, R.contactPointA, c), h2(R.contactPointA, R.contactPointA, a.position), h2(R.contactPointB, A, k), i2(R.contactPointB, R.contactPointB, k), h2(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1;
                    }
                    if (n > 0) for(var N = 0; N < M.length; N++){
                        var S = M[N];
                        if (g3.rotate(z, S, l), i2(z, z, k), h2(y, z, c), g3.squaredLength(y) < Math.pow(n, 2)) {
                            if (m) return !0;
                            var R = this.createContactEquation(a, e, b, j);
                            return g3.copy(R.normalA, y), g3.normalize(R.normalA, R.normalA), g3.scale(R.contactPointA, R.normalA, n), i2(R.contactPointA, R.contactPointA, c), h2(R.contactPointA, R.contactPointA, a.position), h2(R.contactPointB, z, k), i2(R.contactPointB, R.contactPointB, k), h2(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1;
                        }
                    }
                    return 0;
                };
                var T1 = g3.create(), U1 = g3.create(), V1 = g3.create(), W1 = g3.create();
                d7.prototype[q1.PARTICLE | q1.CONVEX] = d7.prototype[q1.PARTICLE | q1.BOX] = d7.prototype.particleConvex = function(a, b, c, d, e, k, l, m, n) {
                    var o = t1, p = u1, q = v1, r = w1, s = x1, A = y1, B = z1, D = C1, E = F1, G = J1, H = K1, I = Number.MAX_VALUE, L = !1, M = k.vertices;
                    if (!f3(c, k, l, m)) return 0;
                    if (n) return !0;
                    for(var N = 0; N !== M.length + 1; N++){
                        var O = M[N % M.length], P = M[(N + 1) % M.length];
                        g3.rotate(o, O, m), g3.rotate(p, P, m), i2(o, o, l), i2(p, p, l), h2(q, p, o), g3.normalize(r, q), g3.rotate90cw(s, r), h2(D, c, o);
                        j2(D, s);
                        h2(A, o, l), h2(B, c, l), g3.sub(G, o, c);
                        var Q = Math.abs(g3.dot(G, s));
                        Q < I && (I = Q, g3.scale(E, s, Q), g3.add(E, E, c), g3.copy(H, s), L = !0);
                    }
                    if (L) {
                        var R = this.createContactEquation(a, e, b, k);
                        return g3.scale(R.normalA, H, -1), g3.normalize(R.normalA, R.normalA), g3.set(R.contactPointA, 0, 0), i2(R.contactPointA, R.contactPointA, c), h2(R.contactPointA, R.contactPointA, a.position), h2(R.contactPointB, E, l), i2(R.contactPointB, R.contactPointB, l), h2(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1;
                    }
                    return 0;
                }, d7.prototype[q1.CIRCLE] = d7.prototype.circleCircle = function(a, b, c, d, e, f, j, k, l, m, n) {
                    var o = t1, m = m || b.radius, n = n || f.radius;
                    h2(o, c, j);
                    var p = m + n;
                    if (g3.squaredLength(o) > Math.pow(p, 2)) return 0;
                    if (l) return !0;
                    var q = this.createContactEquation(a, e, b, f);
                    return h2(q.normalA, j, c), g3.normalize(q.normalA, q.normalA), g3.scale(q.contactPointA, q.normalA, m), g3.scale(q.contactPointB, q.normalA, -n), i2(q.contactPointA, q.contactPointA, c), h2(q.contactPointA, q.contactPointA, a.position), i2(q.contactPointB, q.contactPointB, j), h2(q.contactPointB, q.contactPointB, e.position), this.contactEquations.push(q), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(q)), 1;
                }, d7.prototype[q1.PLANE | q1.CONVEX] = d7.prototype[q1.PLANE | q1.BOX] = d7.prototype.planeConvex = function(a, b, c, d, e, f, k, l, m) {
                    var n = t1, o = u1, p = v1, q = 0;
                    g3.rotate(o, s1, d);
                    for(var r = 0; r !== f.vertices.length; r++){
                        var w = f.vertices[r];
                        if (g3.rotate(n, w, l), i2(n, n, k), h2(p, n, c), j2(p, o) <= 0) {
                            if (m) return !0;
                            q++;
                            var x = this.createContactEquation(a, e, b, f);
                            h2(p, n, c), g3.copy(x.normalA, o);
                            var y = j2(p, x.normalA);
                            g3.scale(p, x.normalA, y), h2(x.contactPointB, n, e.position), h2(x.contactPointA, n, p), h2(x.contactPointA, x.contactPointA, a.position), this.contactEquations.push(x), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(x));
                        }
                    }
                    return this.enableFrictionReduction && this.enableFriction && q && this.frictionEquations.push(this.createFrictionFromAverage(q)), q;
                }, d7.prototype[q1.PARTICLE | q1.PLANE] = d7.prototype.particlePlane = function(a, b, c, d, e, f, i, k, l) {
                    var m = t1, n = u1;
                    k = k || 0, h2(m, c, i), g3.rotate(n, s1, k);
                    var o = j2(m, n);
                    if (o > 0) return 0;
                    if (l) return !0;
                    var p = this.createContactEquation(e, a, f, b);
                    return g3.copy(p.normalA, n), g3.scale(m, p.normalA, o), h2(p.contactPointA, c, m), h2(p.contactPointA, p.contactPointA, e.position), h2(p.contactPointB, c, a.position), this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 1;
                }, d7.prototype[q1.CIRCLE | q1.PARTICLE] = d7.prototype.circleParticle = function(a, b, c, d, e, f, j, k, l) {
                    var m = t1;
                    if (h2(m, j, c), g3.squaredLength(m) > Math.pow(b.radius, 2)) return 0;
                    if (l) return !0;
                    var n = this.createContactEquation(a, e, b, f);
                    return g3.copy(n.normalA, m), g3.normalize(n.normalA, n.normalA), g3.scale(n.contactPointA, n.normalA, b.radius), i2(n.contactPointA, n.contactPointA, c), h2(n.contactPointA, n.contactPointA, a.position), h2(n.contactPointB, j, e.position), this.contactEquations.push(n), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(n)), 1;
                };
                var X1 = new o1({
                    radius: 1
                }), Y1 = g3.create(), Z1 = g3.create();
                g3.create();
                d7.prototype[q1.PLANE | q1.CAPSULE] = d7.prototype.planeCapsule = function(a, b, c, d, e, f, h, j, k) {
                    var l = Y1, m = Z1, n = X1;
                    g3.set(l, -f.length / 2, 0), g3.rotate(l, l, j), i2(l, l, h), g3.set(m, f.length / 2, 0), g3.rotate(m, m, j), i2(m, m, h), n.radius = f.radius;
                    var o;
                    this.enableFrictionReduction && (o = this.enableFriction, this.enableFriction = !1);
                    var p = this.circlePlane(e, n, l, 0, a, b, c, d, k), q = this.circlePlane(e, n, m, 0, a, b, c, d, k);
                    if (this.enableFrictionReduction && (this.enableFriction = o), k) return p || q;
                    var r = p + q;
                    return this.enableFrictionReduction && r && this.frictionEquations.push(this.createFrictionFromAverage(r)), r;
                }, d7.prototype[q1.CIRCLE | q1.PLANE] = d7.prototype.circlePlane = function(a, b, c, d, e, f, k, l, m) {
                    var n = a, o = b, p = c, q = e, r = k, w = l;
                    w = w || 0;
                    var x = t1, y = u1, z = v1;
                    h2(x, p, r), g3.rotate(y, s1, w);
                    var A = j2(y, x);
                    if (A > o.radius) return 0;
                    if (m) return !0;
                    var B = this.createContactEquation(q, n, f, b);
                    return g3.copy(B.normalA, y), g3.scale(B.contactPointB, B.normalA, -o.radius), i2(B.contactPointB, B.contactPointB, p), h2(B.contactPointB, B.contactPointB, n.position), g3.scale(z, B.normalA, A), h2(B.contactPointA, x, z), i2(B.contactPointA, B.contactPointA, r), h2(B.contactPointA, B.contactPointA, q.position), this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)), 1;
                }, d7.prototype[q1.CONVEX] = d7.prototype[q1.CONVEX | q1.BOX] = d7.prototype[q1.BOX] = d7.prototype.convexConvex = function(a, b, c, e, f, k, l, m, n, o) {
                    var p = t1, q = u1, r = v1, s = w1, y = x1, C = z1, D = A1, E = B1, F = 0, o = "number" == typeof o ? o : 0;
                    if (!d7.findSeparatingAxis(b, c, e, k, l, m, p)) return 0;
                    h2(D, l, c), j2(p, D) > 0 && g3.scale(p, p, -1);
                    var G = d7.getClosestEdge(b, e, p, !0), H = d7.getClosestEdge(k, m, p);
                    if (-1 === G || -1 === H) return 0;
                    for(var I = 0; I < 2; I++){
                        var J = G, K = H, L = b, M = k, N = c, O = l, P = e, Q = m, R = a, S = f;
                        if (0 === I) {
                            var T;
                            T = J, J = K, K = T, T = L, L = M, M = T, T = N, N = O, O = T, T = P, P = Q, Q = T, T = R, R = S, S = T;
                        }
                        for(var U = K; U < K + 2; U++){
                            var V = M.vertices[(U + M.vertices.length) % M.vertices.length];
                            g3.rotate(q, V, Q), i2(q, q, O);
                            for(var W = 0, X = J - 1; X < J + 2; X++){
                                var Y = L.vertices[(X + L.vertices.length) % L.vertices.length], Z = L.vertices[(X + 1 + L.vertices.length) % L.vertices.length];
                                g3.rotate(r, Y, P), g3.rotate(s, Z, P), i2(r, r, N), i2(s, s, N), h2(y, s, r), g3.rotate90cw(E, y), g3.normalize(E, E), h2(D, q, r);
                                var $ = j2(E, D);
                                (X === J && $ <= o || X !== J && $ <= 0) && W++;
                            }
                            if (W >= 3) {
                                if (n) return !0;
                                var _ = this.createContactEquation(R, S, L, M);
                                F++;
                                var Y = L.vertices[J % L.vertices.length], Z = L.vertices[(J + 1) % L.vertices.length];
                                g3.rotate(r, Y, P), g3.rotate(s, Z, P), i2(r, r, N), i2(s, s, N), h2(y, s, r), g3.rotate90cw(_.normalA, y), g3.normalize(_.normalA, _.normalA), h2(D, q, r);
                                var $ = j2(_.normalA, D);
                                g3.scale(C, _.normalA, $), h2(_.contactPointA, q, N), h2(_.contactPointA, _.contactPointA, C), i2(_.contactPointA, _.contactPointA, N), h2(_.contactPointA, _.contactPointA, R.position), h2(_.contactPointB, q, O), i2(_.contactPointB, _.contactPointB, O), h2(_.contactPointB, _.contactPointB, S.position), this.contactEquations.push(_), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(_));
                            }
                        }
                    }
                    return this.enableFrictionReduction && this.enableFriction && F && this.frictionEquations.push(this.createFrictionFromAverage(F)), F;
                };
                var $1 = g3.fromValues(0, 0);
                d7.projectConvexOntoAxis = function(a, b, c, d, e) {
                    var f, h, i = null, k = null, l = $1;
                    g3.rotate(l, d, -c);
                    for(var m = 0; m < a.vertices.length; m++)f = a.vertices[m], h = j2(f, l), (null === i || h > i) && (i = h), (null === k || h < k) && (k = h);
                    if (k > i) {
                        var n = k;
                        k = i, i = n;
                    }
                    var o = j2(b, d);
                    g3.set(e, k + o, i + o);
                };
                var _1 = g3.fromValues(0, 0), aa = g3.fromValues(0, 0), ba = g3.fromValues(0, 0), ca = g3.fromValues(0, 0), da = g3.fromValues(0, 0), ea = g3.fromValues(0, 0);
                d7.findSeparatingAxis = function(a, b, c, e, f, i, j) {
                    var k = null, l = !1, m = !1, n = _1, o = aa, p = ba, q = ca, s = da, t = ea;
                    if (a instanceof r1 && e instanceof r1) for(var u = 0; 2 !== u; u++){
                        var v = a, w = c;
                        1 === u && (v = e, w = i);
                        for(var x = 0; 2 !== x; x++){
                            0 === x ? g3.set(q, 0, 1) : 1 === x && g3.set(q, 1, 0), 0 !== w && g3.rotate(q, q, w), d7.projectConvexOntoAxis(a, b, c, q, s), d7.projectConvexOntoAxis(e, f, i, q, t);
                            var y = s, z = t;
                            s[0] > t[0] && (z = s, y = t);
                            var A = z[0] - y[1];
                            l = A <= 0, (null === k || A > k) && (g3.copy(j, q), k = A, m = l);
                        }
                    }
                    else for(var u = 0; 2 !== u; u++){
                        var v = a, w = c;
                        1 === u && (v = e, w = i);
                        for(var x = 0; x !== v.vertices.length; x++){
                            g3.rotate(o, v.vertices[x], w), g3.rotate(p, v.vertices[(x + 1) % v.vertices.length], w), h2(n, p, o), g3.rotate90cw(q, n), g3.normalize(q, q), d7.projectConvexOntoAxis(a, b, c, q, s), d7.projectConvexOntoAxis(e, f, i, q, t);
                            var y = s, z = t;
                            s[0] > t[0] && (z = s, y = t);
                            var A = z[0] - y[1];
                            l = A <= 0, (null === k || A > k) && (g3.copy(j, q), k = A, m = l);
                        }
                    }
                    return m;
                };
                var fa = g3.fromValues(0, 0), ga = g3.fromValues(0, 0), ha = g3.fromValues(0, 0);
                d7.getClosestEdge = function(a, b, c, d) {
                    var e = fa, f = ga, i = ha;
                    g3.rotate(e, c, -b), d && g3.scale(e, e, -1);
                    for(var k = -1, l = a.vertices.length, m = -1, n = 0; n !== l; n++){
                        h2(f, a.vertices[(n + 1) % l], a.vertices[n % l]), g3.rotate90cw(i, f), g3.normalize(i, i);
                        var o = j2(i, e);
                        (-1 === k || o > m) && (k = n % l, m = o);
                    }
                    return k;
                };
                var ia = g3.create(), ja = g3.create(), ka = g3.create(), la = g3.create(), ma = g3.create(), na = g3.create(), oa = g3.create();
                d7.prototype[q1.CIRCLE | q1.HEIGHTFIELD] = d7.prototype.circleHeightfield = function(a, b, c, d, e, f, j, k, l, m) {
                    var n = f.heights, m = m || b.radius, o = f.elementWidth, p = ja, q = ia, r = ma, s = oa, t = na, u = ka, v = la, w = Math.floor((c[0] - m - j[0]) / o), x = Math.ceil((c[0] + m - j[0]) / o);
                    w < 0 && (w = 0), x >= n.length && (x = n.length - 1);
                    for(var y = n[w], z = n[x], A = w; A < x; A++)n[A] < z && (z = n[A]), n[A] > y && (y = n[A]);
                    if (c[1] - m > y) return !l && 0;
                    for(var B = !1, A = w; A < x; A++){
                        g3.set(u, A * o, n[A]), g3.set(v, (A + 1) * o, n[A + 1]), g3.add(u, u, j), g3.add(v, v, j), g3.sub(t, v, u), g3.rotate(t, t, Math.PI / 2), g3.normalize(t, t), g3.scale(q, t, -m), g3.add(q, q, c), g3.sub(p, q, u);
                        var C = g3.dot(p, t);
                        if (q[0] >= u[0] && q[0] < v[0] && C <= 0) {
                            if (l) return !0;
                            B = !0, g3.scale(p, t, -C), g3.add(r, q, p), g3.copy(s, t);
                            var D = this.createContactEquation(e, a, f, b);
                            g3.copy(D.normalA, s), g3.scale(D.contactPointB, D.normalA, -m), i2(D.contactPointB, D.contactPointB, c), h2(D.contactPointB, D.contactPointB, a.position), g3.copy(D.contactPointA, r), g3.sub(D.contactPointA, D.contactPointA, e.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D));
                        }
                    }
                    if (B = !1, m > 0) {
                        for(var A = w; A <= x; A++)if (g3.set(u, A * o, n[A]), g3.add(u, u, j), g3.sub(p, c, u), g3.squaredLength(p) < Math.pow(m, 2)) {
                            if (l) return !0;
                            B = !0;
                            var D = this.createContactEquation(e, a, f, b);
                            g3.copy(D.normalA, p), g3.normalize(D.normalA, D.normalA), g3.scale(D.contactPointB, D.normalA, -m), i2(D.contactPointB, D.contactPointB, c), h2(D.contactPointB, D.contactPointB, a.position), h2(D.contactPointA, u, j), i2(D.contactPointA, D.contactPointA, j), h2(D.contactPointA, D.contactPointA, e.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D));
                        }
                    }
                    return B ? 1 : 0;
                };
                var pa = g3.create(), qa = g3.create(), ra = g3.create(), sa = new p1({
                    vertices: [
                        g3.create(),
                        g3.create(),
                        g3.create(),
                        g3.create()
                    ]
                });
                d7.prototype[q1.BOX | q1.HEIGHTFIELD] = d7.prototype[q1.CONVEX | q1.HEIGHTFIELD] = d7.prototype.convexHeightfield = function(a, b, c, d, e, f, h, i, j) {
                    var k = f.heights, l = f.elementWidth, m = pa, n = qa, o = ra, p = sa, q = Math.floor((a.aabb.lowerBound[0] - h[0]) / l), r = Math.ceil((a.aabb.upperBound[0] - h[0]) / l);
                    q < 0 && (q = 0), r >= k.length && (r = k.length - 1);
                    for(var s = k[q], t = k[r], u = q; u < r; u++)k[u] < t && (t = k[u]), k[u] > s && (s = k[u]);
                    if (a.aabb.lowerBound[1] > s) return !j && 0;
                    for(var v = 0, u = q; u < r; u++){
                        g3.set(m, u * l, k[u]), g3.set(n, (u + 1) * l, k[u + 1]), g3.add(m, m, h), g3.add(n, n, h);
                        var w = 100;
                        g3.set(o, 0.5 * (n[0] + m[0]), 0.5 * (n[1] + m[1] - w)), g3.sub(p.vertices[0], n, o), g3.sub(p.vertices[1], m, o), g3.copy(p.vertices[2], p.vertices[1]), g3.copy(p.vertices[3], p.vertices[0]), p.vertices[2][1] -= w, p.vertices[3][1] -= w, v += this.convexConvex(a, b, c, d, e, p, o, 0, j);
                    }
                    return v;
                };
            },
            {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../shapes/Box": 37,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Shape": 45,
                "../utils/ContactEquationPool": 48,
                "../utils/FrictionEquationPool": 49,
                "../utils/TupleDictionary": 56,
                "../utils/Utils": 57
            }
        ],
        11: [
            function(a10, b9, c10) {
                function d8(a) {
                    a = a || {}, this.from = a.from ? f4.fromValues(a.from[0], a.from[1]) : f4.create(), this.to = a.to ? f4.fromValues(a.to[0], a.to[1]) : f4.create(), this.checkCollisionResponse = void 0 === a.checkCollisionResponse || a.checkCollisionResponse, this.skipBackfaces = !!a.skipBackfaces, this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : -1, this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : -1, this.mode = void 0 !== a.mode ? a.mode : d8.ANY, this.callback = a.callback || function(a) {}, this.direction = f4.create(), this.length = 1, this.update();
                }
                function e6(a, b, c) {
                    f4.sub(h3, c, a);
                    var d = f4.dot(h3, b);
                    return f4.scale(i3, b, d), f4.add(i3, i3, a), f4.squaredDistance(c, i3);
                }
                b9.exports = d8;
                var f4 = a10("../math/vec2");
                a10("../collision/RaycastResult"), a10("../shapes/Shape"), a10("../collision/AABB");
                d8.prototype.constructor = d8, d8.CLOSEST = 1, d8.ANY = 2, d8.ALL = 4, d8.prototype.update = function() {
                    var a = this.direction;
                    f4.sub(a, this.to, this.from), this.length = f4.length(a), f4.normalize(a, a);
                }, d8.prototype.intersectBodies = function(a, b) {
                    for(var c = 0, d = b.length; !a.shouldStop(this) && c < d; c++){
                        var e = b[c], f = e.getAABB();
                        (f.overlapsRay(this) >= 0 || f.containsPoint(this.from)) && this.intersectBody(a, e);
                    }
                };
                var g4 = f4.create();
                d8.prototype.intersectBody = function(a, b) {
                    var c = this.checkCollisionResponse;
                    if (!c || b.collisionResponse) for(var d = g4, e = 0, h = b.shapes.length; e < h; e++){
                        var i = b.shapes[e];
                        if ((!c || i.collisionResponse) && 0 != (this.collisionGroup & i.collisionMask) && 0 != (i.collisionGroup & this.collisionMask)) {
                            f4.rotate(d, i.position, b.angle), f4.add(d, d, b.position);
                            var j = i.angle + b.angle;
                            if (this.intersectShape(a, i, j, d, b), a.shouldStop(this)) break;
                        }
                    }
                }, d8.prototype.intersectShape = function(a, b, c, d, f) {
                    e6(this.from, this.direction, d) > b.boundingRadius * b.boundingRadius || (this._currentBody = f, this._currentShape = b, b.raycast(a, this, d, c), this._currentBody = this._currentShape = null);
                }, d8.prototype.getAABB = function(a) {
                    var b = this.to, c = this.from;
                    f4.set(a.lowerBound, Math.min(b[0], c[0]), Math.min(b[1], c[1])), f4.set(a.upperBound, Math.max(b[0], c[0]), Math.max(b[1], c[1]));
                };
                f4.create();
                d8.prototype.reportIntersection = function(a, b, c, e) {
                    var g = (this.from, this.to, this._currentShape), h = this._currentBody;
                    if (!(this.skipBackfaces && f4.dot(c, this.direction) > 0)) switch(this.mode){
                        case d8.ALL:
                            a.set(c, g, h, b, e), this.callback(a);
                            break;
                        case d8.CLOSEST:
                            (b < a.fraction || !a.hasHit()) && a.set(c, g, h, b, e);
                            break;
                        case d8.ANY:
                            a.set(c, g, h, b, e);
                    }
                };
                var h3 = f4.create(), i3 = f4.create();
            },
            {
                "../collision/AABB": 7,
                "../collision/RaycastResult": 12,
                "../math/vec2": 30,
                "../shapes/Shape": 45
            }
        ],
        12: [
            function(a11, b10, c11) {
                function d9() {
                    this.normal = e.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1;
                }
                var e = a11("../math/vec2"), f5 = a11("../collision/Ray");
                b10.exports = d9, d9.prototype.reset = function() {
                    e.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1;
                }, d9.prototype.getHitDistance = function(a) {
                    return e.distance(a.from, a.to) * this.fraction;
                }, d9.prototype.hasHit = function() {
                    return -1 !== this.fraction;
                }, d9.prototype.getHitPoint = function(a, b) {
                    e.lerp(a, b.from, b.to, this.fraction);
                }, d9.prototype.stop = function() {
                    this.isStopped = !0;
                }, d9.prototype.shouldStop = function(a) {
                    return this.isStopped || -1 !== this.fraction && a.mode === f5.ANY;
                }, d9.prototype.set = function(a, b, c, d, f) {
                    e.copy(this.normal, a), this.shape = b, this.body = c, this.fraction = d, this.faceIndex = f;
                };
            },
            {
                "../collision/Ray": 11,
                "../math/vec2": 30
            }
        ],
        13: [
            function(a12, b11, c12) {
                function d10() {
                    f6.call(this, f6.SAP), this.axisList = [], this.axisIndex = 0;
                    var a = this;
                    this._addBodyHandler = function(b) {
                        a.axisList.push(b.body);
                    }, this._removeBodyHandler = function(b) {
                        var c = a.axisList.indexOf(b.body);
                        -1 !== c && a.axisList.splice(c, 1);
                    };
                }
                var e7 = a12("../utils/Utils"), f6 = a12("../collision/Broadphase");
                b11.exports = d10, d10.prototype = new f6, d10.prototype.constructor = d10, d10.prototype.setWorld = function(a) {
                    this.axisList.length = 0, e7.appendArray(this.axisList, a.bodies), a.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), a.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = a;
                }, d10.sortAxisList = function(a, b) {
                    b |= 0;
                    for(var c = 1, d = a.length; c < d; c++){
                        for(var e = a[c], f = c - 1; f >= 0 && !(a[f].aabb.lowerBound[b] <= e.aabb.lowerBound[b]); f--)a[f + 1] = a[f];
                        a[f + 1] = e;
                    }
                    return a;
                }, d10.prototype.sortList = function() {
                    var a = this.axisList, b = this.axisIndex;
                    d10.sortAxisList(a, b);
                }, d10.prototype.getCollisionPairs = function(a) {
                    var b = this.axisList, c = this.result, d = this.axisIndex;
                    c.length = 0;
                    for(var e = b.length; e--;){
                        var g = b[e];
                        g.aabbNeedsUpdate && g.updateAABB();
                    }
                    this.sortList();
                    for(var h = 0, i = 0 | b.length; h !== i; h++)for(var j = b[h], k = h + 1; k < i; k++){
                        var l = b[k], m = l.aabb.lowerBound[d] <= j.aabb.upperBound[d];
                        if (!m) break;
                        f6.canCollide(j, l) && this.boundingVolumeCheck(j, l) && c.push(j, l);
                    }
                    return c;
                }, d10.prototype.aabbQuery = function(a, b, c) {
                    c = c || [], this.sortList();
                    var d = this.axisIndex, e = "x";
                    1 === d && (e = "y"), 2 === d && (e = "z");
                    for(var f = this.axisList, g = (b.lowerBound[e], b.upperBound[e], 0); g < f.length; g++){
                        var h = f[g];
                        h.aabbNeedsUpdate && h.updateAABB(), h.aabb.overlaps(b) && c.push(h);
                    }
                    return c;
                };
            },
            {
                "../collision/Broadphase": 8,
                "../utils/Utils": 57
            }
        ],
        14: [
            function(a13, b12, c13) {
                function d11(a, b, c, d) {
                    this.type = c, d = e.defaults(d, {
                        collideConnected: !0,
                        wakeUpBodies: !0
                    }), this.equations = [], this.bodyA = a, this.bodyB = b, this.collideConnected = d.collideConnected, d.wakeUpBodies && (a && a.wakeUp(), b && b.wakeUp());
                }
                b12.exports = d11;
                var e = a13("../utils/Utils");
                d11.prototype.update = function() {
                    throw new Error("method update() not implmemented in this Constraint subclass!");
                }, d11.DISTANCE = 1, d11.GEAR = 2, d11.LOCK = 3, d11.PRISMATIC = 4, d11.REVOLUTE = 5, d11.prototype.setStiffness = function(a) {
                    for(var b = this.equations, c = 0; c !== b.length; c++){
                        var d = b[c];
                        d.stiffness = a, d.needsUpdate = !0;
                    }
                }, d11.prototype.setRelaxation = function(a) {
                    for(var b = this.equations, c = 0; c !== b.length; c++){
                        var d = b[c];
                        d.relaxation = a, d.needsUpdate = !0;
                    }
                };
            },
            {
                "../utils/Utils": 57
            }
        ],
        15: [
            function(a14, b13, c14) {
                function d12(a15, b14, c15) {
                    c15 = h4.defaults(c15, {
                        localAnchorA: [
                            0,
                            0
                        ],
                        localAnchorB: [
                            0,
                            0
                        ]
                    }), e8.call(this, a15, b14, e8.DISTANCE, c15), this.localAnchorA = g.fromValues(c15.localAnchorA[0], c15.localAnchorA[1]), this.localAnchorB = g.fromValues(c15.localAnchorB[0], c15.localAnchorB[1]);
                    var d = this.localAnchorA, i = this.localAnchorB;
                    if (this.distance = 0, "number" == typeof c15.distance) this.distance = c15.distance;
                    else {
                        var j = g.create(), k = g.create(), l = g.create();
                        g.rotate(j, d, a15.angle), g.rotate(k, i, b14.angle), g.add(l, b14.position, k), g.sub(l, l, j), g.sub(l, l, a15.position), this.distance = g.length(l);
                    }
                    var m;
                    m = void 0 === c15.maxForce ? Number.MAX_VALUE : c15.maxForce;
                    var n = new f7(a15, b14, -m, m);
                    this.equations = [
                        n
                    ], this.maxForce = m;
                    var l = g.create(), o = g.create(), p = g.create(), q = this;
                    n.computeGq = function() {
                        var a = this.bodyA, b = this.bodyB, c = a.position, e = b.position;
                        return g.rotate(o, d, a.angle), g.rotate(p, i, b.angle), g.add(l, e, p), g.sub(l, l, o), g.sub(l, l, c), g.length(l) - q.distance;
                    }, this.setMaxForce(m), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0;
                }
                var e8 = a14("./Constraint"), f7 = a14("../equations/Equation"), g = a14("../math/vec2"), h4 = a14("../utils/Utils");
                b13.exports = d12, d12.prototype = new e8, d12.prototype.constructor = d12;
                var i4 = g.create(), j3 = g.create(), k2 = g.create();
                d12.prototype.update = function() {
                    var a = this.equations[0], b = this.bodyA, c = this.bodyB, d = (this.distance, b.position), e = c.position, f = this.equations[0], h = a.G;
                    g.rotate(j3, this.localAnchorA, b.angle), g.rotate(k2, this.localAnchorB, c.angle), g.add(i4, e, k2), g.sub(i4, i4, j3), g.sub(i4, i4, d), this.position = g.length(i4);
                    var l = !1;
                    if (this.upperLimitEnabled && this.position > this.upperLimit && (f.maxForce = 0, f.minForce = -this.maxForce, this.distance = this.upperLimit, l = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (f.maxForce = this.maxForce, f.minForce = 0, this.distance = this.lowerLimit, l = !0), (this.lowerLimitEnabled || this.upperLimitEnabled) && !l) return void (f.enabled = !1);
                    f.enabled = !0, g.normalize(i4, i4);
                    var m = g.crossLength(j3, i4), n = g.crossLength(k2, i4);
                    h[0] = -i4[0], h[1] = -i4[1], h[2] = -m, h[3] = i4[0], h[4] = i4[1], h[5] = n;
                }, d12.prototype.setMaxForce = function(a) {
                    var b = this.equations[0];
                    b.minForce = -a, b.maxForce = a;
                }, d12.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce;
                };
            },
            {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Constraint": 14
            }
        ],
        16: [
            function(a16, b15, c16) {
                function d(a, b, c) {
                    c = c || {}, e.call(this, a, b, e.GEAR, c), this.ratio = void 0 !== c.ratio ? c.ratio : 1, this.angle = void 0 !== c.angle ? c.angle : b.angle - this.ratio * a.angle, c.angle = this.angle, c.ratio = this.ratio, this.equations = [
                        new f(a, b, c)
                    ], void 0 !== c.maxTorque && this.setMaxTorque(c.maxTorque);
                }
                var e = a16("./Constraint"), f = (a16("../equations/Equation"), a16("../equations/AngleLockEquation"));
                a16("../math/vec2");
                b15.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.update = function() {
                    var a = this.equations[0];
                    a.ratio !== this.ratio && a.setRatio(this.ratio), a.angle = this.angle;
                }, d.prototype.setMaxTorque = function(a) {
                    this.equations[0].setMaxTorque(a);
                }, d.prototype.getMaxTorque = function(a) {
                    return this.equations[0].maxForce;
                };
            },
            {
                "../equations/AngleLockEquation": 20,
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        17: [
            function(a17, b16, c17) {
                function d13(a, b, c) {
                    c = c || {}, e9.call(this, a, b, e9.LOCK, c);
                    var d = void 0 === c.maxForce ? Number.MAX_VALUE : c.maxForce, h = (c.localAngleB, new g(a, b, -d, d)), i = new g(a, b, -d, d), j = new g(a, b, -d, d), k = f.create(), l = f.create(), m = this;
                    h.computeGq = function() {
                        return f.rotate(k, m.localOffsetB, a.angle), f.sub(l, b.position, a.position), f.sub(l, l, k), l[0];
                    }, i.computeGq = function() {
                        return f.rotate(k, m.localOffsetB, a.angle), f.sub(l, b.position, a.position), f.sub(l, l, k), l[1];
                    };
                    var n = f.create(), o = f.create();
                    j.computeGq = function() {
                        return f.rotate(n, m.localOffsetB, b.angle - m.localAngleB), f.scale(n, n, -1), f.sub(l, a.position, b.position), f.add(l, l, n), f.rotate(o, n, -Math.PI / 2), f.normalize(o, o), f.dot(l, o);
                    }, this.localOffsetB = f.create(), c.localOffsetB ? f.copy(this.localOffsetB, c.localOffsetB) : (f.sub(this.localOffsetB, b.position, a.position), f.rotate(this.localOffsetB, this.localOffsetB, -a.angle)), this.localAngleB = 0, "number" == typeof c.localAngleB ? this.localAngleB = c.localAngleB : this.localAngleB = b.angle - a.angle, this.equations.push(h, i, j), this.setMaxForce(d);
                }
                var e9 = a17("./Constraint"), f = a17("../math/vec2"), g = a17("../equations/Equation");
                b16.exports = d13, d13.prototype = new e9, d13.prototype.constructor = d13, d13.prototype.setMaxForce = function(a) {
                    for(var b = this.equations, c = 0; c < this.equations.length; c++)b[c].maxForce = a, b[c].minForce = -a;
                }, d13.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce;
                };
                var h5 = f.create(), i5 = f.create(), j4 = f.create(), k3 = f.fromValues(1, 0), l2 = f.fromValues(0, 1);
                d13.prototype.update = function() {
                    var a = this.equations[0], b = this.equations[1], c = this.equations[2], d = this.bodyA, e = this.bodyB;
                    f.rotate(h5, this.localOffsetB, d.angle), f.rotate(i5, this.localOffsetB, e.angle - this.localAngleB), f.scale(i5, i5, -1), f.rotate(j4, i5, Math.PI / 2), f.normalize(j4, j4), a.G[0] = -1, a.G[1] = 0, a.G[2] = -f.crossLength(h5, k3), a.G[3] = 1, b.G[0] = 0, b.G[1] = -1, b.G[2] = -f.crossLength(h5, l2), b.G[4] = 1, c.G[0] = -j4[0], c.G[1] = -j4[1], c.G[3] = j4[0], c.G[4] = j4[1], c.G[5] = f.crossLength(i5, j4);
                };
            },
            {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        18: [
            function(a18, b17, c18) {
                function d14(a19, b18, c19) {
                    c19 = c19 || {}, e10.call(this, a19, b18, e10.PRISMATIC, c19);
                    var d15 = h.fromValues(0, 0), j = h.fromValues(1, 0), k = h.fromValues(0, 0);
                    c19.localAnchorA && h.copy(d15, c19.localAnchorA), c19.localAxisA && h.copy(j, c19.localAxisA), c19.localAnchorB && h.copy(k, c19.localAnchorB), this.localAnchorA = d15, this.localAnchorB = k, this.localAxisA = j;
                    var l = this.maxForce = void 0 !== c19.maxForce ? c19.maxForce : Number.MAX_VALUE, m = new g5(a19, b18, -l, l), n = new h.create, o = new h.create, p = new h.create, q = new h.create;
                    if (m.computeGq = function() {
                        return h.dot(p, q);
                    }, m.updateJacobian = function() {
                        var c = this.G, e = a19.position, f = b18.position;
                        h.rotate(n, d15, a19.angle), h.rotate(o, k, b18.angle), h.add(p, f, o), h.sub(p, p, e), h.sub(p, p, n), h.rotate(q, j, a19.angle + Math.PI / 2), c[0] = -q[0], c[1] = -q[1], c[2] = -h.crossLength(n, q) + h.crossLength(q, p), c[3] = q[0], c[4] = q[1], c[5] = h.crossLength(o, q);
                    }, this.equations.push(m), !c19.disableRotationalLock) {
                        var r = new i6(a19, b18, -l, l);
                        this.equations.push(r);
                    }
                    this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== c19.lowerLimit, this.upperLimitEnabled = void 0 !== c19.upperLimit, this.lowerLimit = void 0 !== c19.lowerLimit ? c19.lowerLimit : 0, this.upperLimit = void 0 !== c19.upperLimit ? c19.upperLimit : 1, this.upperLimitEquation = new f8(a19, b18), this.lowerLimitEquation = new f8(a19, b18), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = l, this.motorEquation = new g5(a19, b18), this.motorEnabled = !1, this.motorSpeed = 0;
                    var s = this, t = this.motorEquation;
                    t.computeGW;
                    t.computeGq = function() {
                        return 0;
                    }, t.computeGW = function() {
                        var a = this.G, b = this.bodyA, c = this.bodyB, d = b.velocity, e = c.velocity, f = b.angularVelocity, g = c.angularVelocity;
                        return this.gmult(a, d, f, e, g) + s.motorSpeed;
                    };
                }
                var e10 = a18("./Constraint"), f8 = a18("../equations/ContactEquation"), g5 = a18("../equations/Equation"), h = a18("../math/vec2"), i6 = a18("../equations/RotationalLockEquation");
                b17.exports = d14, d14.prototype = new e10, d14.prototype.constructor = d14;
                var j5 = h.create(), k4 = h.create(), l3 = h.create(), m2 = h.create(), n2 = h.create(), o2 = h.create();
                d14.prototype.update = function() {
                    var a = this.equations, b = a[0], c = this.upperLimit, d = this.lowerLimit, e = this.upperLimitEquation, f = this.lowerLimitEquation, g = this.bodyA, i = this.bodyB, p = this.localAxisA, q = this.localAnchorA, r = this.localAnchorB;
                    b.updateJacobian(), h.rotate(j5, p, g.angle), h.rotate(m2, q, g.angle), h.add(k4, m2, g.position), h.rotate(n2, r, i.angle), h.add(l3, n2, i.position);
                    var s = this.position = h.dot(l3, j5) - h.dot(k4, j5);
                    if (this.motorEnabled) {
                        var t = this.motorEquation.G;
                        t[0] = j5[0], t[1] = j5[1], t[2] = h.crossLength(j5, n2), t[3] = -j5[0], t[4] = -j5[1], t[5] = -h.crossLength(j5, m2);
                    }
                    if (this.upperLimitEnabled && s > c) h.scale(e.normalA, j5, -1), h.sub(e.contactPointA, k4, g.position), h.sub(e.contactPointB, l3, i.position), h.scale(o2, j5, c), h.add(e.contactPointA, e.contactPointA, o2), -1 === a.indexOf(e) && a.push(e);
                    else {
                        var u = a.indexOf(e);
                        -1 !== u && a.splice(u, 1);
                    }
                    if (this.lowerLimitEnabled && s < d) h.scale(f.normalA, j5, 1), h.sub(f.contactPointA, k4, g.position), h.sub(f.contactPointB, l3, i.position), h.scale(o2, j5, d), h.sub(f.contactPointB, f.contactPointB, o2), -1 === a.indexOf(f) && a.push(f);
                    else {
                        var u = a.indexOf(f);
                        -1 !== u && a.splice(u, 1);
                    }
                }, d14.prototype.enableMotor = function() {
                    this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0);
                }, d14.prototype.disableMotor = function() {
                    if (this.motorEnabled) {
                        var a = this.equations.indexOf(this.motorEquation);
                        this.equations.splice(a, 1), this.motorEnabled = !1;
                    }
                }, d14.prototype.setLimits = function(a, b) {
                    "number" == typeof a ? (this.lowerLimit = a, this.lowerLimitEnabled = !0) : (this.lowerLimit = a, this.lowerLimitEnabled = !1), "number" == typeof b ? (this.upperLimit = b, this.upperLimitEnabled = !0) : (this.upperLimit = b, this.upperLimitEnabled = !1);
                };
            },
            {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        19: [
            function(a20, b19, c20) {
                function d16(a, b, c) {
                    c = c || {}, e11.call(this, a, b, e11.REVOLUTE, c);
                    var d = this.maxForce = void 0 !== c.maxForce ? c.maxForce : Number.MAX_VALUE;
                    this.pivotA = i.create(), this.pivotB = i.create(), c.worldPivot ? (i.sub(this.pivotA, c.worldPivot, a.position), i.sub(this.pivotB, c.worldPivot, b.position), i.rotate(this.pivotA, this.pivotA, -a.angle), i.rotate(this.pivotB, this.pivotB, -b.angle)) : (i.copy(this.pivotA, c.localPivotA), i.copy(this.pivotB, c.localPivotB));
                    var o = this.equations = [
                        new f9(a, b, -d, d),
                        new f9(a, b, -d, d)
                    ], p = o[0], q = o[1], r = this;
                    p.computeGq = function() {
                        return i.rotate(j, r.pivotA, a.angle), i.rotate(k, r.pivotB, b.angle), i.add(n3, b.position, k), i.sub(n3, n3, a.position), i.sub(n3, n3, j), i.dot(n3, l);
                    }, q.computeGq = function() {
                        return i.rotate(j, r.pivotA, a.angle), i.rotate(k, r.pivotB, b.angle), i.add(n3, b.position, k), i.sub(n3, n3, a.position), i.sub(n3, n3, j), i.dot(n3, m);
                    }, q.minForce = p.minForce = -d, q.maxForce = p.maxForce = d, this.motorEquation = new g6(a, b), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new h6(a, b), this.lowerLimitEquation = new h6(a, b), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0;
                }
                var e11 = a20("./Constraint"), f9 = a20("../equations/Equation"), g6 = a20("../equations/RotationalVelocityEquation"), h6 = a20("../equations/RotationalLockEquation"), i = a20("../math/vec2");
                b19.exports = d16;
                var j = i.create(), k = i.create(), l = i.fromValues(1, 0), m = i.fromValues(0, 1), n3 = i.create();
                d16.prototype = new e11, d16.prototype.constructor = d16, d16.prototype.setLimits = function(a, b) {
                    "number" == typeof a ? (this.lowerLimit = a, this.lowerLimitEnabled = !0) : (this.lowerLimit = a, this.lowerLimitEnabled = !1), "number" == typeof b ? (this.upperLimit = b, this.upperLimitEnabled = !0) : (this.upperLimit = b, this.upperLimitEnabled = !1);
                }, d16.prototype.update = function() {
                    var a = this.bodyA, b = this.bodyB, c = this.pivotA, d = this.pivotB, e = this.equations, f = (e[0], e[1], e[0]), g = e[1], h = this.upperLimit, n = this.lowerLimit, o = this.upperLimitEquation, p = this.lowerLimitEquation, q = this.angle = b.angle - a.angle;
                    if (this.upperLimitEnabled && q > h) o.angle = h, -1 === e.indexOf(o) && e.push(o);
                    else {
                        var r = e.indexOf(o);
                        -1 !== r && e.splice(r, 1);
                    }
                    if (this.lowerLimitEnabled && q < n) p.angle = n, -1 === e.indexOf(p) && e.push(p);
                    else {
                        var r = e.indexOf(p);
                        -1 !== r && e.splice(r, 1);
                    }
                    i.rotate(j, c, a.angle), i.rotate(k, d, b.angle), f.G[0] = -1, f.G[1] = 0, f.G[2] = -i.crossLength(j, l), f.G[3] = 1, f.G[4] = 0, f.G[5] = i.crossLength(k, l), g.G[0] = 0, g.G[1] = -1, g.G[2] = -i.crossLength(j, m), g.G[3] = 0, g.G[4] = 1, g.G[5] = i.crossLength(k, m);
                }, d16.prototype.enableMotor = function() {
                    this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0);
                }, d16.prototype.disableMotor = function() {
                    if (this.motorEnabled) {
                        var a = this.equations.indexOf(this.motorEquation);
                        this.equations.splice(a, 1), this.motorEnabled = !1;
                    }
                }, d16.prototype.motorIsEnabled = function() {
                    return !!this.motorEnabled;
                }, d16.prototype.setMotorSpeed = function(a) {
                    if (this.motorEnabled) {
                        var b = this.equations.indexOf(this.motorEquation);
                        this.equations[b].relativeVelocity = a;
                    }
                }, d16.prototype.getMotorSpeed = function() {
                    return !!this.motorEnabled && this.motorEquation.relativeVelocity;
                };
            },
            {
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../equations/RotationalVelocityEquation": 25,
                "../math/vec2": 30,
                "./Constraint": 14
            }
        ],
        20: [
            function(a21, b20, c21) {
                function d(a, b, c) {
                    c = c || {}, e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = c.angle || 0, this.ratio = "number" == typeof c.ratio ? c.ratio : 1, this.setRatio(this.ratio);
                }
                var e = a21("./Equation");
                a21("../math/vec2");
                b20.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeGq = function() {
                    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
                }, d.prototype.setRatio = function(a) {
                    var b = this.G;
                    b[2] = a, b[5] = -1, this.ratio = a;
                }, d.prototype.setMaxTorque = function(a) {
                    this.maxForce = a, this.minForce = -a;
                };
            },
            {
                "../math/vec2": 30,
                "./Equation": 22
            }
        ],
        21: [
            function(a22, b21, c22) {
                function d17(a, b) {
                    e12.call(this, a, b, 0, Number.MAX_VALUE), this.contactPointA = f.create(), this.penetrationVec = f.create(), this.contactPointB = f.create(), this.normalA = f.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null;
                }
                var e12 = a22("./Equation"), f = a22("../math/vec2");
                b21.exports = d17, d17.prototype = new e12, d17.prototype.constructor = d17, d17.prototype.computeB = function(a, b, c) {
                    var d = this.bodyA, e = this.bodyB, g = this.contactPointA, h = this.contactPointB, i = d.position, j = e.position, k = this.penetrationVec, l = this.normalA, m = this.G, n = f.crossLength(g, l), o = f.crossLength(h, l);
                    m[0] = -l[0], m[1] = -l[1], m[2] = -n, m[3] = l[0], m[4] = l[1], m[5] = o, f.add(k, j, h), f.sub(k, k, i), f.sub(k, k, g);
                    var p, q;
                    return this.firstImpact && 0 !== this.restitution ? (q = 0, p = 1 / b * (1 + this.restitution) * this.computeGW()) : (q = f.dot(l, k) + this.offset, p = this.computeGW()), -q * a - p * b - c * this.computeGiMf();
                };
                var g7 = f.create(), h7 = f.create(), i7 = f.create();
                d17.prototype.getVelocityAlongNormal = function() {
                    return this.bodyA.getVelocityAtPoint(g7, this.contactPointA), this.bodyB.getVelocityAtPoint(h7, this.contactPointB), f.subtract(i7, g7, h7), f.dot(this.normalA, i7);
                };
            },
            {
                "../math/vec2": 30,
                "./Equation": 22
            }
        ],
        22: [
            function(a23, b22, c23) {
                function d18(a, b, c, e) {
                    this.minForce = void 0 === c ? -Number.MAX_VALUE : c, this.maxForce = void 0 === e ? Number.MAX_VALUE : e, this.bodyA = a, this.bodyB = b, this.stiffness = d18.DEFAULT_STIFFNESS, this.relaxation = d18.DEFAULT_RELAXATION, this.G = new f10.ARRAY_TYPE(6);
                    for(var g = 0; g < 6; g++)this.G[g] = 0;
                    this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0;
                }
                b22.exports = d18;
                var e13 = a23("../math/vec2"), f10 = a23("../utils/Utils");
                a23("../objects/Body");
                d18.prototype.constructor = d18, d18.DEFAULT_STIFFNESS = 1000000, d18.DEFAULT_RELAXATION = 4, d18.prototype.update = function() {
                    var a = this.stiffness, b = this.relaxation, c = this.timeStep;
                    this.a = 4 / (c * (1 + 4 * b)), this.b = 4 * b / (1 + 4 * b), this.epsilon = 4 / (c * c * a * (1 + 4 * b)), this.needsUpdate = !1;
                }, d18.prototype.gmult = function(a, b, c, d, e) {
                    return a[0] * b[0] + a[1] * b[1] + a[2] * c + a[3] * d[0] + a[4] * d[1] + a[5] * e;
                }, d18.prototype.computeB = function(a, b, c) {
                    var d = this.computeGW();
                    return -this.computeGq() * a - d * b - this.computeGiMf() * c;
                };
                var g8 = e13.create(), h8 = e13.create();
                d18.prototype.computeGq = function() {
                    var a = this.G, b = this.bodyA, c = this.bodyB, d = (b.position, c.position, b.angle), e = c.angle;
                    return this.gmult(a, g8, d, h8, e) + this.offset;
                }, d18.prototype.computeGW = function() {
                    var a = this.G, b = this.bodyA, c = this.bodyB, d = b.velocity, e = c.velocity, f = b.angularVelocity, g = c.angularVelocity;
                    return this.gmult(a, d, f, e, g) + this.relativeVelocity;
                }, d18.prototype.computeGWlambda = function() {
                    var a = this.G, b = this.bodyA, c = this.bodyB, d = b.vlambda, e = c.vlambda, f = b.wlambda, g = c.wlambda;
                    return this.gmult(a, d, f, e, g);
                };
                var i8 = e13.create(), j6 = e13.create();
                d18.prototype.computeGiMf = function() {
                    var a = this.bodyA, b = this.bodyB, c = a.force, d = a.angularForce, f = b.force, g = b.angularForce, h = a.invMassSolve, k = b.invMassSolve, l = a.invInertiaSolve, m = b.invInertiaSolve, n = this.G;
                    return e13.scale(i8, c, h), e13.multiply(i8, a.massMultiplier, i8), e13.scale(j6, f, k), e13.multiply(j6, b.massMultiplier, j6), this.gmult(n, i8, d * l, j6, g * m);
                }, d18.prototype.computeGiMGt = function() {
                    var a = this.bodyA, b = this.bodyB, c = a.invMassSolve, d = b.invMassSolve, e = a.invInertiaSolve, f = b.invInertiaSolve, g = this.G;
                    return g[0] * g[0] * c * a.massMultiplier[0] + g[1] * g[1] * c * a.massMultiplier[1] + g[2] * g[2] * e + g[3] * g[3] * d * b.massMultiplier[0] + g[4] * g[4] * d * b.massMultiplier[1] + g[5] * g[5] * f;
                };
                var k5 = e13.create(), l4 = e13.create(), m3 = e13.create();
                e13.create(), e13.create(), e13.create();
                d18.prototype.addToWlambda = function(a) {
                    var b = this.bodyA, c = this.bodyB, d = k5, f = l4, g = m3, h = b.invMassSolve, i = c.invMassSolve, j = b.invInertiaSolve, n = c.invInertiaSolve, o = this.G;
                    f[0] = o[0], f[1] = o[1], g[0] = o[3], g[1] = o[4], e13.scale(d, f, h * a), e13.multiply(d, d, b.massMultiplier), e13.add(b.vlambda, b.vlambda, d), b.wlambda += j * o[2] * a, e13.scale(d, g, i * a), e13.multiply(d, d, c.massMultiplier), e13.add(c.vlambda, c.vlambda, d), c.wlambda += n * o[5] * a;
                }, d18.prototype.computeInvC = function(a) {
                    return 1 / (this.computeGiMGt() + a);
                };
            },
            {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }
        ],
        23: [
            function(a24, b23, c24) {
                function d19(a, b, c) {
                    f11.call(this, a, b, -c, c), this.contactPointA = e.create(), this.contactPointB = e.create(), this.t = e.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = 0.3;
                }
                var e = a24("../math/vec2"), f11 = a24("./Equation");
                a24("../utils/Utils");
                b23.exports = d19, d19.prototype = new f11, d19.prototype.constructor = d19, d19.prototype.setSlipForce = function(a) {
                    this.maxForce = a, this.minForce = -a;
                }, d19.prototype.getSlipForce = function() {
                    return this.maxForce;
                }, d19.prototype.computeB = function(a, b, c) {
                    var d = (this.bodyA, this.bodyB, this.contactPointA), f = this.contactPointB, g = this.t, h = this.G;
                    return h[0] = -g[0], h[1] = -g[1], h[2] = -e.crossLength(d, g), h[3] = g[0], h[4] = g[1], h[5] = e.crossLength(f, g), -this.computeGW() * b - c * this.computeGiMf();
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Equation": 22
            }
        ],
        24: [
            function(a25, b24, c25) {
                function d20(a, b, c) {
                    c = c || {}, e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = c.angle || 0;
                    var d = this.G;
                    d[2] = 1, d[5] = -1;
                }
                var e = a25("./Equation"), f = a25("../math/vec2");
                b24.exports = d20, d20.prototype = new e, d20.prototype.constructor = d20;
                var g = f.create(), h = f.create(), i = f.fromValues(1, 0), j = f.fromValues(0, 1);
                d20.prototype.computeGq = function() {
                    return f.rotate(g, i, this.bodyA.angle + this.angle), f.rotate(h, j, this.bodyB.angle), f.dot(g, h);
                };
            },
            {
                "../math/vec2": 30,
                "./Equation": 22
            }
        ],
        25: [
            function(a26, b25, c26) {
                function d21(a, b) {
                    e14.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1;
                }
                var e14 = a26("./Equation");
                a26("../math/vec2");
                b25.exports = d21, d21.prototype = new e14, d21.prototype.constructor = d21, d21.prototype.computeB = function(a, b, c) {
                    var d = this.G;
                    d[2] = -1, d[5] = this.ratio;
                    var e = this.computeGiMf();
                    return -this.computeGW() * b - c * e;
                };
            },
            {
                "../math/vec2": 30,
                "./Equation": 22
            }
        ],
        26: [
            function(a27, b26, c27) {
                var d22 = function() {};
                b26.exports = d22, d22.prototype = {
                    constructor: d22,
                    on: function(a, b, c) {
                        b.context = c || this, void 0 === this._listeners && (this._listeners = {});
                        var d = this._listeners;
                        return void 0 === d[a] && (d[a] = []), -1 === d[a].indexOf(b) && d[a].push(b), this;
                    },
                    has: function(a, b) {
                        if (void 0 === this._listeners) return !1;
                        var c = this._listeners;
                        if (b) {
                            if (void 0 !== c[a] && -1 !== c[a].indexOf(b)) return !0;
                        } else if (void 0 !== c[a]) return !0;
                        return !1;
                    },
                    off: function(a, b) {
                        if (void 0 === this._listeners) return this;
                        var c = this._listeners, d = c[a].indexOf(b);
                        return -1 !== d && c[a].splice(d, 1), this;
                    },
                    emit: function(a) {
                        if (void 0 === this._listeners) return this;
                        var b = this._listeners, c = b[a.type];
                        if (void 0 !== c) {
                            a.target = this;
                            for(var d = 0, e = c.length; d < e; d++){
                                var f = c[d];
                                f.call(f.context, a);
                            }
                        }
                        return this;
                    }
                };
            },
            {}
        ],
        27: [
            function(a28, b27, c28) {
                function d(a, b, c) {
                    if (c = c || {}, !(a instanceof e && b instanceof e)) throw new Error("First two arguments must be Material instances.");
                    this.id = d.idCounter++, this.materialA = a, this.materialB = b, this.friction = void 0 !== c.friction ? Number(c.friction) : 0.3, this.restitution = void 0 !== c.restitution ? Number(c.restitution) : 0, this.stiffness = void 0 !== c.stiffness ? Number(c.stiffness) : f.DEFAULT_STIFFNESS, this.relaxation = void 0 !== c.relaxation ? Number(c.relaxation) : f.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== c.frictionStiffness ? Number(c.frictionStiffness) : f.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== c.frictionRelaxation ? Number(c.frictionRelaxation) : f.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== c.surfaceVelocity ? Number(c.surfaceVelocity) : 0, this.contactSkinSize = 0.005;
                }
                var e = a28("./Material"), f = a28("../equations/Equation");
                b27.exports = d, d.idCounter = 0;
            },
            {
                "../equations/Equation": 22,
                "./Material": 28
            }
        ],
        28: [
            function(a29, b, c) {
                function d(a) {
                    this.id = a || d.idCounter++;
                }
                b.exports = d, d.idCounter = 0;
            },
            {}
        ],
        29: [
            function(a30, b28, c29) {
                var d23 = {};
                d23.GetArea = function(a) {
                    if (a.length < 6) return 0;
                    for(var b = a.length - 2, c = 0, d = 0; d < b; d += 2)c += (a[d + 2] - a[d]) * (a[d + 1] + a[d + 3]);
                    return 0.5 * -(c += (a[0] - a[b]) * (a[b + 1] + a[1]));
                }, d23.Triangulate = function(a) {
                    var b = a.length >> 1;
                    if (b < 3) return [];
                    for(var c = [], e = [], f = 0; f < b; f++)e.push(f);
                    for(var f = 0, g = b; g > 3;){
                        var h = e[(f + 0) % g], i = e[(f + 1) % g], j = e[(f + 2) % g], k = a[2 * h], l = a[2 * h + 1], m = a[2 * i], n = a[2 * i + 1], o = a[2 * j], p = a[2 * j + 1], q = !1;
                        if (d23._convex(k, l, m, n, o, p)) {
                            q = !0;
                            for(var r = 0; r < g; r++){
                                var s = e[r];
                                if (s != h && s != i && s != j && d23._PointInTriangle(a[2 * s], a[2 * s + 1], k, l, m, n, o, p)) {
                                    q = !1;
                                    break;
                                }
                            }
                        }
                        if (q) c.push(h, i, j), e.splice((f + 1) % g, 1), g--, f = 0;
                        else if ((f++) > 3 * g) break;
                    }
                    return c.push(e[0], e[1], e[2]), c;
                }, d23._PointInTriangle = function(a, b, c, d, e, f, g, h) {
                    var i = g - c, j = h - d, k = e - c, l = f - d, m = a - c, n = b - d, o = i * i + j * j, p = i * k + j * l, q = i * m + j * n, r = k * k + l * l, s = k * m + l * n, t = 1 / (o * r - p * p), u = (r * q - p * s) * t, v = (o * s - p * q) * t;
                    return u >= 0 && v >= 0 && u + v < 1;
                }, d23._convex = function(a, b, c, d, e, f) {
                    return (b - d) * (e - c) + (c - a) * (f - d) >= 0;
                }, b28.exports = d23;
            },
            {}
        ],
        30: [
            function(a31, b29, c30) {
                var d24 = b29.exports = {}, e15 = a31("../utils/Utils");
                d24.crossLength = function(a, b) {
                    return a[0] * b[1] - a[1] * b[0];
                }, d24.crossVZ = function(a, b, c) {
                    return d24.rotate(a, b, -Math.PI / 2), d24.scale(a, a, c), a;
                }, d24.crossZV = function(a, b, c) {
                    return d24.rotate(a, c, Math.PI / 2), d24.scale(a, a, b), a;
                }, d24.rotate = function(a, b, c) {
                    if (0 !== c) {
                        var d = Math.cos(c), e = Math.sin(c), f = b[0], g = b[1];
                        a[0] = d * f - e * g, a[1] = e * f + d * g;
                    } else a[0] = b[0], a[1] = b[1];
                }, d24.rotate90cw = function(a, b) {
                    var c = b[0], d = b[1];
                    a[0] = d, a[1] = -c;
                }, d24.toLocalFrame = function(a, b, c, e) {
                    d24.copy(a, b), d24.sub(a, a, c), d24.rotate(a, a, -e);
                }, d24.toGlobalFrame = function(a, b, c, e) {
                    d24.copy(a, b), d24.rotate(a, a, e), d24.add(a, a, c);
                }, d24.vectorToLocalFrame = function(a, b, c) {
                    d24.rotate(a, b, -c);
                }, d24.vectorToGlobalFrame = function(a, b, c) {
                    d24.rotate(a, b, c);
                }, d24.centroid = function(a, b, c, e) {
                    return d24.add(a, b, c), d24.add(a, a, e), d24.scale(a, a, 1 / 3), a;
                }, d24.create = function() {
                    var a = new e15.ARRAY_TYPE(2);
                    return a[0] = 0, a[1] = 0, a;
                }, d24.clone = function(a) {
                    var b = new e15.ARRAY_TYPE(2);
                    return b[0] = a[0], b[1] = a[1], b;
                }, d24.fromValues = function(a, b) {
                    var c = new e15.ARRAY_TYPE(2);
                    return c[0] = a, c[1] = b, c;
                }, d24.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a;
                }, d24.set = function(a, b, c) {
                    return a[0] = b, a[1] = c, a;
                }, d24.add = function(a, b, c) {
                    return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a;
                }, d24.subtract = function(a, b, c) {
                    return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a;
                }, d24.sub = d24.subtract, d24.multiply = function(a, b, c) {
                    return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a;
                }, d24.mul = d24.multiply, d24.divide = function(a, b, c) {
                    return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a;
                }, d24.div = d24.divide, d24.scale = function(a, b, c) {
                    return a[0] = b[0] * c, a[1] = b[1] * c, a;
                }, d24.distance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1];
                    return Math.sqrt(c * c + d * d);
                }, d24.dist = d24.distance, d24.squaredDistance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1];
                    return c * c + d * d;
                }, d24.sqrDist = d24.squaredDistance, d24.length = function(a) {
                    var b = a[0], c = a[1];
                    return Math.sqrt(b * b + c * c);
                }, d24.len = d24.length, d24.squaredLength = function(a) {
                    var b = a[0], c = a[1];
                    return b * b + c * c;
                }, d24.sqrLen = d24.squaredLength, d24.negate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a;
                }, d24.normalize = function(a, b) {
                    var c = b[0], d = b[1], e = c * c + d * d;
                    return e > 0 && (e = 1 / Math.sqrt(e), a[0] = b[0] * e, a[1] = b[1] * e), a;
                }, d24.dot = function(a, b) {
                    return a[0] * b[0] + a[1] * b[1];
                }, d24.str = function(a) {
                    return "vec2(" + a[0] + ", " + a[1] + ")";
                }, d24.lerp = function(a, b, c, d) {
                    var e = b[0], f = b[1];
                    return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a;
                }, d24.reflect = function(a, b, c) {
                    var d = b[0] * c[0] + b[1] * c[1];
                    a[0] = b[0] - 2 * c[0] * d, a[1] = b[1] - 2 * c[1] * d;
                }, d24.getLineSegmentsIntersection = function(a, b, c, e, f) {
                    var g = d24.getLineSegmentsIntersectionFraction(b, c, e, f);
                    return !(g < 0) && (a[0] = b[0] + g * (c[0] - b[0]), a[1] = b[1] + g * (c[1] - b[1]), !0);
                }, d24.getLineSegmentsIntersectionFraction = function(a, b, c, d) {
                    var e, f, g = b[0] - a[0], h = b[1] - a[1], i = d[0] - c[0], j = d[1] - c[1];
                    return e = (-h * (a[0] - c[0]) + g * (a[1] - c[1])) / (-i * h + g * j), f = (i * (a[1] - c[1]) - j * (a[0] - c[0])) / (-i * h + g * j), e >= 0 && e <= 1 && f >= 0 && f <= 1 ? f : -1;
                };
            },
            {
                "../utils/Utils": 57
            }
        ],
        31: [
            function(a32, b30, c31) {
                function d25(a) {
                    a = a || {}, k6.call(this), this.id = a.id || ++d25._idCounter, this.world = null, this.shapes = [], this.mass = a.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!a.fixedRotation, this.fixedX = !!a.fixedX, this.fixedY = !!a.fixedY, this.massMultiplier = e.create(), this.position = e.fromValues(0, 0), a.position && e.copy(this.position, a.position), this.interpolatedPosition = e.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = e.fromValues(0, 0), this.previousAngle = 0, this.velocity = e.fromValues(0, 0), a.velocity && e.copy(this.velocity, a.velocity), this.vlambda = e.fromValues(0, 0), this.wlambda = 0, this.angle = a.angle || 0, this.angularVelocity = a.angularVelocity || 0, this.force = e.create(), a.force && e.copy(this.force, a.force), this.angularForce = a.angularForce || 0, this.damping = "number" == typeof a.damping ? a.damping : 0.1, this.angularDamping = "number" == typeof a.angularDamping ? a.angularDamping : 0.1, this.type = d25.STATIC, void 0 !== a.type ? this.type = a.type : a.mass ? this.type = d25.DYNAMIC : this.type = d25.STATIC, this.boundingRadius = 0, this.aabb = new j7, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === a.allowSleep || a.allowSleep, this.wantsToSleep = !1, this.sleepState = d25.AWAKE, this.sleepSpeedLimit = void 0 !== a.sleepSpeedLimit ? a.sleepSpeedLimit : 0.2, this.sleepTimeLimit = void 0 !== a.sleepTimeLimit ? a.sleepTimeLimit : 1, this.gravityScale = void 0 !== a.gravityScale ? a.gravityScale : 1, this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== a.ccdSpeedThreshold ? a.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== a.ccdIterations ? a.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties();
                }
                var e = a32("../math/vec2"), f12 = a32("poly-decomp"), g9 = a32("../shapes/Convex"), h9 = a32("../collision/RaycastResult"), i9 = a32("../collision/Ray"), j7 = a32("../collision/AABB"), k6 = a32("../events/EventEmitter");
                b30.exports = d25, d25.prototype = new k6, d25.prototype.constructor = d25, d25._idCounter = 0, d25.prototype.updateSolveMassProperties = function() {
                    this.sleepState === d25.SLEEPING || this.type === d25.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia);
                }, d25.prototype.setDensity = function(a) {
                    var b = this.getArea();
                    this.mass = b * a, this.updateMassProperties();
                }, d25.prototype.getArea = function() {
                    for(var a = 0, b = 0; b < this.shapes.length; b++)a += this.shapes[b].area;
                    return a;
                }, d25.prototype.getAABB = function() {
                    return this.aabbNeedsUpdate && this.updateAABB(), this.aabb;
                };
                var l5 = new j7, m = e.create();
                d25.prototype.updateAABB = function() {
                    for(var a = this.shapes, b = a.length, c = m, d = this.angle, f = 0; f !== b; f++){
                        var g = a[f], h = g.angle + d;
                        e.rotate(c, g.position, d), e.add(c, c, this.position), g.computeAABB(l5, c, h), 0 === f ? this.aabb.copy(l5) : this.aabb.extend(l5);
                    }
                    this.aabbNeedsUpdate = !1;
                }, d25.prototype.updateBoundingRadius = function() {
                    for(var a = this.shapes, b = a.length, c = 0, d = 0; d !== b; d++){
                        var f = a[d], g = e.length(f.position), h = f.boundingRadius;
                        g + h > c && (c = g + h);
                    }
                    this.boundingRadius = c;
                }, d25.prototype.addShape = function(a, b, c) {
                    if (a.body) throw new Error("A shape can only be added to one body.");
                    a.body = this, b ? e.copy(a.position, b) : e.set(a.position, 0, 0), a.angle = c || 0, this.shapes.push(a), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0;
                }, d25.prototype.removeShape = function(a) {
                    var b = this.shapes.indexOf(a);
                    return -1 !== b && (this.shapes.splice(b, 1), this.aabbNeedsUpdate = !0, a.body = null, !0);
                }, d25.prototype.updateMassProperties = function() {
                    if (this.type === d25.STATIC || this.type === d25.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        var a = this.shapes, b = a.length, c = this.mass / b, f = 0;
                        if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                        else {
                            for(var g = 0; g < b; g++){
                                var h = a[g], i = e.squaredLength(h.position);
                                f += h.computeMomentOfInertia(c) + c * i;
                            }
                            this.inertia = f, this.invInertia = f > 0 ? 1 / f : 0;
                        }
                        this.invMass = 1 / this.mass, e.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
                    }
                };
                e.create();
                d25.prototype.applyForce = function(a, b) {
                    if (e.add(this.force, this.force, a), b) {
                        var c = e.crossLength(b, a);
                        this.angularForce += c;
                    }
                };
                var n = e.create(), o = e.create(), p = e.create();
                d25.prototype.applyForceLocal = function(a, b) {
                    b = b || p;
                    var c = n, d = o;
                    this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyForce(c, d);
                };
                var q = e.create();
                d25.prototype.applyImpulse = function(a, b) {
                    if (this.type === d25.DYNAMIC) {
                        var c = q;
                        if (e.scale(c, a, this.invMass), e.multiply(c, this.massMultiplier, c), e.add(this.velocity, c, this.velocity), b) {
                            var f = e.crossLength(b, a);
                            f *= this.invInertia, this.angularVelocity += f;
                        }
                    }
                };
                var r = e.create(), s = e.create(), t = e.create();
                d25.prototype.applyImpulseLocal = function(a, b) {
                    b = b || t;
                    var c = r, d = s;
                    this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyImpulse(c, d);
                }, d25.prototype.toLocalFrame = function(a, b) {
                    e.toLocalFrame(a, b, this.position, this.angle);
                }, d25.prototype.toWorldFrame = function(a, b) {
                    e.toGlobalFrame(a, b, this.position, this.angle);
                }, d25.prototype.vectorToLocalFrame = function(a, b) {
                    e.vectorToLocalFrame(a, b, this.angle);
                }, d25.prototype.vectorToWorldFrame = function(a, b) {
                    e.vectorToGlobalFrame(a, b, this.angle);
                }, d25.prototype.fromPolygon = function(a, b) {
                    b = b || {};
                    for(var c = this.shapes.length; c >= 0; --c)this.removeShape(this.shapes[c]);
                    var d = new f12.Polygon;
                    if (d.vertices = a, d.makeCCW(), "number" == typeof b.removeCollinearPoints && d.removeCollinearPoints(b.removeCollinearPoints), void 0 === b.skipSimpleCheck && !d.isSimple()) return !1;
                    this.concavePath = d.vertices.slice(0);
                    for(var c = 0; c < this.concavePath.length; c++){
                        var h = [
                            0,
                            0
                        ];
                        e.copy(h, this.concavePath[c]), this.concavePath[c] = h;
                    }
                    var i;
                    i = b.optimalDecomp ? d.decomp() : d.quickDecomp();
                    for(var j = e.create(), c = 0; c !== i.length; c++){
                        for(var k = new g9({
                            vertices: i[c].vertices
                        }), l = 0; l !== k.vertices.length; l++){
                            var h = k.vertices[l];
                            e.sub(h, h, k.centerOfMass);
                        }
                        e.scale(j, k.centerOfMass, 1), k.updateTriangles(), k.updateCenterOfMass(), k.updateBoundingRadius(), this.addShape(k, j);
                    }
                    return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0;
                };
                var u = (e.fromValues(0, 0), e.fromValues(0, 0)), v = e.fromValues(0, 0), w = e.fromValues(0, 0);
                d25.prototype.adjustCenterOfMass = function() {
                    var a = u, b = v, c = w, d = 0;
                    e.set(b, 0, 0);
                    for(var f = 0; f !== this.shapes.length; f++){
                        var g = this.shapes[f];
                        e.scale(a, g.position, g.area), e.add(b, b, a), d += g.area;
                    }
                    e.scale(c, b, 1 / d);
                    for(var f = 0; f !== this.shapes.length; f++){
                        var g = this.shapes[f];
                        e.sub(g.position, g.position, c);
                    }
                    e.add(this.position, this.position, c);
                    for(var f = 0; this.concavePath && f < this.concavePath.length; f++)e.sub(this.concavePath[f], this.concavePath[f], c);
                    this.updateMassProperties(), this.updateBoundingRadius();
                }, d25.prototype.setZeroForce = function() {
                    e.set(this.force, 0, 0), this.angularForce = 0;
                }, d25.prototype.resetConstraintVelocity = function() {
                    var a = this, b = a.vlambda;
                    e.set(b, 0, 0), a.wlambda = 0;
                }, d25.prototype.addConstraintVelocity = function() {
                    var a = this, b = a.velocity;
                    e.add(b, b, a.vlambda), a.angularVelocity += a.wlambda;
                }, d25.prototype.applyDamping = function(a) {
                    if (this.type === d25.DYNAMIC) {
                        var b = this.velocity;
                        e.scale(b, b, Math.pow(1 - this.damping, a)), this.angularVelocity *= Math.pow(1 - this.angularDamping, a);
                    }
                }, d25.prototype.wakeUp = function() {
                    var a = this.sleepState;
                    this.sleepState = d25.AWAKE, this.idleTime = 0, a !== d25.AWAKE && this.emit(d25.wakeUpEvent);
                }, d25.prototype.sleep = function() {
                    this.sleepState = d25.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, e.set(this.velocity, 0, 0), e.set(this.force, 0, 0), this.emit(d25.sleepEvent);
                }, d25.prototype.sleepTick = function(a, b, c) {
                    if (this.allowSleep && this.type !== d25.SLEEPING) {
                        this.wantsToSleep = !1;
                        this.sleepState;
                        e.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0, this.sleepState = d25.AWAKE) : (this.idleTime += c, this.sleepState = d25.SLEEPY), this.idleTime > this.sleepTimeLimit && (b ? this.wantsToSleep = !0 : this.sleep());
                    }
                }, d25.prototype.overlaps = function(a) {
                    return this.world.overlapKeeper.bodiesAreOverlapping(this, a);
                };
                var x = e.create(), y = e.create();
                d25.prototype.integrate = function(a) {
                    var b = this.invMass, c = this.force, d = this.position, f = this.velocity;
                    e.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * a), e.scale(x, c, a * b), e.multiply(x, this.massMultiplier, x), e.add(f, x, f), this.integrateToTimeOfImpact(a) || (e.scale(y, f, a), e.add(d, d, y), this.fixedRotation || (this.angle += this.angularVelocity * a)), this.aabbNeedsUpdate = !0;
                };
                var z = new h9, A = new i9({
                    mode: i9.ALL
                }), B = e.create(), C = e.create(), D = e.create(), E = e.create();
                d25.prototype.integrateToTimeOfImpact = function(a33) {
                    if (this.ccdSpeedThreshold < 0 || e.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                    e.normalize(B, this.velocity), e.scale(C, this.velocity, a33), e.add(C, C, this.position), e.sub(D, C, this.position);
                    var b, c = this.angularVelocity * a33, d = e.length(D), f = 1, g = this;
                    if (z.reset(), A.callback = function(a) {
                        a.body !== g && (b = a.body, a.getHitPoint(C, A), e.sub(D, C, g.position), f = e.length(D) / d, a.stop());
                    }, e.copy(A.from, this.position), e.copy(A.to, C), A.update(), this.world.raycast(z, A), !b) return !1;
                    var h = this.angle;
                    e.copy(E, this.position);
                    for(var i = 0, j = 0, k = 0, l = f; l >= j && i < this.ccdIterations;){
                        i++, k = (l - j) / 2, e.scale(y, D, f), e.add(this.position, E, y), this.angle = h + c * f, this.updateAABB();
                        this.aabb.overlaps(b.aabb) && this.world.narrowphase.bodiesOverlap(this, b) ? j = k : l = k;
                    }
                    return f = k, e.copy(this.position, E), this.angle = h, e.scale(y, D, f), e.add(this.position, this.position, y), this.fixedRotation || (this.angle += c * f), !0;
                }, d25.prototype.getVelocityAtPoint = function(a, b) {
                    return e.crossVZ(a, b, this.angularVelocity), e.subtract(a, this.velocity, a), a;
                }, d25.sleepyEvent = {
                    type: "sleepy"
                }, d25.sleepEvent = {
                    type: "sleep"
                }, d25.wakeUpEvent = {
                    type: "wakeup"
                }, d25.DYNAMIC = 1, d25.STATIC = 2, d25.KINEMATIC = 4, d25.AWAKE = 0, d25.SLEEPY = 1, d25.SLEEPING = 2;
            },
            {
                "../collision/AABB": 7,
                "../collision/Ray": 11,
                "../collision/RaycastResult": 12,
                "../events/EventEmitter": 26,
                "../math/vec2": 30,
                "../shapes/Convex": 40,
                "poly-decomp": 5
            }
        ],
        32: [
            function(a34, b31, c32) {
                function d26(a, b, c) {
                    c = c || {}, f13.call(this, a, b, c), this.localAnchorA = e.fromValues(0, 0), this.localAnchorB = e.fromValues(0, 0), c.localAnchorA && e.copy(this.localAnchorA, c.localAnchorA), c.localAnchorB && e.copy(this.localAnchorB, c.localAnchorB), c.worldAnchorA && this.setWorldAnchorA(c.worldAnchorA), c.worldAnchorB && this.setWorldAnchorB(c.worldAnchorB);
                    var d = e.create(), g = e.create();
                    this.getWorldAnchorA(d), this.getWorldAnchorB(g);
                    var h = e.distance(d, g);
                    this.restLength = "number" == typeof c.restLength ? c.restLength : h;
                }
                var e = a34("../math/vec2"), f13 = a34("./Spring");
                a34("../utils/Utils");
                b31.exports = d26, d26.prototype = new f13, d26.prototype.constructor = d26, d26.prototype.setWorldAnchorA = function(a) {
                    this.bodyA.toLocalFrame(this.localAnchorA, a);
                }, d26.prototype.setWorldAnchorB = function(a) {
                    this.bodyB.toLocalFrame(this.localAnchorB, a);
                }, d26.prototype.getWorldAnchorA = function(a) {
                    this.bodyA.toWorldFrame(a, this.localAnchorA);
                }, d26.prototype.getWorldAnchorB = function(a) {
                    this.bodyB.toWorldFrame(a, this.localAnchorB);
                };
                var g10 = e.create(), h10 = e.create(), i = e.create(), j = e.create(), k = e.create(), l = e.create(), m = e.create(), n = e.create(), o = e.create();
                d26.prototype.applyForce = function() {
                    var a = this.stiffness, b = this.damping, c = this.restLength, d = this.bodyA, f = this.bodyB, p = g10, q = h10, r = i, s = j, t = o, u = k, v = l, w = m, x = n;
                    this.getWorldAnchorA(u), this.getWorldAnchorB(v), e.sub(w, u, d.position), e.sub(x, v, f.position), e.sub(p, v, u);
                    var y = e.len(p);
                    e.normalize(q, p), e.sub(r, f.velocity, d.velocity), e.crossZV(t, f.angularVelocity, x), e.add(r, r, t), e.crossZV(t, d.angularVelocity, w), e.sub(r, r, t), e.scale(s, q, -a * (y - c) - b * e.dot(r, q)), e.sub(d.force, d.force, s), e.add(f.force, f.force, s);
                    var z = e.crossLength(w, s), A = e.crossLength(x, s);
                    d.angularForce -= z, f.angularForce += A;
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Spring": 34
            }
        ],
        33: [
            function(a35, b32, c33) {
                function d27(a, b, c) {
                    c = c || {}, e16.call(this, a, b, c), this.restAngle = "number" == typeof c.restAngle ? c.restAngle : b.angle - a.angle;
                }
                var e16 = (a35("../math/vec2"), a35("./Spring"));
                b32.exports = d27, d27.prototype = new e16, d27.prototype.constructor = d27, d27.prototype.applyForce = function() {
                    var a = this.stiffness, b = this.damping, c = this.restAngle, d = this.bodyA, e = this.bodyB, f = e.angle - d.angle, g = e.angularVelocity - d.angularVelocity, h = -a * (f - c) - b * g * 0;
                    d.angularForce -= h, e.angularForce += h;
                };
            },
            {
                "../math/vec2": 30,
                "./Spring": 34
            }
        ],
        34: [
            function(a36, b33, c34) {
                function d(a, b, c) {
                    c = e.defaults(c, {
                        stiffness: 100,
                        damping: 1
                    }), this.stiffness = c.stiffness, this.damping = c.damping, this.bodyA = a, this.bodyB = b;
                }
                var e = (a36("../math/vec2"), a36("../utils/Utils"));
                b33.exports = d, d.prototype.applyForce = function() {};
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }
        ],
        35: [
            function(a37, b34, c35) {
                function d(a, b) {
                    b = b || {}, this.chassisBody = a, this.wheels = [], this.groundBody = new i({
                        mass: 0
                    }), this.world = null;
                    var c = this;
                    this.preStepCallback = function() {
                        c.update();
                    };
                }
                function e(a, b) {
                    b = b || {}, this.vehicle = a, this.forwardEquation = new h(a.chassisBody, a.groundBody), this.sideEquation = new h(a.chassisBody, a.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== b.sideFriction ? b.sideFriction : 5), this.localForwardVector = f.fromValues(0, 1), b.localForwardVector && f.copy(this.localForwardVector, b.localForwardVector), this.localPosition = f.fromValues(0, 0), b.localPosition && f.copy(this.localPosition, b.localPosition), g.apply(this, a.chassisBody, a.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0);
                }
                var f = a37("../math/vec2"), g = (a37("../utils/Utils"), a37("../constraints/Constraint")), h = a37("../equations/FrictionEquation"), i = a37("../objects/Body");
                b34.exports = d, d.prototype.addToWorld = function(a) {
                    this.world = a, a.addBody(this.groundBody), a.on("preStep", this.preStepCallback);
                    for(var b = 0; b < this.wheels.length; b++){
                        var c = this.wheels[b];
                        a.addConstraint(c);
                    }
                }, d.prototype.removeFromWorld = function() {
                    var a = this.world;
                    a.removeBody(this.groundBody), a.off("preStep", this.preStepCallback);
                    for(var b = 0; b < this.wheels.length; b++){
                        var c = this.wheels[b];
                        a.removeConstraint(c);
                    }
                    this.world = null;
                }, d.prototype.addWheel = function(a) {
                    var b = new e(this, a);
                    return this.wheels.push(b), b;
                }, d.prototype.update = function() {
                    for(var a = 0; a < this.wheels.length; a++)this.wheels[a].update();
                }, e.prototype = new g, e.prototype.setBrakeForce = function(a) {
                    this.forwardEquation.setSlipForce(a);
                }, e.prototype.setSideFriction = function(a) {
                    this.sideEquation.setSlipForce(a);
                };
                var j = f.create(), k = f.create();
                e.prototype.getSpeed = function() {
                    return this.vehicle.chassisBody.vectorToWorldFrame(k, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(j, k), f.dot(j, k);
                };
                var l = f.create();
                e.prototype.update = function() {
                    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), f.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), f.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), f.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), f.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), f.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), f.normalize(l, this.forwardEquation.t), f.scale(l, l, this.engineForce), this.vehicle.chassisBody.applyForce(l, this.forwardEquation.contactPointA);
                };
            },
            {
                "../constraints/Constraint": 14,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }
        ],
        36: [
            function(a, b, c) {
                var d = b.exports = {
                    AABB: a("./collision/AABB"),
                    AngleLockEquation: a("./equations/AngleLockEquation"),
                    Body: a("./objects/Body"),
                    Broadphase: a("./collision/Broadphase"),
                    Capsule: a("./shapes/Capsule"),
                    Circle: a("./shapes/Circle"),
                    Constraint: a("./constraints/Constraint"),
                    ContactEquation: a("./equations/ContactEquation"),
                    ContactEquationPool: a("./utils/ContactEquationPool"),
                    ContactMaterial: a("./material/ContactMaterial"),
                    Convex: a("./shapes/Convex"),
                    DistanceConstraint: a("./constraints/DistanceConstraint"),
                    Equation: a("./equations/Equation"),
                    EventEmitter: a("./events/EventEmitter"),
                    FrictionEquation: a("./equations/FrictionEquation"),
                    FrictionEquationPool: a("./utils/FrictionEquationPool"),
                    GearConstraint: a("./constraints/GearConstraint"),
                    GSSolver: a("./solver/GSSolver"),
                    Heightfield: a("./shapes/Heightfield"),
                    Line: a("./shapes/Line"),
                    LockConstraint: a("./constraints/LockConstraint"),
                    Material: a("./material/Material"),
                    Narrowphase: a("./collision/Narrowphase"),
                    NaiveBroadphase: a("./collision/NaiveBroadphase"),
                    Particle: a("./shapes/Particle"),
                    Plane: a("./shapes/Plane"),
                    Pool: a("./utils/Pool"),
                    RevoluteConstraint: a("./constraints/RevoluteConstraint"),
                    PrismaticConstraint: a("./constraints/PrismaticConstraint"),
                    Ray: a("./collision/Ray"),
                    RaycastResult: a("./collision/RaycastResult"),
                    Box: a("./shapes/Box"),
                    RotationalVelocityEquation: a("./equations/RotationalVelocityEquation"),
                    SAPBroadphase: a("./collision/SAPBroadphase"),
                    Shape: a("./shapes/Shape"),
                    Solver: a("./solver/Solver"),
                    Spring: a("./objects/Spring"),
                    TopDownVehicle: a("./objects/TopDownVehicle"),
                    LinearSpring: a("./objects/LinearSpring"),
                    RotationalSpring: a("./objects/RotationalSpring"),
                    Utils: a("./utils/Utils"),
                    World: a("./world/World"),
                    vec2: a("./math/vec2"),
                    version: a("../package.json").version
                };
                Object.defineProperty(d, "Rectangle", {
                    get: function() {
                        return console.warn("The Rectangle class has been renamed to Box."), this.Box;
                    }
                });
            },
            {
                "../package.json": 6,
                "./collision/AABB": 7,
                "./collision/Broadphase": 8,
                "./collision/NaiveBroadphase": 9,
                "./collision/Narrowphase": 10,
                "./collision/Ray": 11,
                "./collision/RaycastResult": 12,
                "./collision/SAPBroadphase": 13,
                "./constraints/Constraint": 14,
                "./constraints/DistanceConstraint": 15,
                "./constraints/GearConstraint": 16,
                "./constraints/LockConstraint": 17,
                "./constraints/PrismaticConstraint": 18,
                "./constraints/RevoluteConstraint": 19,
                "./equations/AngleLockEquation": 20,
                "./equations/ContactEquation": 21,
                "./equations/Equation": 22,
                "./equations/FrictionEquation": 23,
                "./equations/RotationalVelocityEquation": 25,
                "./events/EventEmitter": 26,
                "./material/ContactMaterial": 27,
                "./material/Material": 28,
                "./math/vec2": 30,
                "./objects/Body": 31,
                "./objects/LinearSpring": 32,
                "./objects/RotationalSpring": 33,
                "./objects/Spring": 34,
                "./objects/TopDownVehicle": 35,
                "./shapes/Box": 37,
                "./shapes/Capsule": 38,
                "./shapes/Circle": 39,
                "./shapes/Convex": 40,
                "./shapes/Heightfield": 41,
                "./shapes/Line": 42,
                "./shapes/Particle": 43,
                "./shapes/Plane": 44,
                "./shapes/Shape": 45,
                "./solver/GSSolver": 46,
                "./solver/Solver": 47,
                "./utils/ContactEquationPool": 48,
                "./utils/FrictionEquationPool": 49,
                "./utils/Pool": 55,
                "./utils/Utils": 57,
                "./world/World": 61
            }
        ],
        37: [
            function(a38, b35, c36) {
                function d28(a) {
                    "number" == typeof arguments[0] && "number" == typeof arguments[1] && (a = {
                        width: arguments[0],
                        height: arguments[1]
                    }, console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })")), a = a || {};
                    var b = this.width = a.width || 1, c = this.height = a.height || 1, d = [
                        e.fromValues(-b / 2, -c / 2),
                        e.fromValues(b / 2, -c / 2),
                        e.fromValues(b / 2, c / 2),
                        e.fromValues(-b / 2, c / 2)
                    ], h = [
                        e.fromValues(1, 0),
                        e.fromValues(0, 1)
                    ];
                    a.vertices = d, a.axes = h, a.type = f.BOX, g.call(this, a);
                }
                var e = a38("../math/vec2"), f = a38("./Shape"), g = a38("./Convex");
                b35.exports = d28, d28.prototype = new g, d28.prototype.constructor = d28, d28.prototype.computeMomentOfInertia = function(a) {
                    var b = this.width, c = this.height;
                    return a * (c * c + b * b) / 12;
                }, d28.prototype.updateBoundingRadius = function() {
                    var a = this.width, b = this.height;
                    this.boundingRadius = Math.sqrt(a * a + b * b) / 2;
                };
                e.create(), e.create(), e.create(), e.create();
                d28.prototype.computeAABB = function(a, b, c) {
                    a.setFromPoints(this.vertices, b, c, 0);
                }, d28.prototype.updateArea = function() {
                    this.area = this.width * this.height;
                };
            },
            {
                "../math/vec2": 30,
                "./Convex": 40,
                "./Shape": 45
            }
        ],
        38: [
            function(a39, b36, c37) {
                function d29(a) {
                    "number" == typeof arguments[0] && "number" == typeof arguments[1] && (a = {
                        length: arguments[0],
                        radius: arguments[1]
                    }, console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })")), a = a || {}, this.length = a.length || 1, this.radius = a.radius || 1, a.type = e17.CAPSULE, e17.call(this, a);
                }
                var e17 = a39("./Shape"), f = a39("../math/vec2");
                b36.exports = d29, d29.prototype = new e17, d29.prototype.constructor = d29, d29.prototype.computeMomentOfInertia = function(a) {
                    var b = this.radius, c = this.length + b, d = 2 * b;
                    return a * (d * d + c * c) / 12;
                }, d29.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius + this.length / 2;
                }, d29.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length;
                };
                var g11 = f.create();
                d29.prototype.computeAABB = function(a, b, c) {
                    var d = this.radius;
                    f.set(g11, this.length / 2, 0), 0 !== c && f.rotate(g11, g11, c), f.set(a.upperBound, Math.max(g11[0] + d, -g11[0] + d), Math.max(g11[1] + d, -g11[1] + d)), f.set(a.lowerBound, Math.min(g11[0] - d, -g11[0] - d), Math.min(g11[1] - d, -g11[1] - d)), f.add(a.lowerBound, a.lowerBound, b), f.add(a.upperBound, a.upperBound, b);
                };
                var h = f.create(), i = f.create(), j = f.create(), k = f.create(), l = f.fromValues(0, 1);
                d29.prototype.raycast = function(a, b, c, d) {
                    for(var e = b.from, g = b.to, m = (b.direction, h), n = i, o = j, p = k, q = this.length / 2, r = 0; r < 2; r++){
                        var s = this.radius * (2 * r - 1);
                        f.set(o, -q, s), f.set(p, q, s), f.toGlobalFrame(o, o, c, d), f.toGlobalFrame(p, p, c, d);
                        var t = f.getLineSegmentsIntersectionFraction(e, g, o, p);
                        if (t >= 0 && (f.rotate(n, l, d), f.scale(n, n, 2 * r - 1), b.reportIntersection(a, t, n, -1), a.shouldStop(b))) return;
                    }
                    for(var u = Math.pow(this.radius, 2) + Math.pow(q, 2), r = 0; r < 2; r++){
                        f.set(o, q * (2 * r - 1), 0), f.toGlobalFrame(o, o, c, d);
                        var v = Math.pow(g[0] - e[0], 2) + Math.pow(g[1] - e[1], 2), w = 2 * ((g[0] - e[0]) * (e[0] - o[0]) + (g[1] - e[1]) * (e[1] - o[1])), x = Math.pow(e[0] - o[0], 2) + Math.pow(e[1] - o[1], 2) - Math.pow(this.radius, 2), t = Math.pow(w, 2) - 4 * v * x;
                        if (!(t < 0)) {
                            if (0 === t) {
                                if (f.lerp(m, e, g, t), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, t, n, -1), a.shouldStop(b))) return;
                            } else {
                                var y = Math.sqrt(t), z = 1 / (2 * v), A = (-w - y) * z, B = (-w + y) * z;
                                if (A >= 0 && A <= 1 && (f.lerp(m, e, g, A), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, A, n, -1), a.shouldStop(b)))) return;
                                if (B >= 0 && B <= 1 && (f.lerp(m, e, g, B), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, B, n, -1), a.shouldStop(b)))) return;
                            }
                        }
                    }
                };
            },
            {
                "../math/vec2": 30,
                "./Shape": 45
            }
        ],
        39: [
            function(a40, b37, c38) {
                function d30(a) {
                    "number" == typeof arguments[0] && (a = {
                        radius: arguments[0]
                    }, console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })")), a = a || {}, this.radius = a.radius || 1, a.type = e18.CIRCLE, e18.call(this, a);
                }
                var e18 = a40("./Shape"), f = a40("../math/vec2");
                b37.exports = d30, d30.prototype = new e18, d30.prototype.constructor = d30, d30.prototype.computeMomentOfInertia = function(a) {
                    var b = this.radius;
                    return a * b * b / 2;
                }, d30.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius;
                }, d30.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius;
                }, d30.prototype.computeAABB = function(a, b, c) {
                    var d = this.radius;
                    f.set(a.upperBound, d, d), f.set(a.lowerBound, -d, -d), b && (f.add(a.lowerBound, a.lowerBound, b), f.add(a.upperBound, a.upperBound, b));
                };
                var g = f.create(), h = f.create();
                d30.prototype.raycast = function(a, b, c, d) {
                    var e = b.from, i = b.to, j = this.radius, k = Math.pow(i[0] - e[0], 2) + Math.pow(i[1] - e[1], 2), l = 2 * ((i[0] - e[0]) * (e[0] - c[0]) + (i[1] - e[1]) * (e[1] - c[1])), m = Math.pow(e[0] - c[0], 2) + Math.pow(e[1] - c[1], 2) - Math.pow(j, 2), n = Math.pow(l, 2) - 4 * k * m, o = g, p = h;
                    if (!(n < 0)) {
                        if (0 === n) f.lerp(o, e, i, n), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, n, p, -1);
                        else {
                            var q = Math.sqrt(n), r = 1 / (2 * k), s = (-l - q) * r, t = (-l + q) * r;
                            if (s >= 0 && s <= 1 && (f.lerp(o, e, i, s), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, s, p, -1), a.shouldStop(b))) return;
                            t >= 0 && t <= 1 && (f.lerp(o, e, i, t), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, t, p, -1));
                        }
                    }
                };
            },
            {
                "../math/vec2": 30,
                "./Shape": 45
            }
        ],
        40: [
            function(a41, b38, c39) {
                function d31(a) {
                    Array.isArray(arguments[0]) && (a = {
                        vertices: arguments[0],
                        axes: arguments[1]
                    }, console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })")), a = a || {}, this.vertices = [];
                    for(var b = void 0 !== a.vertices ? a.vertices : [], c = 0; c < b.length; c++){
                        var d = f14.create();
                        f14.copy(d, b[c]), this.vertices.push(d);
                    }
                    if (this.axes = [], a.axes) for(var c = 0; c < a.axes.length; c++){
                        var g = f14.create();
                        f14.copy(g, a.axes[c]), this.axes.push(g);
                    }
                    else for(var c = 0; c < this.vertices.length; c++){
                        var h = this.vertices[c], i = this.vertices[(c + 1) % this.vertices.length], j = f14.create();
                        f14.sub(j, i, h), f14.rotate90cw(j, j), f14.normalize(j, j), this.axes.push(j);
                    }
                    if (this.centerOfMass = f14.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, a.type = e19.CONVEX, e19.call(this, a), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.");
                }
                var e19 = a41("./Shape"), f14 = a41("../math/vec2"), g12 = a41("../math/polyk");
                a41("poly-decomp");
                b38.exports = d31, d31.prototype = new e19, d31.prototype.constructor = d31;
                var h11 = f14.create(), i10 = f14.create();
                d31.prototype.projectOntoLocalAxis = function(a, b) {
                    for(var c, d, e = null, g = null, a = h11, i = 0; i < this.vertices.length; i++)c = this.vertices[i], d = f14.dot(c, a), (null === e || d > e) && (e = d), (null === g || d < g) && (g = d);
                    if (g > e) {
                        var j = g;
                        g = e, e = j;
                    }
                    f14.set(b, g, e);
                }, d31.prototype.projectOntoWorldAxis = function(a, b, c, d) {
                    var e = i10;
                    this.projectOntoLocalAxis(a, d), 0 !== c ? f14.rotate(e, a, c) : e = a;
                    var g = f14.dot(b, e);
                    f14.set(d, d[0] + g, d[1] + g);
                }, d31.prototype.updateTriangles = function() {
                    this.triangles.length = 0;
                    for(var a = [], b = 0; b < this.vertices.length; b++){
                        var c = this.vertices[b];
                        a.push(c[0], c[1]);
                    }
                    for(var d = g12.Triangulate(a), b = 0; b < d.length; b += 3){
                        var e = d[b], f = d[b + 1], h = d[b + 2];
                        this.triangles.push([
                            e,
                            f,
                            h
                        ]);
                    }
                };
                var j8 = f14.create(), k7 = f14.create(), l6 = f14.create(), m4 = f14.create(), n4 = f14.create();
                f14.create(), f14.create(), f14.create(), f14.create();
                d31.prototype.updateCenterOfMass = function() {
                    var a = this.triangles, b = this.vertices, c = this.centerOfMass, e = j8, g = l6, h = m4, i = n4, o = k7;
                    f14.set(c, 0, 0);
                    for(var p = 0, q = 0; q !== a.length; q++){
                        var r = a[q], g = b[r[0]], h = b[r[1]], i = b[r[2]];
                        f14.centroid(e, g, h, i);
                        var s = d31.triangleArea(g, h, i);
                        p += s, f14.scale(o, e, s), f14.add(c, c, o);
                    }
                    f14.scale(c, c, 1 / p);
                }, d31.prototype.computeMomentOfInertia = function(a) {
                    for(var b = 0, c = 0, d = this.vertices.length, e = d - 1, g = 0; g < d; e = g, g++){
                        var h = this.vertices[e], i = this.vertices[g], j = Math.abs(f14.crossLength(h, i));
                        b += j * (f14.dot(i, i) + f14.dot(i, h) + f14.dot(h, h)), c += j;
                    }
                    return a / 6 * (b / c);
                }, d31.prototype.updateBoundingRadius = function() {
                    for(var a = this.vertices, b = 0, c = 0; c !== a.length; c++){
                        var d = f14.squaredLength(a[c]);
                        d > b && (b = d);
                    }
                    this.boundingRadius = Math.sqrt(b);
                }, d31.triangleArea = function(a, b, c) {
                    return 0.5 * ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]));
                }, d31.prototype.updateArea = function() {
                    this.updateTriangles(), this.area = 0;
                    for(var a = this.triangles, b = this.vertices, c = 0; c !== a.length; c++){
                        var e = a[c], f = b[e[0]], g = b[e[1]], h = b[e[2]], i = d31.triangleArea(f, g, h);
                        this.area += i;
                    }
                }, d31.prototype.computeAABB = function(a, b, c) {
                    a.setFromPoints(this.vertices, b, c, 0);
                };
                var o3 = f14.create(), p2 = f14.create(), q2 = f14.create();
                d31.prototype.raycast = function(a, b, c, d) {
                    var e = o3, g = p2, h = q2, i = this.vertices;
                    f14.toLocalFrame(e, b.from, c, d), f14.toLocalFrame(g, b.to, c, d);
                    for(var j = i.length, k = 0; k < j && !a.shouldStop(b); k++){
                        var l = i[k], m = i[(k + 1) % j], n = f14.getLineSegmentsIntersectionFraction(e, g, l, m);
                        n >= 0 && (f14.sub(h, m, l), f14.rotate(h, h, -Math.PI / 2 + d), f14.normalize(h, h), b.reportIntersection(a, n, h, k));
                    }
                };
            },
            {
                "../math/polyk": 29,
                "../math/vec2": 30,
                "./Shape": 45,
                "poly-decomp": 5
            }
        ],
        41: [
            function(a42, b39, c40) {
                function d32(a) {
                    if (Array.isArray(arguments[0])) {
                        if (a = {
                            heights: arguments[0]
                        }, "object" == typeof arguments[1]) for(var b in arguments[1])a[b] = arguments[1][b];
                        console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })");
                    }
                    a = a || {}, this.heights = a.heights ? a.heights.slice(0) : [], this.maxValue = a.maxValue || null, this.minValue = a.minValue || null, this.elementWidth = a.elementWidth || 0.1, void 0 !== a.maxValue && void 0 !== a.minValue || this.updateMaxMinValues(), a.type = e20.HEIGHTFIELD, e20.call(this, a);
                }
                var e20 = a42("./Shape"), f = a42("../math/vec2");
                a42("../utils/Utils");
                b39.exports = d32, d32.prototype = new e20, d32.prototype.constructor = d32, d32.prototype.updateMaxMinValues = function() {
                    for(var a = this.heights, b = a[0], c = a[0], d = 0; d !== a.length; d++){
                        var e = a[d];
                        e > b && (b = e), e < c && (c = e);
                    }
                    this.maxValue = b, this.minValue = c;
                }, d32.prototype.computeMomentOfInertia = function(a) {
                    return Number.MAX_VALUE;
                }, d32.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE;
                }, d32.prototype.updateArea = function() {
                    for(var a = this.heights, b = 0, c = 0; c < a.length - 1; c++)b += (a[c] + a[c + 1]) / 2 * this.elementWidth;
                    this.area = b;
                };
                var g13 = [
                    f.create(),
                    f.create(),
                    f.create(),
                    f.create()
                ];
                d32.prototype.computeAABB = function(a, b, c) {
                    f.set(g13[0], 0, this.maxValue), f.set(g13[1], this.elementWidth * this.heights.length, this.maxValue), f.set(g13[2], this.elementWidth * this.heights.length, this.minValue), f.set(g13[3], 0, this.minValue), a.setFromPoints(g13, b, c);
                }, d32.prototype.getLineSegment = function(a, b, c) {
                    var d = this.heights, e = this.elementWidth;
                    f.set(a, c * e, d[c]), f.set(b, (c + 1) * e, d[c + 1]);
                }, d32.prototype.getSegmentIndex = function(a) {
                    return Math.floor(a[0] / this.elementWidth);
                }, d32.prototype.getClampedSegmentIndex = function(a) {
                    var b = this.getSegmentIndex(a);
                    return b = Math.min(this.heights.length, Math.max(b, 0));
                };
                var h = (f.create(), f.create()), i = f.create(), j = f.create(), k = f.create(), l = f.create();
                f.fromValues(0, 1);
                d32.prototype.raycast = function(a, b, c, d) {
                    var e = b.from, g = b.to, m = (b.direction, h), n = i, o = j, p = k, q = l;
                    f.toLocalFrame(p, e, c, d), f.toLocalFrame(q, g, c, d);
                    var r = this.getClampedSegmentIndex(p), s = this.getClampedSegmentIndex(q);
                    if (r > s) {
                        var t = r;
                        r = s, s = t;
                    }
                    for(var u = 0; u < this.heights.length - 1; u++){
                        this.getLineSegment(n, o, u);
                        var v = f.getLineSegmentsIntersectionFraction(p, q, n, o);
                        if (v >= 0 && (f.sub(m, o, n), f.rotate(m, m, d + Math.PI / 2), f.normalize(m, m), b.reportIntersection(a, v, m, -1), a.shouldStop(b))) return;
                    }
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }
        ],
        42: [
            function(a43, b40, c41) {
                function d33(a) {
                    "number" == typeof arguments[0] && (a = {
                        length: arguments[0]
                    }, console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })")), a = a || {}, this.length = a.length || 1, a.type = e21.LINE, e21.call(this, a);
                }
                var e21 = a43("./Shape"), f = a43("../math/vec2");
                b40.exports = d33, d33.prototype = new e21, d33.prototype.constructor = d33, d33.prototype.computeMomentOfInertia = function(a) {
                    return a * Math.pow(this.length, 2) / 12;
                }, d33.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.length / 2;
                };
                var g14 = [
                    f.create(),
                    f.create()
                ];
                d33.prototype.computeAABB = function(a, b, c) {
                    var d = this.length / 2;
                    f.set(g14[0], -d, 0), f.set(g14[1], d, 0), a.setFromPoints(g14, b, c, 0);
                };
                var h = (f.create(), f.create()), i = f.create(), j = f.create(), k = f.fromValues(0, 1);
                d33.prototype.raycast = function(a, b, c, d) {
                    var e = b.from, g = b.to, l = i, m = j, n = this.length / 2;
                    f.set(l, -n, 0), f.set(m, n, 0), f.toGlobalFrame(l, l, c, d), f.toGlobalFrame(m, m, c, d);
                    var o = f.getLineSegmentsIntersectionFraction(l, m, e, g);
                    if (o >= 0) {
                        var p = h;
                        f.rotate(p, k, d), b.reportIntersection(a, o, p, -1);
                    }
                };
            },
            {
                "../math/vec2": 30,
                "./Shape": 45
            }
        ],
        43: [
            function(a44, b41, c) {
                function d(a) {
                    a = a || {}, a.type = e.PARTICLE, e.call(this, a);
                }
                var e = a44("./Shape"), f = a44("../math/vec2");
                b41.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                    return 0;
                }, d.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = 0;
                }, d.prototype.computeAABB = function(a, b, c) {
                    f.copy(a.lowerBound, b), f.copy(a.upperBound, b);
                };
            },
            {
                "../math/vec2": 30,
                "./Shape": 45
            }
        ],
        44: [
            function(a45, b42, c42) {
                function d34(a) {
                    a = a || {}, a.type = e22.PLANE, e22.call(this, a);
                }
                var e22 = a45("./Shape"), f = a45("../math/vec2");
                a45("../utils/Utils");
                b42.exports = d34, d34.prototype = new e22, d34.prototype.constructor = d34, d34.prototype.computeMomentOfInertia = function(a) {
                    return 0;
                }, d34.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE;
                }, d34.prototype.computeAABB = function(a, b, c) {
                    var d = c % (2 * Math.PI), e = f.set, g = 10000000, h = a.lowerBound, i = a.upperBound;
                    e(h, -g, -g), e(i, g, g), 0 === d ? i[1] = 0 : d === Math.PI / 2 ? h[0] = 0 : d === Math.PI ? h[1] = 0 : d === 3 * Math.PI / 2 && (i[0] = 0);
                }, d34.prototype.updateArea = function() {
                    this.area = Number.MAX_VALUE;
                };
                var g15 = f.create(), h12 = (f.create(), f.create(), f.create()), i11 = f.create();
                d34.prototype.raycast = function(a, b, c, d) {
                    var e = b.from, j = b.to, k = b.direction, l = g15, m = h12, n = i11;
                    f.set(m, 0, 1), f.rotate(m, m, d), f.sub(n, e, c);
                    var o = f.dot(n, m);
                    if (f.sub(n, j, c), !(o * f.dot(n, m) > 0 || f.squaredDistance(e, j) < o * o)) {
                        var p = f.dot(m, k);
                        f.sub(l, e, c);
                        var q = -f.dot(m, l) / p / b.length;
                        b.reportIntersection(a, q, m, -1);
                    }
                };
            },
            {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }
        ],
        45: [
            function(a46, b, c) {
                function d(a) {
                    a = a || {}, this.body = null, this.position = e.fromValues(0, 0), a.position && e.copy(this.position, a.position), this.angle = a.angle || 0, this.type = a.type || 0, this.id = d.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : 1, this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse, this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : 1, this.material = a.material || null, this.area = 0, this.sensor = void 0 !== a.sensor && a.sensor, this.type && this.updateBoundingRadius(), this.updateArea();
                }
                b.exports = d;
                var e = a46("../math/vec2");
                d.idCounter = 0, d.CIRCLE = 1, d.PARTICLE = 2, d.PLANE = 4, d.CONVEX = 8, d.LINE = 16, d.BOX = 32, Object.defineProperty(d, "RECTANGLE", {
                    get: function() {
                        return console.warn("Shape.RECTANGLE is deprecated, use Shape.BOX instead."), d.BOX;
                    }
                }), d.CAPSULE = 64, d.HEIGHTFIELD = 128, d.prototype.computeMomentOfInertia = function(a) {}, d.prototype.updateBoundingRadius = function() {}, d.prototype.updateArea = function() {}, d.prototype.computeAABB = function(a, b, c) {}, d.prototype.raycast = function(a, b, c, d) {};
            },
            {
                "../math/vec2": 30
            }
        ],
        46: [
            function(a47, b43, c43) {
                function d35(a) {
                    g16.call(this, a, g16.GS), a = a || {}, this.iterations = a.iterations || 10, this.tolerance = a.tolerance || 0.0000001, this.arrayStep = 30, this.lambda = new h13.ARRAY_TYPE(this.arrayStep), this.Bs = new h13.ARRAY_TYPE(this.arrayStep), this.invCs = new h13.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = void 0 !== a.frictionIterations ? 0 : a.frictionIterations, this.usedIterations = 0;
                }
                function e23(a) {
                    for(var b = a.length; b--;)a[b] = 0;
                }
                var f15 = a47("../math/vec2"), g16 = a47("./Solver"), h13 = a47("../utils/Utils"), i = a47("../equations/FrictionEquation");
                b43.exports = d35, d35.prototype = new g16, d35.prototype.constructor = d35, d35.prototype.solve = function(a, b) {
                    this.sortEquations();
                    var c = 0, g = this.iterations, j = this.frictionIterations, k = this.equations, l = k.length, m = Math.pow(this.tolerance * l, 2), n = b.bodies, o = b.bodies.length, p = (f15.add, f15.set, this.useZeroRHS), q = this.lambda;
                    if (this.usedIterations = 0, l) for(var r = 0; r !== o; r++){
                        var s = n[r];
                        s.updateSolveMassProperties();
                    }
                    q.length < l && (q = this.lambda = new h13.ARRAY_TYPE(l + this.arrayStep), this.Bs = new h13.ARRAY_TYPE(l + this.arrayStep), this.invCs = new h13.ARRAY_TYPE(l + this.arrayStep)), e23(q);
                    for(var t = this.invCs, u = this.Bs, q = this.lambda, r = 0; r !== k.length; r++){
                        var v = k[r];
                        (v.timeStep !== a || v.needsUpdate) && (v.timeStep = a, v.update()), u[r] = v.computeB(v.a, v.b, a), t[r] = v.computeInvC(v.epsilon);
                    }
                    var v, w, r, x;
                    if (0 !== l) {
                        for(r = 0; r !== o; r++){
                            var s = n[r];
                            s.resetConstraintVelocity();
                        }
                        if (j) {
                            for(c = 0; c !== j; c++){
                                for(w = 0, x = 0; x !== l; x++){
                                    v = k[x];
                                    var y = d35.iterateEquation(x, v, v.epsilon, u, t, q, p, a, c);
                                    w += Math.abs(y);
                                }
                                if (this.usedIterations++, w * w <= m) break;
                            }
                            for(d35.updateMultipliers(k, q, 1 / a), x = 0; x !== l; x++){
                                var z = k[x];
                                if (z instanceof i) {
                                    for(var A = 0, B = 0; B !== z.contactEquations.length; B++)A += z.contactEquations[B].multiplier;
                                    A *= z.frictionCoefficient / z.contactEquations.length, z.maxForce = A, z.minForce = -A;
                                }
                            }
                        }
                        for(c = 0; c !== g; c++){
                            for(w = 0, x = 0; x !== l; x++){
                                v = k[x];
                                var y = d35.iterateEquation(x, v, v.epsilon, u, t, q, p, a, c);
                                w += Math.abs(y);
                            }
                            if (this.usedIterations++, w * w <= m) break;
                        }
                        for(r = 0; r !== o; r++)n[r].addConstraintVelocity();
                        d35.updateMultipliers(k, q, 1 / a);
                    }
                }, d35.updateMultipliers = function(a, b, c) {
                    for(var d = a.length; d--;)a[d].multiplier = b[d] * c;
                }, d35.iterateEquation = function(a, b, c, d, e, f, g, h, i) {
                    var j = d[a], k = e[a], l = f[a], m = b.computeGWlambda(), n = b.maxForce, o = b.minForce;
                    g && (j = 0);
                    var p = k * (j - m - c * l), q = l + p;
                    return q < o * h ? p = o * h - l : q > n * h && (p = n * h - l), f[a] += p, b.addToWlambda(p), p;
                };
            },
            {
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Solver": 47
            }
        ],
        47: [
            function(a48, b44, c44) {
                function d36(a, b) {
                    a = a || {}, e.call(this), this.type = b, this.equations = [], this.equationSortFunction = a.equationSortFunction || !1;
                }
                var e = (a48("../utils/Utils"), a48("../events/EventEmitter"));
                b44.exports = d36, d36.prototype = new e, d36.prototype.constructor = d36, d36.prototype.solve = function(a, b) {
                    throw new Error("Solver.solve should be implemented by subclasses!");
                };
                var f = {
                    bodies: []
                };
                d36.prototype.solveIsland = function(a, b) {
                    this.removeAllEquations(), b.equations.length && (this.addEquations(b.equations), f.bodies.length = 0, b.getBodies(f.bodies), f.bodies.length && this.solve(a, f));
                }, d36.prototype.sortEquations = function() {
                    this.equationSortFunction && this.equations.sort(this.equationSortFunction);
                }, d36.prototype.addEquation = function(a) {
                    a.enabled && this.equations.push(a);
                }, d36.prototype.addEquations = function(a) {
                    for(var b = 0, c = a.length; b !== c; b++){
                        var d = a[b];
                        d.enabled && this.equations.push(d);
                    }
                }, d36.prototype.removeEquation = function(a) {
                    var b = this.equations.indexOf(a);
                    -1 !== b && this.equations.splice(b, 1);
                }, d36.prototype.removeAllEquations = function() {
                    this.equations.length = 0;
                }, d36.GS = 1, d36.ISLAND = 2;
            },
            {
                "../events/EventEmitter": 26,
                "../utils/Utils": 57
            }
        ],
        48: [
            function(a49, b, c) {
                function d() {
                    f.apply(this, arguments);
                }
                var e = a49("../equations/ContactEquation"), f = a49("./Pool");
                b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                    return new e;
                }, d.prototype.destroy = function(a) {
                    return a.bodyA = a.bodyB = null, this;
                };
            },
            {
                "../equations/ContactEquation": 21,
                "./Pool": 55
            }
        ],
        49: [
            function(a50, b, c) {
                function d() {
                    f.apply(this, arguments);
                }
                var e = a50("../equations/FrictionEquation"), f = a50("./Pool");
                b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                    return new e;
                }, d.prototype.destroy = function(a) {
                    return a.bodyA = a.bodyB = null, this;
                };
            },
            {
                "../equations/FrictionEquation": 23,
                "./Pool": 55
            }
        ],
        50: [
            function(a51, b, c) {
                function d() {
                    f.apply(this, arguments);
                }
                var e = a51("../world/IslandNode"), f = a51("./Pool");
                b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                    return new e;
                }, d.prototype.destroy = function(a) {
                    return a.reset(), this;
                };
            },
            {
                "../world/IslandNode": 60,
                "./Pool": 55
            }
        ],
        51: [
            function(a52, b, c) {
                function d() {
                    f.apply(this, arguments);
                }
                var e = a52("../world/Island"), f = a52("./Pool");
                b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                    return new e;
                }, d.prototype.destroy = function(a) {
                    return a.reset(), this;
                };
            },
            {
                "../world/Island": 58,
                "./Pool": 55
            }
        ],
        52: [
            function(a53, b45, c45) {
                function d37() {
                    this.overlappingShapesLastState = new e24, this.overlappingShapesCurrentState = new e24, this.recordPool = new f16({
                        size: 16
                    }), this.tmpDict = new e24, this.tmpArray1 = [];
                }
                var e24 = a53("./TupleDictionary"), f16 = (a53("./OverlapKeeperRecord"), a53("./OverlapKeeperRecordPool"));
                a53("./Utils");
                b45.exports = d37, d37.prototype.tick = function() {
                    for(var a = this.overlappingShapesLastState, b = this.overlappingShapesCurrentState, c = a.keys.length; c--;){
                        var d = a.keys[c], e = a.getByKey(d);
                        b.getByKey(d);
                        e && this.recordPool.release(e);
                    }
                    a.reset(), a.copy(b), b.reset();
                }, d37.prototype.setOverlapping = function(a, b, c, d) {
                    var e = (this.overlappingShapesLastState, this.overlappingShapesCurrentState);
                    if (!e.get(b.id, d.id)) {
                        var f = this.recordPool.get();
                        f.set(a, b, c, d), e.set(b.id, d.id, f);
                    }
                }, d37.prototype.getNewOverlaps = function(a) {
                    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, a);
                }, d37.prototype.getEndOverlaps = function(a) {
                    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, a);
                }, d37.prototype.bodiesAreOverlapping = function(a, b) {
                    for(var c = this.overlappingShapesCurrentState, d = c.keys.length; d--;){
                        var e = c.keys[d], f = c.data[e];
                        if (f.bodyA === a && f.bodyB === b || f.bodyA === b && f.bodyB === a) return !0;
                    }
                    return !1;
                }, d37.prototype.getDiff = function(a, b, c) {
                    var c = c || [], d = a, e = b;
                    c.length = 0;
                    for(var f = e.keys.length; f--;){
                        var g = e.keys[f], h = e.data[g];
                        if (!h) throw new Error("Key " + g + " had no data!");
                        d.data[g] || c.push(h);
                    }
                    return c;
                }, d37.prototype.isNewOverlap = function(a, b) {
                    var c = 0 | a.id, d = 0 | b.id, e = this.overlappingShapesLastState, f = this.overlappingShapesCurrentState;
                    return !e.get(c, d) && !!f.get(c, d);
                }, d37.prototype.getNewBodyOverlaps = function(a) {
                    this.tmpArray1.length = 0;
                    var b = this.getNewOverlaps(this.tmpArray1);
                    return this.getBodyDiff(b, a);
                }, d37.prototype.getEndBodyOverlaps = function(a) {
                    this.tmpArray1.length = 0;
                    var b = this.getEndOverlaps(this.tmpArray1);
                    return this.getBodyDiff(b, a);
                }, d37.prototype.getBodyDiff = function(a, b) {
                    b = b || [];
                    for(var c = this.tmpDict, d = a.length; d--;){
                        var e = a[d];
                        c.set(0 | e.bodyA.id, 0 | e.bodyB.id, e);
                    }
                    for(d = c.keys.length; d--;){
                        var e = c.getByKey(c.keys[d]);
                        e && b.push(e.bodyA, e.bodyB);
                    }
                    return c.reset(), b;
                };
            },
            {
                "./OverlapKeeperRecord": 53,
                "./OverlapKeeperRecordPool": 54,
                "./TupleDictionary": 56,
                "./Utils": 57
            }
        ],
        53: [
            function(a54, b46, c46) {
                function d38(a, b, c, d) {
                    this.shapeA = b, this.shapeB = d, this.bodyA = a, this.bodyB = c;
                }
                b46.exports = d38, d38.prototype.set = function(a, b, c, e) {
                    d38.call(this, a, b, c, e);
                };
            },
            {}
        ],
        54: [
            function(a55, b, c) {
                function d() {
                    f.apply(this, arguments);
                }
                var e = a55("./OverlapKeeperRecord"), f = a55("./Pool");
                b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() {
                    return new e;
                }, d.prototype.destroy = function(a) {
                    return a.bodyA = a.bodyB = a.shapeA = a.shapeB = null, this;
                };
            },
            {
                "./OverlapKeeperRecord": 53,
                "./Pool": 55
            }
        ],
        55: [
            function(a56, b47, c) {
                function d(a) {
                    a = a || {}, this.objects = [], void 0 !== a.size && this.resize(a.size);
                }
                b47.exports = d, d.prototype.resize = function(a) {
                    for(var b = this.objects; b.length > a;)b.pop();
                    for(; b.length < a;)b.push(this.create());
                    return this;
                }, d.prototype.get = function() {
                    var a = this.objects;
                    return a.length ? a.pop() : this.create();
                }, d.prototype.release = function(a) {
                    return this.destroy(a), this.objects.push(a), this;
                };
            },
            {}
        ],
        56: [
            function(a57, b48, c47) {
                function d39() {
                    this.data = {}, this.keys = [];
                }
                var e = a57("./Utils");
                b48.exports = d39, d39.prototype.getKey = function(a, b) {
                    return a |= 0, b |= 0, (0 | a) == (0 | b) ? -1 : 0 | ((0 | a) > (0 | b) ? a << 16 | 65535 & b : b << 16 | 65535 & a);
                }, d39.prototype.getByKey = function(a) {
                    return a |= 0, this.data[a];
                }, d39.prototype.get = function(a, b) {
                    return this.data[this.getKey(a, b)];
                }, d39.prototype.set = function(a, b, c) {
                    if (!c) throw new Error("No data!");
                    var d = this.getKey(a, b);
                    return this.data[d] || this.keys.push(d), this.data[d] = c, d;
                }, d39.prototype.reset = function() {
                    for(var a = this.data, b = this.keys, c = b.length; c--;)delete a[b[c]];
                    b.length = 0;
                }, d39.prototype.copy = function(a) {
                    this.reset(), e.appendArray(this.keys, a.keys);
                    for(var b = a.keys.length; b--;){
                        var c = a.keys[b];
                        this.data[c] = a.data[c];
                    }
                };
            },
            {
                "./Utils": 57
            }
        ],
        57: [
            function(a58, b49, c48) {
                function d40() {}
                b49.exports = d40, d40.appendArray = function(a, b) {
                    if (b.length < 150000) a.push.apply(a, b);
                    else for(var c = 0, d = b.length; c !== d; ++c)a.push(b[c]);
                }, d40.splice = function(a, b, c) {
                    c = c || 1;
                    for(var d = b, e = a.length - c; d < e; d++)a[d] = a[d + c];
                    a.length = e;
                }, "undefined" != typeof P2_ARRAY_TYPE ? d40.ARRAY_TYPE = P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? d40.ARRAY_TYPE = Float32Array : d40.ARRAY_TYPE = Array, d40.extend = function(a, b) {
                    for(var c in b)a[c] = b[c];
                }, d40.defaults = function(a, b) {
                    a = a || {};
                    for(var c in b)c in a || (a[c] = b[c]);
                    return a;
                };
            },
            {}
        ],
        58: [
            function(a59, b50, c49) {
                function d41() {
                    this.equations = [], this.bodies = [];
                }
                var e25 = a59("../objects/Body");
                b50.exports = d41, d41.prototype.reset = function() {
                    this.equations.length = this.bodies.length = 0;
                };
                var f = [];
                d41.prototype.getBodies = function(a) {
                    var b = a || [], c = this.equations;
                    f.length = 0;
                    for(var d = 0; d !== c.length; d++){
                        var e = c[d];
                        -1 === f.indexOf(e.bodyA.id) && (b.push(e.bodyA), f.push(e.bodyA.id)), -1 === f.indexOf(e.bodyB.id) && (b.push(e.bodyB), f.push(e.bodyB.id));
                    }
                    return b;
                }, d41.prototype.wantsToSleep = function() {
                    for(var a = 0; a < this.bodies.length; a++){
                        var b = this.bodies[a];
                        if (b.type === e25.DYNAMIC && !b.wantsToSleep) return !1;
                    }
                    return !0;
                }, d41.prototype.sleep = function() {
                    for(var a = 0; a < this.bodies.length; a++)this.bodies[a].sleep();
                    return !0;
                };
            },
            {
                "../objects/Body": 31
            }
        ],
        59: [
            function(a60, b51, c50) {
                function d42(a) {
                    this.nodePool = new e26({
                        size: 16
                    }), this.islandPool = new f17({
                        size: 8
                    }), this.equations = [], this.islands = [], this.nodes = [], this.queue = [];
                }
                var e26 = (a60("../math/vec2"), a60("./Island"), a60("./IslandNode"), a60("./../utils/IslandNodePool")), f17 = a60("./../utils/IslandPool"), g17 = a60("../objects/Body");
                b51.exports = d42, d42.getUnvisitedNode = function(a) {
                    for(var b = a.length, c = 0; c !== b; c++){
                        var d = a[c];
                        if (!d.visited && d.body.type === g17.DYNAMIC) return d;
                    }
                    return !1;
                }, d42.prototype.visit = function(a, b, c) {
                    b.push(a.body);
                    for(var d = a.equations.length, e = 0; e !== d; e++){
                        var f = a.equations[e];
                        -1 === c.indexOf(f) && c.push(f);
                    }
                }, d42.prototype.bfs = function(a, b, c) {
                    var e = this.queue;
                    for(e.length = 0, e.push(a), a.visited = !0, this.visit(a, b, c); e.length;)for(var f, h = e.pop(); f = d42.getUnvisitedNode(h.neighbors);)f.visited = !0, this.visit(f, b, c), f.body.type === g17.DYNAMIC && e.push(f);
                }, d42.prototype.split = function(a) {
                    for(var b = a.bodies, c = this.nodes, e = this.equations; c.length;)this.nodePool.release(c.pop());
                    for(var f = 0; f !== b.length; f++){
                        var g = this.nodePool.get();
                        g.body = b[f], c.push(g);
                    }
                    for(var h = 0; h !== e.length; h++){
                        var i = e[h], f = b.indexOf(i.bodyA), j = b.indexOf(i.bodyB), k = c[f], l = c[j];
                        k.neighbors.push(l), l.neighbors.push(k), k.equations.push(i), l.equations.push(i);
                    }
                    for(var m = this.islands, f = 0; f < m.length; f++)this.islandPool.release(m[f]);
                    m.length = 0;
                    for(var n; n = d42.getUnvisitedNode(c);){
                        var o = this.islandPool.get();
                        this.bfs(n, o.bodies, o.equations), m.push(o);
                    }
                    return m;
                };
            },
            {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "./../utils/IslandNodePool": 50,
                "./../utils/IslandPool": 51,
                "./Island": 58,
                "./IslandNode": 60
            }
        ],
        60: [
            function(a61, b, c) {
                function d(a) {
                    this.body = a, this.neighbors = [], this.equations = [], this.visited = !1;
                }
                b.exports = d, d.prototype.reset = function() {
                    this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null;
                };
            },
            {}
        ],
        61: [
            function(a62, b52, c51) {
                function d43(a) {
                    l7.apply(this), a = a || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = a.solver || new e27, this.narrowphase = new r2(this), this.islandManager = new u2, this.gravity = f18.fromValues(0, -9.78), a.gravity && f18.copy(this.gravity, a.gravity), this.frictionGravity = f18.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = a.broadphase || new q3, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new n5, this.defaultContactMaterial = new o4(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === a.islandSplit || !!a.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                        type: "postStep"
                    }, this.addBodyEvent = {
                        type: "addBody",
                        body: null
                    }, this.removeBodyEvent = {
                        type: "removeBody",
                        body: null
                    }, this.addSpringEvent = {
                        type: "addSpring",
                        spring: null
                    }, this.impactEvent = {
                        type: "impact",
                        bodyA: null,
                        bodyB: null,
                        shapeA: null,
                        shapeB: null,
                        contactEquation: null
                    }, this.postBroadphaseEvent = {
                        type: "postBroadphase",
                        pairs: null
                    }, this.sleepMode = d43.NO_SLEEPING, this.beginContactEvent = {
                        type: "beginContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null,
                        contactEquations: []
                    }, this.endContactEvent = {
                        type: "endContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null
                    }, this.preSolveEvent = {
                        type: "preSolve",
                        contactEquations: null,
                        frictionEquations: null
                    }, this.overlappingShapesLastState = {
                        keys: []
                    }, this.overlappingShapesCurrentState = {
                        keys: []
                    }, this.overlapKeeper = new t2;
                }
                var e27 = a62("../solver/GSSolver"), f18 = (a62("../solver/Solver"), a62("../collision/Ray"), a62("../math/vec2")), g18 = a62("../shapes/Circle"), h14 = a62("../shapes/Convex"), i12 = (a62("../shapes/Line"), a62("../shapes/Plane")), j9 = a62("../shapes/Capsule"), k8 = a62("../shapes/Particle"), l7 = a62("../events/EventEmitter"), m = a62("../objects/Body"), n5 = (a62("../shapes/Shape"), a62("../objects/LinearSpring"), a62("../material/Material")), o4 = a62("../material/ContactMaterial"), p3 = (a62("../constraints/DistanceConstraint"), a62("../constraints/Constraint"), a62("../constraints/LockConstraint"), a62("../constraints/RevoluteConstraint"), a62("../constraints/PrismaticConstraint"), a62("../constraints/GearConstraint"), a62("../../package.json"), a62("../collision/Broadphase"), a62("../collision/AABB")), q3 = a62("../collision/SAPBroadphase"), r2 = a62("../collision/Narrowphase"), s2 = a62("../utils/Utils"), t2 = a62("../utils/OverlapKeeper"), u2 = a62("./IslandManager");
                a62("../objects/RotationalSpring");
                b52.exports = d43, d43.prototype = new Object(l7.prototype), d43.prototype.constructor = d43, d43.NO_SLEEPING = 1, d43.BODY_SLEEPING = 2, d43.ISLAND_SLEEPING = 4, d43.prototype.addConstraint = function(a) {
                    this.constraints.push(a);
                }, d43.prototype.addContactMaterial = function(a) {
                    this.contactMaterials.push(a);
                }, d43.prototype.removeContactMaterial = function(a) {
                    var b = this.contactMaterials.indexOf(a);
                    -1 !== b && s2.splice(this.contactMaterials, b, 1);
                }, d43.prototype.getContactMaterial = function(a, b) {
                    for(var c = this.contactMaterials, d = 0, e = c.length; d !== e; d++){
                        var f = c[d];
                        if (f.materialA.id === a.id && f.materialB.id === b.id || f.materialA.id === b.id && f.materialB.id === a.id) return f;
                    }
                    return !1;
                }, d43.prototype.removeConstraint = function(a) {
                    var b = this.constraints.indexOf(a);
                    -1 !== b && s2.splice(this.constraints, b, 1);
                };
                var v2 = (f18.create(), f18.create(), f18.create(), f18.create(), f18.create(), f18.create(), f18.create()), w2 = f18.fromValues(0, 0), x2 = f18.fromValues(0, 0);
                f18.fromValues(0, 0), f18.fromValues(0, 0);
                d43.prototype.step = function(a, b, c) {
                    if (c = c || 10, 0 === (b = b || 0)) this.internalStep(a), this.time += a;
                    else {
                        this.accumulator += b;
                        for(var d = 0; this.accumulator >= a && d < c;)this.internalStep(a), this.time += a, this.accumulator -= a, d++;
                        for(var e = this.accumulator % a / a, g = 0; g !== this.bodies.length; g++){
                            var h = this.bodies[g];
                            f18.lerp(h.interpolatedPosition, h.previousPosition, h.position, e), h.interpolatedAngle = h.previousAngle + e * (h.angle - h.previousAngle);
                        }
                    }
                };
                var y2 = [];
                d43.prototype.internalStep = function(a) {
                    this.stepping = !0;
                    var b = this.springs.length, c = this.springs, e = this.bodies, g = this.gravity, h = this.solver, i = this.bodies.length, j = this.broadphase, k = this.narrowphase, l = this.constraints, n = v2, o = (f18.scale, f18.add), p = (f18.rotate, this.islandManager);
                    if (this.overlapKeeper.tick(), this.lastTimeStep = a, this.useWorldGravityAsFrictionGravity) {
                        var q = f18.length(this.gravity);
                        0 === q && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = q);
                    }
                    if (this.applyGravity) for(var r = 0; r !== i; r++){
                        var t = e[r], u = t.force;
                        t.type === m.DYNAMIC && t.sleepState !== m.SLEEPING && (f18.scale(n, g, t.mass * t.gravityScale), o(u, u, n));
                    }
                    if (this.applySpringForces) for(var r = 0; r !== b; r++){
                        var w = c[r];
                        w.applyForce();
                    }
                    if (this.applyDamping) for(var r = 0; r !== i; r++){
                        var t = e[r];
                        t.type === m.DYNAMIC && t.applyDamping(a);
                    }
                    for(var x = j.getCollisionPairs(this), z = this.disabledBodyCollisionPairs, r = z.length - 2; r >= 0; r -= 2)for(var A = x.length - 2; A >= 0; A -= 2)(z[r] === x[A] && z[r + 1] === x[A + 1] || z[r + 1] === x[A] && z[r] === x[A + 1]) && x.splice(A, 2);
                    var B = l.length;
                    for(r = 0; r !== B; r++){
                        var C = l[r];
                        if (!C.collideConnected) for(var A = x.length - 2; A >= 0; A -= 2)(C.bodyA === x[A] && C.bodyB === x[A + 1] || C.bodyB === x[A] && C.bodyA === x[A + 1]) && x.splice(A, 2);
                    }
                    this.postBroadphaseEvent.pairs = x, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, k.reset(this);
                    for(var r = 0, D = x.length; r !== D; r += 2)for(var E = x[r], F = x[r + 1], G = 0, H = E.shapes.length; G !== H; G++)for(var I = E.shapes[G], J = I.position, K = I.angle, L = 0, M = F.shapes.length; L !== M; L++){
                        var N = F.shapes[L], O = N.position, P = N.angle, Q = this.defaultContactMaterial;
                        if (I.material && N.material) {
                            var R = this.getContactMaterial(I.material, N.material);
                            R && (Q = R);
                        }
                        this.runNarrowphase(k, E, I, J, K, F, N, O, P, Q, this.frictionGravity);
                    }
                    for(var r = 0; r !== i; r++){
                        var S = e[r];
                        S._wakeUpAfterNarrowphase && (S.wakeUp(), S._wakeUpAfterNarrowphase = !1);
                    }
                    if (this.has("endContact")) {
                        this.overlapKeeper.getEndOverlaps(y2);
                        for(var T = this.endContactEvent, L = y2.length; L--;){
                            var U = y2[L];
                            T.shapeA = U.shapeA, T.shapeB = U.shapeB, T.bodyA = U.bodyA, T.bodyB = U.bodyB, this.emit(T);
                        }
                        y2.length = 0;
                    }
                    var V = this.preSolveEvent;
                    V.contactEquations = k.contactEquations, V.frictionEquations = k.frictionEquations, this.emit(V), V.contactEquations = V.frictionEquations = null;
                    var B = l.length;
                    for(r = 0; r !== B; r++)l[r].update();
                    if (k.contactEquations.length || k.frictionEquations.length || B) {
                        if (this.islandSplit) {
                            for(p.equations.length = 0, s2.appendArray(p.equations, k.contactEquations), s2.appendArray(p.equations, k.frictionEquations), r = 0; r !== B; r++)s2.appendArray(p.equations, l[r].equations);
                            p.split(this);
                            for(var r = 0; r !== p.islands.length; r++){
                                var W = p.islands[r];
                                W.equations.length && h.solveIsland(a, W);
                            }
                        } else {
                            for(h.addEquations(k.contactEquations), h.addEquations(k.frictionEquations), r = 0; r !== B; r++)h.addEquations(l[r].equations);
                            this.solveConstraints && h.solve(a, this), h.removeAllEquations();
                        }
                    }
                    for(var r = 0; r !== i; r++){
                        var S = e[r];
                        S.integrate(a);
                    }
                    for(var r = 0; r !== i; r++)e[r].setZeroForce();
                    if (this.emitImpactEvent && this.has("impact")) for(var X = this.impactEvent, r = 0; r !== k.contactEquations.length; r++){
                        var Y = k.contactEquations[r];
                        Y.firstImpact && (X.bodyA = Y.bodyA, X.bodyB = Y.bodyB, X.shapeA = Y.shapeA, X.shapeB = Y.shapeB, X.contactEquation = Y, this.emit(X));
                    }
                    if (this.sleepMode === d43.BODY_SLEEPING) for(r = 0; r !== i; r++)e[r].sleepTick(this.time, !1, a);
                    else if (this.sleepMode === d43.ISLAND_SLEEPING && this.islandSplit) {
                        for(r = 0; r !== i; r++)e[r].sleepTick(this.time, !0, a);
                        for(var r = 0; r < this.islandManager.islands.length; r++){
                            var W = this.islandManager.islands[r];
                            W.wantsToSleep() && W.sleep();
                        }
                    }
                    this.stepping = !1;
                    for(var Z = this.bodiesToBeRemoved, r = 0; r !== Z.length; r++)this.removeBody(Z[r]);
                    Z.length = 0, this.emit(this.postStepEvent);
                }, d43.prototype.runNarrowphase = function(a, b, c, d, e, g, h, i, j, k, l) {
                    if (0 != (c.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & c.collisionMask)) {
                        f18.rotate(w2, d, b.angle), f18.rotate(x2, i, g.angle), f18.add(w2, w2, b.position), f18.add(x2, x2, g.position);
                        var n = e + b.angle, o = j + g.angle;
                        a.enableFriction = k.friction > 0, a.frictionCoefficient = k.friction;
                        var p;
                        p = b.type === m.STATIC || b.type === m.KINEMATIC ? g.mass : g.type === m.STATIC || g.type === m.KINEMATIC ? b.mass : b.mass * g.mass / (b.mass + g.mass), a.slipForce = k.friction * l * p, a.restitution = k.restitution, a.surfaceVelocity = k.surfaceVelocity, a.frictionStiffness = k.frictionStiffness, a.frictionRelaxation = k.frictionRelaxation, a.stiffness = k.stiffness, a.relaxation = k.relaxation, a.contactSkinSize = k.contactSkinSize, a.enabledEquations = b.collisionResponse && g.collisionResponse && c.collisionResponse && h.collisionResponse;
                        var q = a[c.type | h.type], r = 0;
                        if (q) {
                            var s = c.sensor || h.sensor, t = a.frictionEquations.length;
                            r = c.type < h.type ? q.call(a, b, c, w2, n, g, h, x2, o, s) : q.call(a, g, h, x2, o, b, c, w2, n, s);
                            var u = a.frictionEquations.length - t;
                            if (r) {
                                if (b.allowSleep && b.type === m.DYNAMIC && b.sleepState === m.SLEEPING && g.sleepState === m.AWAKE && g.type !== m.STATIC) f18.squaredLength(g.velocity) + Math.pow(g.angularVelocity, 2) >= 2 * Math.pow(g.sleepSpeedLimit, 2) && (b._wakeUpAfterNarrowphase = !0);
                                if (g.allowSleep && g.type === m.DYNAMIC && g.sleepState === m.SLEEPING && b.sleepState === m.AWAKE && b.type !== m.STATIC) f18.squaredLength(b.velocity) + Math.pow(b.angularVelocity, 2) >= 2 * Math.pow(b.sleepSpeedLimit, 2) && (g._wakeUpAfterNarrowphase = !0);
                                if (this.overlapKeeper.setOverlapping(b, c, g, h), this.has("beginContact") && this.overlapKeeper.isNewOverlap(c, h)) {
                                    var v = this.beginContactEvent;
                                    if (v.shapeA = c, v.shapeB = h, v.bodyA = b, v.bodyB = g, v.contactEquations.length = 0, "number" == typeof r) for(var y = a.contactEquations.length - r; y < a.contactEquations.length; y++)v.contactEquations.push(a.contactEquations[y]);
                                    this.emit(v);
                                }
                                if ("number" == typeof r && u > 1) for(var y = a.frictionEquations.length - u; y < a.frictionEquations.length; y++){
                                    var z = a.frictionEquations[y];
                                    z.setSlipForce(z.getSlipForce() / u);
                                }
                            }
                        }
                    }
                }, d43.prototype.addSpring = function(a) {
                    this.springs.push(a);
                    var b = this.addSpringEvent;
                    b.spring = a, this.emit(b), b.spring = null;
                }, d43.prototype.removeSpring = function(a) {
                    var b = this.springs.indexOf(a);
                    -1 !== b && s2.splice(this.springs, b, 1);
                }, d43.prototype.addBody = function(a) {
                    if (-1 === this.bodies.indexOf(a)) {
                        this.bodies.push(a), a.world = this;
                        var b = this.addBodyEvent;
                        b.body = a, this.emit(b), b.body = null;
                    }
                }, d43.prototype.removeBody = function(a) {
                    if (this.stepping) this.bodiesToBeRemoved.push(a);
                    else {
                        a.world = null;
                        var b = this.bodies.indexOf(a);
                        -1 !== b && (s2.splice(this.bodies, b, 1), this.removeBodyEvent.body = a, a.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null);
                    }
                }, d43.prototype.getBodyById = function(a) {
                    for(var b = this.bodies, c = 0; c < b.length; c++){
                        var d = b[c];
                        if (d.id === a) return d;
                    }
                    return !1;
                }, d43.prototype.disableBodyCollision = function(a, b) {
                    this.disabledBodyCollisionPairs.push(a, b);
                }, d43.prototype.enableBodyCollision = function(a, b) {
                    for(var c = this.disabledBodyCollisionPairs, d = 0; d < c.length; d += 2)if (c[d] === a && c[d + 1] === b || c[d + 1] === a && c[d] === b) return void c.splice(d, 2);
                }, d43.prototype.clear = function() {
                    this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                    for(var a = this.constraints, b = a.length - 1; b >= 0; b--)this.removeConstraint(a[b]);
                    for(var c = this.bodies, b = c.length - 1; b >= 0; b--)this.removeBody(c[b]);
                    for(var e = this.springs, b = e.length - 1; b >= 0; b--)this.removeSpring(e[b]);
                    for(var f = this.contactMaterials, b = f.length - 1; b >= 0; b--)this.removeContactMaterial(f[b]);
                    d43.apply(this);
                };
                var z2 = f18.create(), A2 = (f18.fromValues(0, 0), f18.fromValues(0, 0));
                d43.prototype.hitTest = function(a, b, c) {
                    c = c || 0;
                    var d = new m({
                        position: a
                    }), e = new k8, l = a, n = 0, o = z2, p = A2;
                    d.addShape(e);
                    for(var q = this.narrowphase, r = [], s = 0, t = b.length; s !== t; s++)for(var u = b[s], v = 0, w = u.shapes.length; v !== w; v++){
                        var x = u.shapes[v];
                        f18.rotate(o, x.position, u.angle), f18.add(o, o, u.position);
                        var y = x.angle + u.angle;
                        (x instanceof g18 && q.circleParticle(u, x, o, y, d, e, l, n, !0) || x instanceof h14 && q.particleConvex(d, e, l, n, u, x, o, y, !0) || x instanceof i12 && q.particlePlane(d, e, l, n, u, x, o, y, !0) || x instanceof j9 && q.particleCapsule(d, e, l, n, u, x, o, y, !0) || x instanceof k8 && f18.squaredLength(f18.sub(p, o, a)) < c * c) && r.push(u);
                    }
                    return r;
                }, d43.prototype.setGlobalStiffness = function(a) {
                    for(var b = this.constraints, c = 0; c !== b.length; c++)for(var d = b[c], e = 0; e !== d.equations.length; e++){
                        var f = d.equations[e];
                        f.stiffness = a, f.needsUpdate = !0;
                    }
                    for(var g = this.contactMaterials, c = 0; c !== g.length; c++){
                        var d = g[c];
                        d.stiffness = d.frictionStiffness = a;
                    }
                    var d = this.defaultContactMaterial;
                    d.stiffness = d.frictionStiffness = a;
                }, d43.prototype.setGlobalRelaxation = function(a) {
                    for(var b = 0; b !== this.constraints.length; b++)for(var c = this.constraints[b], d = 0; d !== c.equations.length; d++){
                        var e = c.equations[d];
                        e.relaxation = a, e.needsUpdate = !0;
                    }
                    for(var b = 0; b !== this.contactMaterials.length; b++){
                        var c = this.contactMaterials[b];
                        c.relaxation = c.frictionRelaxation = a;
                    }
                    var c = this.defaultContactMaterial;
                    c.relaxation = c.frictionRelaxation = a;
                };
                var B2 = new p3, C2 = [];
                d43.prototype.raycast = function(a, b) {
                    return b.getAABB(B2), this.broadphase.aabbQuery(this, B2, C2), b.intersectBodies(a, C2), C2.length = 0, a.hasHit();
                };
            },
            {
                "../../package.json": 6,
                "../collision/AABB": 7,
                "../collision/Broadphase": 8,
                "../collision/Narrowphase": 10,
                "../collision/Ray": 11,
                "../collision/SAPBroadphase": 13,
                "../constraints/Constraint": 14,
                "../constraints/DistanceConstraint": 15,
                "../constraints/GearConstraint": 16,
                "../constraints/LockConstraint": 17,
                "../constraints/PrismaticConstraint": 18,
                "../constraints/RevoluteConstraint": 19,
                "../events/EventEmitter": 26,
                "../material/ContactMaterial": 27,
                "../material/Material": 28,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../objects/LinearSpring": 32,
                "../objects/RotationalSpring": 33,
                "../shapes/Capsule": 38,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Line": 42,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45,
                "../solver/GSSolver": 46,
                "../solver/Solver": 47,
                "../utils/OverlapKeeper": 52,
                "../utils/Utils": 57,
                "./IslandManager": 59
            }
        ]
    }, {}, [
        36
    ])(36);
}), (function() {
    function a63(a, b, c, e) {
        var f = a.createTexture();
        return a.bindTexture(a.TEXTURE_2D, f), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e === d44.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e === d44.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, b, c, 0, a.RGBA, a.UNSIGNED_BYTE, null), f;
    }
    function b53(b, c, d, f, g) {
        var h = b.createFramebuffer(), i = b.createRenderbuffer(), j = null, k = 0;
        return b.activeTexture(b.TEXTURE0 + g), b.bindFramebuffer(b.FRAMEBUFFER, h), b.bindRenderbuffer(b.RENDERBUFFER, i), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.RENDERBUFFER, this.renderBuffer), j = a63(b, c, d, f), b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, j, 0), k = b.checkFramebufferStatus(b.FRAMEBUFFER), k !== b.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", e28[k]), h.width = c, h.height = d, h.targetTexture = j, h.renderBuffer = i, h;
    }
    var c52 = this, d44 = d44 || {};
    d44.DisplayObject = function() {
        this.position = new d44.Point(0, 0), this.scale = new d44.Point(1, 1), this.pivot = new d44.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new d44.Matrix, this.worldPosition = new d44.Point(0, 0), this.worldScale = new d44.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new d44.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1;
    }, d44.DisplayObject.prototype = {
        constructor: d44.DisplayObject,
        destroy: function() {
            if (this.children) {
                for(var a = this.children.length; a--;)this.children[a].destroy();
                this.children = [];
            }
            this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite();
        },
        updateTransform: function(a) {
            if (!a && !this.parent && !this.game) return this;
            var b = this.parent;
            a ? b = a : this.parent || (b = this.game.world);
            var c, d, e, f, g, h, i = b.worldTransform, j = this.worldTransform;
            this.rotation % Phaser.Math.PI2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), c = this._cr * this.scale.x, d = this._sr * this.scale.x, e = -this._sr * this.scale.y, f = this._cr * this.scale.y, g = this.position.x, h = this.position.y, (this.pivot.x || this.pivot.y) && (g -= this.pivot.x * c + this.pivot.y * e, h -= this.pivot.x * d + this.pivot.y * f), j.a = c * i.a + d * i.c, j.b = c * i.b + d * i.d, j.c = e * i.a + f * i.c, j.d = e * i.b + f * i.d, j.tx = g * i.a + h * i.c + i.tx, j.ty = g * i.b + h * i.d + i.ty) : (c = this.scale.x, d = 0, e = 0, f = this.scale.y, g = this.position.x - this.pivot.x * c, h = this.position.y - this.pivot.y * f, j.a = c * i.a, j.b = c * i.b, j.c = f * i.c, j.d = f * i.d, j.tx = g * i.a + h * i.c + i.tx, j.ty = g * i.b + h * i.d + i.ty), c = j.a, d = j.b, e = j.c, f = j.d;
            var k = c * f - d * e;
            if (c || d) {
                var l = Math.sqrt(c * c + d * d);
                this.worldRotation = d > 0 ? Math.acos(c / l) : -Math.acos(c / l), this.worldScale.x = l, this.worldScale.y = k / l;
            } else if (e || f) {
                var m = Math.sqrt(e * e + f * f);
                this.worldRotation = Phaser.Math.HALF_PI - (f > 0 ? Math.acos(-e / m) : -Math.acos(e / m)), this.worldScale.x = k / m, this.worldScale.y = m;
            } else this.worldScale.x = 0, this.worldScale.y = 0;
            return this.worldAlpha = this.alpha * b.worldAlpha, this.worldPosition.x = j.tx, this.worldPosition.y = j.ty, this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, j, i), this;
        },
        preUpdate: function() {},
        generateTexture: function(a, b, c) {
            var e = this.getLocalBounds(), f = new Phaser.RenderTexture(this.game, 0 | e.width, 0 | e.height, c, b, a);
            return d44.DisplayObject._tempMatrix.tx = -e.x, d44.DisplayObject._tempMatrix.ty = -e.y, f.render(this, d44.DisplayObject._tempMatrix), f;
        },
        updateCache: function() {
            return this._generateCachedSprite(), this;
        },
        toGlobal: function(a) {
            return this.updateTransform(), this.worldTransform.apply(a);
        },
        toLocal: function(a, b) {
            return b && (a = b.toGlobal(a)), this.updateTransform(), this.worldTransform.applyInverse(a);
        },
        _renderCachedSprite: function(a) {
            this._cachedSprite.worldAlpha = this.worldAlpha, a.gl ? d44.Sprite.prototype._renderWebGL.call(this._cachedSprite, a) : d44.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
        },
        _generateCachedSprite: function() {
            this._cacheAsBitmap = !1;
            var a = this.getLocalBounds();
            if (a.width = Math.max(1, Math.ceil(a.width)), a.height = Math.max(1, Math.ceil(a.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(a.width, a.height);
            else {
                var b = 0;
                this.texture && this.texture.baseTexture && d44._enableMultiTextureToggle && (b = this.texture.baseTexture.textureIndex);
                var c = new Phaser.RenderTexture(this.game, a.width, a.height, void 0, void 0, void 0, void 0, b);
                this._cachedSprite = new d44.Sprite(c), this._cachedSprite.worldTransform = this.worldTransform;
            }
            var e = this._filters;
            this._filters = null, this._cachedSprite.filters = e, d44.DisplayObject._tempMatrix.tx = -a.x, d44.DisplayObject._tempMatrix.ty = -a.y, this._cachedSprite.texture.render(this, d44.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -a.x / a.width, this._cachedSprite.anchor.y = -a.y / a.height, this._filters = e, this._cacheAsBitmap = !0;
        },
        _destroyCachedSprite: function() {
            this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null);
        }
    }, d44.DisplayObject.prototype.displayObjectUpdateTransform = d44.DisplayObject.prototype.updateTransform, Object.defineProperties(d44.DisplayObject.prototype, {
        x: {
            get: function() {
                return this.position.x;
            },
            set: function(a) {
                this.position.x = a;
            }
        },
        y: {
            get: function() {
                return this.position.y;
            },
            set: function(a) {
                this.position.y = a;
            }
        },
        worldVisible: {
            get: function() {
                if (this.visible) {
                    var a = this.parent;
                    if (!a) return this.visible;
                    do {
                        if (!a.visible) return !1;
                        a = a.parent;
                    }while (a)
                    return !0;
                }
                return !1;
            }
        },
        mask: {
            get: function() {
                return this._mask;
            },
            set: function(a) {
                this._mask && (this._mask.isMask = !1), this._mask = a, a && (this._mask.isMask = !0);
            }
        },
        filters: {
            get: function() {
                return this._filters;
            },
            set: function(a) {
                if (Array.isArray(a)) {
                    for(var b = [], c = 0; c < a.length; c++)for(var e = a[c].passes, f = 0; f < e.length; f++)b.push(e[f]);
                    this._filterBlock = {
                        target: this,
                        filterPasses: b
                    };
                }
                this._filters = a, this.blendMode && this.blendMode === d44.blendModes.MULTIPLY && (this.blendMode = d44.blendModes.NORMAL);
            }
        },
        cacheAsBitmap: {
            get: function() {
                return this._cacheAsBitmap;
            },
            set: function(a) {
                this._cacheAsBitmap !== a && (a ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = a);
            }
        }
    }), d44.DisplayObjectContainer = function() {
        d44.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1;
    }, d44.DisplayObjectContainer.prototype = Object.create(d44.DisplayObject.prototype), d44.DisplayObjectContainer.prototype.constructor = d44.DisplayObjectContainer, d44.DisplayObjectContainer.prototype.addChild = function(a) {
        return this.addChildAt(a, this.children.length);
    }, d44.DisplayObjectContainer.prototype.addChildAt = function(a, b) {
        if (b >= 0 && b <= this.children.length) return a.parent && a.parent.removeChild(a), a.parent = this, this.children.splice(b, 0, a), a;
        throw new Error(a + "addChildAt: The index " + b + " supplied is out of bounds " + this.children.length);
    }, d44.DisplayObjectContainer.prototype.swapChildren = function(a, b) {
        if (a !== b) {
            var c = this.getChildIndex(a), d = this.getChildIndex(b);
            if (c < 0 || d < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[c] = b, this.children[d] = a;
        }
    }, d44.DisplayObjectContainer.prototype.getChildIndex = function(a) {
        var b = this.children.indexOf(a);
        if (-1 === b) throw new Error("The supplied DisplayObject must be a child of the caller");
        return b;
    }, d44.DisplayObjectContainer.prototype.setChildIndex = function(a, b) {
        if (b < 0 || b >= this.children.length) throw new Error("The supplied index is out of bounds");
        var c = this.getChildIndex(a);
        this.children.splice(c, 1), this.children.splice(b, 0, a);
    }, d44.DisplayObjectContainer.prototype.getChildAt = function(a) {
        if (a < 0 || a >= this.children.length) throw new Error("getChildAt: Supplied index " + a + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[a];
    }, d44.DisplayObjectContainer.prototype.removeChild = function(a) {
        var b = this.children.indexOf(a);
        if (-1 !== b) return this.removeChildAt(b);
    }, d44.DisplayObjectContainer.prototype.removeChildAt = function(a) {
        var b = this.getChildAt(a);
        return b && (b.parent = void 0, this.children.splice(a, 1)), b;
    }, d44.DisplayObjectContainer.prototype.removeChildren = function(a, b) {
        void 0 === a && (a = 0), void 0 === b && (b = this.children.length);
        var c = b - a;
        if (c > 0 && c <= b) {
            for(var d = this.children.splice(a, c), e = 0; e < d.length; e++)d[e].parent = void 0;
            return d;
        }
        if (0 === c && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range");
    }, d44.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) for(var a = 0; a < this.children.length; a++)this.children[a].updateTransform();
    }, d44.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = d44.DisplayObjectContainer.prototype.updateTransform, d44.DisplayObjectContainer.prototype.getBounds = function(a) {
        var b = a && a instanceof d44.DisplayObject, c = !0;
        b ? c = a instanceof d44.DisplayObjectContainer && a.contains(this) : a = this;
        var e;
        if (b) {
            var f = a.worldTransform;
            for(a.worldTransform = d44.identityMatrix, e = 0; e < a.children.length; e++)a.children[e].updateTransform();
        }
        var g, h, i, j = 1 / 0, k = 1 / 0, l = -1 / 0, m = -1 / 0, n = !1;
        for(e = 0; e < this.children.length; e++)this.children[e].visible && (n = !0, g = this.children[e].getBounds(), j = j < g.x ? j : g.x, k = k < g.y ? k : g.y, h = g.width + g.x, i = g.height + g.y, l = l > h ? l : h, m = m > i ? m : i);
        var o = this._bounds;
        if (!n) {
            o = new d44.Rectangle;
            var p = o.x, q = o.width + o.x, r = o.y, s = o.height + o.y, t = this.worldTransform, u = t.a, v = t.b, w = t.c, x = t.d, y = t.tx, z = t.ty, A = u * q + w * s + y, B = x * s + v * q + z, C = u * p + w * s + y, D = x * s + v * p + z, E = u * p + w * r + y, F = x * r + v * p + z, G = u * q + w * r + y, H = x * r + v * q + z;
            l = A, m = B, j = A, k = B, j = C < j ? C : j, j = E < j ? E : j, j = G < j ? G : j, k = D < k ? D : k, k = F < k ? F : k, k = H < k ? H : k, l = C > l ? C : l, l = E > l ? E : l, l = G > l ? G : l, m = D > m ? D : m, m = F > m ? F : m, m = H > m ? H : m;
        }
        if (o.x = j, o.y = k, o.width = l - j, o.height = m - k, b) for(a.worldTransform = f, e = 0; e < a.children.length; e++)a.children[e].updateTransform();
        if (!c) {
            var I = a.getBounds();
            o.x -= I.x, o.y -= I.y;
        }
        return o;
    }, d44.DisplayObjectContainer.prototype.getLocalBounds = function() {
        return this.getBounds(this);
    }, d44.DisplayObjectContainer.prototype.contains = function(a) {
        return !!a && (a === this || this.contains(a.parent));
    }, d44.DisplayObjectContainer.prototype._renderWebGL = function(a) {
        if (this.visible && !(this.alpha <= 0)) {
            if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
            var b;
            if (this._mask || this._filters) {
                for(this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), b = 0; b < this.children.length; b++)this.children[b]._renderWebGL(a);
                a.spriteBatch.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), a.spriteBatch.start();
            } else for(b = 0; b < this.children.length; b++)this.children[b]._renderWebGL(a);
        }
    }, d44.DisplayObjectContainer.prototype._renderCanvas = function(a) {
        if (!1 !== this.visible && 0 !== this.alpha) {
            if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
            this._mask && a.maskManager.pushMask(this._mask, a);
            for(var b = 0; b < this.children.length; b++)this.children[b]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a);
        }
    }, Object.defineProperty(d44.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.getLocalBounds().width * this.scale.x;
        },
        set: function(a) {
            var b = this.getLocalBounds().width;
            this.scale.x = 0 !== b ? a / b : 1, this._width = a;
        }
    }), Object.defineProperty(d44.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.getLocalBounds().height * this.scale.y;
        },
        set: function(a) {
            var b = this.getLocalBounds().height;
            this.scale.y = 0 !== b ? a / b : 1, this._height = a;
        }
    }), d44.Sprite = function(a) {
        d44.DisplayObjectContainer.call(this), this.anchor = new d44.Point(d44.Sprite.defaultAnchor.x, d44.Sprite.defaultAnchor.y), this.texture = a || d44.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = d44.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0;
    }, d44.Sprite.defaultAnchor = {
        x: 0,
        y: 0
    }, d44.Sprite.prototype = Object.create(d44.DisplayObjectContainer.prototype), d44.Sprite.prototype.constructor = d44.Sprite, Object.defineProperty(d44.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width;
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width, this._width = a;
        }
    }), Object.defineProperty(d44.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height;
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height, this._height = a;
        }
    }), d44.Sprite.prototype.setTexture = function(a, b) {
        void 0 !== b && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = a, this.texture.valid = !0, this.cachedTint = -1;
    }, d44.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height);
    }, d44.Sprite.prototype.getBounds = function(a) {
        var b = this.texture.frame.width, c = this.texture.frame.height, d = b * (1 - this.anchor.x), e = b * -this.anchor.x, f = c * (1 - this.anchor.y), g = c * -this.anchor.y, h = a || this.worldTransform, i = h.a, j = h.b, k = h.c, l = h.d, m = h.tx, n = h.ty, o = -1 / 0, p = -1 / 0, q = 1 / 0, r = 1 / 0;
        if (0 === j && 0 === k) {
            if (i < 0) {
                i *= -1;
                var s = d;
                d = -e, e = -s;
            }
            if (l < 0) {
                l *= -1;
                var s = f;
                f = -g, g = -s;
            }
            q = i * e + m, o = i * d + m, r = l * g + n, p = l * f + n;
        } else {
            var t = i * e + k * g + m, u = l * g + j * e + n, v = i * d + k * g + m, w = l * g + j * d + n, x = i * d + k * f + m, y = l * f + j * d + n, z = i * e + k * f + m, A = l * f + j * e + n;
            q = t < q ? t : q, q = v < q ? v : q, q = x < q ? x : q, q = z < q ? z : q, r = u < r ? u : r, r = w < r ? w : r, r = y < r ? y : r, r = A < r ? A : r, o = t > o ? t : o, o = v > o ? v : o, o = x > o ? x : o, o = z > o ? z : o, p = u > p ? u : p, p = w > p ? w : p, p = y > p ? y : p, p = A > p ? A : p;
        }
        var B = this._bounds;
        return B.x = q, B.width = o - q, B.y = r, B.height = p - r, this._currentBounds = B, B;
    }, d44.Sprite.prototype.getLocalBounds = function() {
        var a = this.worldTransform;
        this.worldTransform = d44.identityMatrix;
        for(var b = 0; b < this.children.length; b++)this.children[b].updateTransform();
        var c = this.getBounds();
        for(this.worldTransform = a, b = 0; b < this.children.length; b++)this.children[b].updateTransform();
        return c;
    }, d44.Sprite.prototype._renderWebGL = function(a, b) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var c = this.worldTransform;
            if (b && (c = b), this._mask || this._filters) {
                var d = a.spriteBatch;
                this._filters && (d.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (d.stop(), a.maskManager.pushMask(this.mask, a), d.start()), d.render(this);
                for(var e = 0; e < this.children.length; e++)this.children[e]._renderWebGL(a);
                d.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), d.start();
            } else {
                a.spriteBatch.render(this);
                for(var e = 0; e < this.children.length; e++)this.children[e]._renderWebGL(a, c);
            }
        }
    }, d44.Sprite.prototype._renderCanvas = function(a, b) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            var c = this.worldTransform;
            if (b && (c = b), this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, a.context.globalCompositeOperation = d44.blendModesCanvas[a.currentBlendMode]), this._mask && a.maskManager.pushMask(this._mask, a), !this.texture.valid) {
                for(var e = 0; e < this.children.length; e++)this.children[e]._renderCanvas(a);
                return void (this._mask && a.maskManager.popMask(a));
            }
            var f = this.texture.baseTexture.resolution / a.resolution;
            a.context.globalAlpha = this.worldAlpha, a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode && (a.scaleMode = this.texture.baseTexture.scaleMode, a.context[a.smoothProperty] = a.scaleMode === d44.scaleModes.LINEAR);
            var g = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width, h = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height, i = c.tx * a.resolution + a.shakeX, j = c.ty * a.resolution + a.shakeY, k = this.texture.crop.width, l = this.texture.crop.height;
            if (this.texture.rotated) {
                var m = c.a, n = c.b, o = c.c, p = c.d, q = k;
                i = c.c * l + i, j = c.d * l + j, c.a = 0.00000000000000006123233995736766 * m - o, c.b = 0.00000000000000006123233995736766 * n - p, c.c = m + 0.00000000000000006123233995736766 * o, c.d = n + 0.00000000000000006123233995736766 * p, k = l, l = q;
            }
            if (a.roundPixels ? (a.context.setTransform(c.a, c.b, c.c, c.d, 0 | i, 0 | j), g |= 0, h |= 0) : a.context.setTransform(c.a, c.b, c.c, c.d, i, j), g /= f, h /= f, 16777215 !== this.tint) (this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = d44.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), a.context.drawImage(this.tintedTexture, 0, 0, k, l, g, h, k / f, l / f);
            else {
                var r = this.texture.crop.x, s = this.texture.crop.y;
                k = Math.floor(k), l = Math.floor(l), a.context.drawImage(this.texture.baseTexture.source, r, s, k, l, g, h, k / f, l / f);
            }
            for(var e = 0; e < this.children.length; e++)this.children[e]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a);
        }
    }, d44.initDefaultShaders = function() {}, d44.CompileVertexShader = function(a, b) {
        return d44._CompileShader(a, b, a.VERTEX_SHADER);
    }, d44.CompileFragmentShader = function(a, b) {
        return d44._CompileShader(a, b, a.FRAGMENT_SHADER);
    }, d44._CompileShader = function(a, b, c) {
        var d = b;
        Array.isArray(b) && (d = b.join("\n"));
        var e = a.createShader(c);
        return a.shaderSource(e, d), a.compileShader(e), a.getShaderParameter(e, a.COMPILE_STATUS) ? e : (window.console.log(a.getShaderInfoLog(e)), null);
    }, d44.compileProgram = function(a, b, c) {
        var e = d44.CompileFragmentShader(a, c), f = d44.CompileVertexShader(a, b), g = a.createProgram();
        return a.attachShader(g, f), a.attachShader(g, e), a.linkProgram(g), a.getProgramParameter(g, a.LINK_STATUS) || (window.console.log(a.getProgramInfoLog(g)), window.console.log("Could not initialise shaders")), g;
    }, d44.PixiShader = function(a) {
        this._UID = Phaser._UID++, this.gl = a, this.program = null, this.fragmentSrc = null, this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init();
    }, d44.PixiShader.prototype.constructor = d44.PixiShader, d44.PixiShader.prototype.initMultitexShader = function() {
        var a = this.gl;
        this.MAX_TEXTURES = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
        for(var b = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", c = 1; c < this.MAX_TEXTURES; ++c)b += "\tif (vTextureIndex == " + c + ".0) {gl_FragColor = texture2D(uSamplerArray[" + c + "], vTextureCoord) * vColor;return;}\n";
        this.fragmentSrc = [
            "// PixiShader Fragment Shader.",
            "precision lowp float;",
            "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }",
            "varying vec2 vTextureCoord;",
            "varying vec4 vColor;",
            "varying float vTextureIndex;",
            "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];",
            "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);",
            "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);",
            "void main(void) {",
            b,
            "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}",
            "   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}",
            "}"
        ];
        var e = d44.compileProgram(a, this.vertexSrc || d44.PixiShader.defaultVertexSrc, this.fragmentSrc);
        a.useProgram(e), this.uSamplerArray = a.getUniformLocation(e, "uSamplerArray[0]"), this.projectionVector = a.getUniformLocation(e, "projectionVector"), this.offsetVector = a.getUniformLocation(e, "offsetVector"), this.dimensions = a.getUniformLocation(e, "dimensions"), this.aVertexPosition = a.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = a.getAttribLocation(e, "aColor"), this.aTextureIndex = a.getAttribLocation(e, "aTextureIndex");
        var f = [], g = a.createTexture();
        a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, g), a.texImage2D(a.TEXTURE_2D, 0, a.RGB, 1, 1, 0, a.RGB, a.UNSIGNED_BYTE, null);
        for(var h = 0; h < this.MAX_TEXTURES; ++h)a.activeTexture(a.TEXTURE0 + h), a.bindTexture(a.TEXTURE_2D, g), f.push(h);
        a.activeTexture(a.TEXTURE0), a.uniform1iv(this.uSamplerArray, f), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [
            this.aVertexPosition,
            this.aTextureCoord,
            this.colorAttribute,
            this.aTextureIndex
        ];
        for(var i in this.uniforms)this.uniforms[i].uniformLocation = a.getUniformLocation(e, i);
        this.initUniforms(), this.program = e;
    }, d44.PixiShader.prototype.initDefaultShader = function() {
        null === this.fragmentSrc && (this.fragmentSrc = [
            "precision lowp float;",
            "varying vec2 vTextureCoord;",
            "varying vec4 vColor;",
            "varying float vTextureIndex;",
            "uniform sampler2D uSampler;",
            "void main(void) {",
            "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;",
            "}"
        ]);
        var a = this.gl, b = d44.compileProgram(a, this.vertexSrc || d44.PixiShader.defaultVertexSrc, this.fragmentSrc);
        a.useProgram(b), this.uSampler = a.getUniformLocation(b, "uSampler"), this.projectionVector = a.getUniformLocation(b, "projectionVector"), this.offsetVector = a.getUniformLocation(b, "offsetVector"), this.dimensions = a.getUniformLocation(b, "dimensions"), this.aVertexPosition = a.getAttribLocation(b, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(b, "aTextureCoord"), this.colorAttribute = a.getAttribLocation(b, "aColor"), this.aTextureIndex = a.getAttribLocation(b, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [
            this.aVertexPosition,
            this.aTextureCoord,
            this.colorAttribute,
            this.aTextureIndex
        ];
        for(var c in this.uniforms)this.uniforms[c].uniformLocation = a.getUniformLocation(b, c);
        this.initUniforms(), this.program = b;
    }, d44.PixiShader.prototype.init = function(a) {
        d44._enableMultiTextureToggle && !a ? this.initMultitexShader() : this.initDefaultShader();
    }, d44.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var a, b = this.gl;
        for(var c in this.uniforms){
            a = this.uniforms[c];
            var d = a.type;
            "sampler2D" === d ? (a._init = !1, null !== a.value && this.initSampler2D(a)) : "mat2" === d || "mat3" === d || "mat4" === d ? (a.glMatrix = !0, a.glValueLength = 1, "mat2" === d ? a.glFunc = b.uniformMatrix2fv : "mat3" === d ? a.glFunc = b.uniformMatrix3fv : "mat4" === d && (a.glFunc = b.uniformMatrix4fv)) : (a.glFunc = b["uniform" + d], a.glValueLength = "2f" === d || "2i" === d ? 2 : "3f" === d || "3i" === d ? 3 : "4f" === d || "4i" === d ? 4 : 1);
        }
    }, d44.PixiShader.prototype.initSampler2D = function(a) {
        if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
            var b = this.gl;
            if (b.activeTexture(b.TEXTURE0 + this.textureCount), b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]), a.textureData) {
                var c = a.textureData, d = c.magFilter ? c.magFilter : b.LINEAR, e = c.minFilter ? c.minFilter : b.LINEAR, f = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE, g = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE, h = c.luminance ? b.LUMINANCE : b.RGBA;
                if (c.repeat && (f = b.REPEAT, g = b.REPEAT), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY), c.width) {
                    var i = c.width ? c.width : 512, j = c.height ? c.height : 2, k = c.border ? c.border : 0;
                    b.texImage2D(b.TEXTURE_2D, 0, h, i, j, k, h, b.UNSIGNED_BYTE, null);
                } else b.texImage2D(b.TEXTURE_2D, 0, h, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, d), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, e), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, g);
            }
            b.uniform1i(a.uniformLocation, this.textureCount), a._init = !0, this.textureCount++;
        }
    }, d44.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var a, b = this.gl;
        for(var c in this.uniforms)a = this.uniforms[c], 1 === a.glValueLength ? !0 === a.glMatrix ? a.glFunc.call(b, a.uniformLocation, a.transpose, a.value) : a.glFunc.call(b, a.uniformLocation, a.value) : 2 === a.glValueLength ? a.glFunc.call(b, a.uniformLocation, a.value.x, a.value.y) : 3 === a.glValueLength ? a.glFunc.call(b, a.uniformLocation, a.value.x, a.value.y, a.value.z) : 4 === a.glValueLength ? a.glFunc.call(b, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w) : "sampler2D" === a.type && (a._init ? (b.activeTexture(b["TEXTURE" + this.textureCount]), a.value.baseTexture._dirty[b.id] ? d44.instances[b.id].updateTexture(a.value.baseTexture) : b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]), b.uniform1i(a.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(a));
    }, d44.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, d44.PixiShader.defaultVertexSrc = [
        "// PixiShader Vertex Shader",
        "// With multi-texture rendering",
        "attribute vec2 aVertexPosition;",
        "attribute vec2 aTextureCoord;",
        "attribute vec4 aColor;",
        "attribute float aTextureIndex;",
        "uniform vec2 projectionVector;",
        "uniform vec2 offsetVector;",
        "varying vec2 vTextureCoord;",
        "varying vec4 vColor;",
        "varying float vTextureIndex;",
        "const vec2 center = vec2(-1.0, 1.0);",
        "void main(void) {",
        "   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);",
        "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);",
        "   vTextureCoord = aTextureCoord;",
        "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);",
        "   vTextureIndex = aTextureIndex;",
        "}"
    ], d44.PixiFastShader = function(a) {
        if (this._UID = Phaser._UID++, this.gl = a, this.program = null, d44._enableMultiTextureToggle) {
            var a = this.gl;
            this.MAX_TEXTURES = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
            for(var b = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", c = 1; c < this.MAX_TEXTURES; ++c)b += "\tif (vTextureIndex == " + c + ".0) { gl_FragColor = texture2D(uSamplerArray[" + c + "], vTextureCoord) * vColor;return;}\n";
            this.fragmentSrc = [
                "// PixiFastShader Fragment Shader.",
                "precision lowp float;",
                "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }",
                "varying vec2 vTextureCoord;",
                "varying float vColor;",
                "varying float vTextureIndex;",
                "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];",
                "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);",
                "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);",
                "void main(void) {",
                b,
                "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}",
                "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}",
                "}"
            ];
        } else this.fragmentSrc = [
            "// PixiFastShader Fragment Shader.",
            "precision lowp float;",
            "varying vec2 vTextureCoord;",
            "varying float vColor;",
            "varying float vTextureIndex;",
            "uniform sampler2D uSampler;",
            "void main(void) {",
            "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;",
            "}"
        ];
        this.vertexSrc = [
            "// PixiFastShader Vertex Shader.",
            "attribute vec2 aVertexPosition;",
            "attribute vec2 aPositionCoord;",
            "attribute vec2 aScale;",
            "attribute float aRotation;",
            "attribute vec2 aTextureCoord;",
            "attribute float aColor;",
            "attribute float aTextureIndex;",
            "uniform vec2 projectionVector;",
            "uniform vec2 offsetVector;",
            "uniform mat3 uMatrix;",
            "varying vec2 vTextureCoord;",
            "varying float vColor;",
            "varying float vTextureIndex;",
            "const vec2 center = vec2(-1.0, 1.0);",
            "void main(void) {",
            "   vec2 v;",
            "   vec2 sv = aVertexPosition * aScale;",
            "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);",
            "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);",
            "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;",
            "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);",
            "   vTextureCoord = aTextureCoord;",
            "   vTextureIndex = aTextureIndex;",
            "   vColor = aColor;",
            "}"
        ], this.textureCount = 0, this.init();
    }, d44.PixiFastShader.prototype.constructor = d44.PixiFastShader, d44.PixiFastShader.prototype.init = function() {
        var a = this.gl, b = d44.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        if (a.useProgram(b), this.uSampler = d44._enableMultiTextureToggle ? a.getUniformLocation(b, "uSamplerArray[0]") : a.getUniformLocation(b, "uSampler"), d44._enableMultiTextureToggle) {
            var c = [], e = a.createTexture();
            a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e), a.texImage2D(a.TEXTURE_2D, 0, a.RGB, 1, 1, 0, a.RGB, a.UNSIGNED_BYTE, null);
            for(var f = 0; f < this.MAX_TEXTURES; ++f)a.activeTexture(a.TEXTURE0 + f), a.bindTexture(a.TEXTURE_2D, e), c.push(f);
            a.activeTexture(a.TEXTURE0), a.uniform1iv(this.uSampler, c);
        }
        this.projectionVector = a.getUniformLocation(b, "projectionVector"), this.offsetVector = a.getUniformLocation(b, "offsetVector"), this.dimensions = a.getUniformLocation(b, "dimensions"), this.uMatrix = a.getUniformLocation(b, "uMatrix"), this.aVertexPosition = a.getAttribLocation(b, "aVertexPosition"), this.aPositionCoord = a.getAttribLocation(b, "aPositionCoord"), this.aScale = a.getAttribLocation(b, "aScale"), this.aRotation = a.getAttribLocation(b, "aRotation"), this.aTextureCoord = a.getAttribLocation(b, "aTextureCoord"), this.colorAttribute = a.getAttribLocation(b, "aColor"), this.aTextureIndex = a.getAttribLocation(b, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [
            this.aVertexPosition,
            this.aPositionCoord,
            this.aScale,
            this.aRotation,
            this.aTextureCoord,
            this.colorAttribute,
            this.aTextureIndex
        ], this.program = b;
    }, d44.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, d44.StripShader = function(a) {
        if (this._UID = Phaser._UID++, this.gl = a, this.program = null, d44._enableMultiTextureToggle) {
            var a = this.gl;
            this.MAX_TEXTURES = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
            for(var b = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\n", c = 1; c < this.MAX_TEXTURES; ++c)b += "\tif (vTextureIndex == " + c + ".0) { gl_FragColor = texture2D(uSamplerArray[" + c + "], vTextureCoord) ;return;}\n";
            this.fragmentSrc = [
                "//StripShader Fragment Shader.",
                "precision mediump float;",
                "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }",
                "varying vec2 vTextureCoord;",
                "varying float vTextureIndex;",
                "uniform float alpha;",
                "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];",
                "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);",
                "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);",
                "void main(void) {",
                b,
                "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}",
                "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}",
                "}"
            ];
        } else this.fragmentSrc = [
            "//StripShader Fragment Shader.",
            "precision mediump float;",
            "varying vec2 vTextureCoord;",
            "varying float vTextureIndex;",
            "uniform float alpha;",
            "uniform sampler2D uSampler;",
            "void main(void) {",
            "   gl_FragColor = texture2D(uSampler, vTextureCoord);",
            "}"
        ];
        this.vertexSrc = [
            "//StripShader Vertex Shader.",
            "attribute vec2 aVertexPosition;",
            "attribute vec2 aTextureCoord;",
            "attribute float aTextureIndex;",
            "uniform mat3 translationMatrix;",
            "uniform vec2 projectionVector;",
            "uniform vec2 offsetVector;",
            "varying vec2 vTextureCoord;",
            "varying float vTextureIndex;",
            "void main(void) {",
            "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);",
            "   v -= offsetVector.xyx;",
            "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);",
            "   vTextureCoord = aTextureCoord;",
            "   vTextureIndex = aTextureIndex;",
            "}"
        ], this.init();
    }, d44.StripShader.prototype.constructor = d44.StripShader, d44.StripShader.prototype.init = function() {
        var a = this.gl, b = d44.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        if (a.useProgram(b), this.uSampler = d44._enableMultiTextureToggle ? a.getUniformLocation(b, "uSamplerArray[0]") : a.getUniformLocation(b, "uSampler"), d44._enableMultiTextureToggle) {
            var c = [], e = a.createTexture();
            a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e), a.texImage2D(a.TEXTURE_2D, 0, a.RGB, 1, 1, 0, a.RGB, a.UNSIGNED_BYTE, null);
            for(var f = 0; f < this.MAX_TEXTURES; ++f)a.activeTexture(a.TEXTURE0 + f), a.bindTexture(a.TEXTURE_2D, e), c.push(f);
            a.activeTexture(a.TEXTURE0), a.uniform1iv(this.uSampler, c);
        }
        this.projectionVector = a.getUniformLocation(b, "projectionVector"), this.offsetVector = a.getUniformLocation(b, "offsetVector"), this.colorAttribute = a.getAttribLocation(b, "aColor"), this.aTextureIndex = a.getAttribLocation(b, "aTextureIndex"), this.aVertexPosition = a.getAttribLocation(b, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(b, "aTextureCoord"), this.attributes = [
            this.aVertexPosition,
            this.aTextureCoord,
            this.aTextureIndex
        ], this.translationMatrix = a.getUniformLocation(b, "translationMatrix"), this.alpha = a.getUniformLocation(b, "alpha"), this.program = b;
    }, d44.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null;
    }, d44.PrimitiveShader = function(a) {
        this._UID = Phaser._UID++, this.gl = a, this.program = null, this.fragmentSrc = [
            "precision mediump float;",
            "varying vec4 vColor;",
            "void main(void) {",
            "   gl_FragColor = vColor;",
            "}"
        ], this.vertexSrc = [
            "attribute vec2 aVertexPosition;",
            "attribute vec4 aColor;",
            "uniform mat3 translationMatrix;",
            "uniform vec2 projectionVector;",
            "uniform vec2 offsetVector;",
            "uniform float alpha;",
            "uniform float flipY;",
            "uniform vec3 tint;",
            "varying vec4 vColor;",
            "void main(void) {",
            "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);",
            "   v -= offsetVector.xyx;",
            "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);",
            "   vColor = aColor * vec4(tint * alpha, alpha);",
            "}"
        ], this.init();
    }, d44.PrimitiveShader.prototype.constructor = d44.PrimitiveShader, d44.PrimitiveShader.prototype.init = function() {
        var a = this.gl, b = d44.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(b), this.projectionVector = a.getUniformLocation(b, "projectionVector"), this.offsetVector = a.getUniformLocation(b, "offsetVector"), this.tintColor = a.getUniformLocation(b, "tint"), this.flipY = a.getUniformLocation(b, "flipY"), this.aVertexPosition = a.getAttribLocation(b, "aVertexPosition"), this.colorAttribute = a.getAttribLocation(b, "aColor"), this.attributes = [
            this.aVertexPosition,
            this.colorAttribute
        ], this.translationMatrix = a.getUniformLocation(b, "translationMatrix"), this.alpha = a.getUniformLocation(b, "alpha"), this.program = b;
    }, d44.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, d44.ComplexPrimitiveShader = function(a) {
        this._UID = Phaser._UID++, this.gl = a, this.program = null, this.fragmentSrc = [
            "precision mediump float;",
            "varying vec4 vColor;",
            "void main(void) {",
            "   gl_FragColor = vColor;",
            "}"
        ], this.vertexSrc = [
            "attribute vec2 aVertexPosition;",
            "uniform mat3 translationMatrix;",
            "uniform vec2 projectionVector;",
            "uniform vec2 offsetVector;",
            "uniform vec3 tint;",
            "uniform float alpha;",
            "uniform vec3 color;",
            "uniform float flipY;",
            "varying vec4 vColor;",
            "void main(void) {",
            "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);",
            "   v -= offsetVector.xyx;",
            "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);",
            "   vColor = vec4(color * alpha * tint, alpha);",
            "}"
        ], this.init();
    }, d44.ComplexPrimitiveShader.prototype.constructor = d44.ComplexPrimitiveShader, d44.ComplexPrimitiveShader.prototype.init = function() {
        var a = this.gl, b = d44.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(b), this.projectionVector = a.getUniformLocation(b, "projectionVector"), this.offsetVector = a.getUniformLocation(b, "offsetVector"), this.tintColor = a.getUniformLocation(b, "tint"), this.color = a.getUniformLocation(b, "color"), this.flipY = a.getUniformLocation(b, "flipY"), this.aVertexPosition = a.getAttribLocation(b, "aVertexPosition"), this.attributes = [
            this.aVertexPosition,
            this.colorAttribute
        ], this.translationMatrix = a.getUniformLocation(b, "translationMatrix"), this.alpha = a.getUniformLocation(b, "alpha"), this.program = b;
    }, d44.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null;
    }, d44.glContexts = [], d44.instances = [], d44._enableMultiTextureToggle = !1, d44.WebGLRenderer = function(a) {
        this.game = a, d44.defaultRenderer || (d44.defaultRenderer = this), this.extensions = {}, this.type = Phaser.WEBGL, this.resolution = a.resolution, this.transparent = a.transparent, this.autoResize = !1, this.preserveDrawingBuffer = a.preserveDrawingBuffer, this.clearBeforeRender = a.clearBeforeRender, this.width = a.width, this.height = a.height, this.view = a.canvas, this._contextOptions = {
            alpha: this.transparent,
            antialias: a.antialias,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: this.preserveDrawingBuffer
        }, this.projection = new d44.Point, this.offset = new d44.Point, this.shaderManager = new d44.WebGLShaderManager, this.spriteBatch = new d44.WebGLSpriteBatch(a), this.maskManager = new d44.WebGLMaskManager, this.filterManager = new d44.WebGLFilterManager, this.stencilManager = new d44.WebGLStencilManager, this.blendModeManager = new d44.WebGLBlendModeManager, this.renderSession = {}, this.currentBatchedTextures = [], this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.flushCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.renderSession.maxTextureAvailableSpace = null, this.initContext(), this.mapBlendModes();
    }, d44.WebGLRenderer.prototype.constructor = d44.WebGLRenderer, d44.WebGLRenderer.prototype.initContext = function() {
        var a = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = a, !a) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.maxTextures = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = this.gl.getParameter(a.MAX_TEXTURE_SIZE), this.glContextId = a.id = d44.WebGLRenderer.glContextId++, d44.glContexts[this.glContextId] = a, d44.instances[this.glContextId] = this, a.disable(a.DEPTH_TEST), a.disable(a.CULL_FACE), a.enable(a.BLEND), this.shaderManager.setContext(a), this.spriteBatch.setContext(a), this.maskManager.setContext(a), this.filterManager.setContext(a), this.blendModeManager.setContext(a), this.stencilManager.setContext(a), this.renderSession.gl = this.gl, this.resize(this.width, this.height), this.extensions.compression = {};
        var b = a.getExtension("WEBGL_compressed_texture_etc1") || a.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"), c = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), e = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        b && (this.extensions.compression.ETC1 = b), c && (this.extensions.compression.PVRTC = c), e && (this.extensions.compression.S3TC = e);
    }, d44.WebGLRenderer.prototype.setTexturePriority = function(a64) {
        if (!d44._enableMultiTextureToggle) return void console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.");
        for(var b = function(a) {
            return --a, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, a |= a >> 16, ++a;
        }, c = this.gl, e = c.getParameter(c.MAX_TEXTURE_IMAGE_UNITS), f = c.getParameter(c.MAX_TEXTURE_SIZE), g = this.game.cache._cache.image, h = null, i = 0; i < this.currentBatchedTextures.length; i++)h = this.currentBatchedTextures[i], h in g ? g[h].base.textureIndex = 0 : console.warn('setTexturePriority: There is no image "%s" in the image cache.', h);
        var j = f - b(Math.max(this.width, this.height));
        this.currentBatchedTextures.length = 0;
        for(var k = 0; k < a64.length; ++k)if ((h = a64[k]) in g) {
            var l = g[h].base;
            j -= b(Math.max(l.width, l.height)), j <= 0 ? (l.textureIndex = 0, console.warn('setTexturePriority: Image "%s" was given textureIndex=0 because there is no available texture space (%s).', h, j)) : l.textureIndex = 1 + k % (e - 1), this.currentBatchedTextures.push(h);
        } else console.warn('setTexturePriority: There is no image "%s" in the image cache.', h);
        return this.renderSession.maxTextureAvailableSpace = j, this.currentBatchedTextures;
    }, d44.WebGLRenderer.prototype.render = function(a) {
        if (!this.contextLost) {
            var b = this.gl;
            b.viewport(0, 0, this.width, this.height), b.bindFramebuffer(b.FRAMEBUFFER, null), this.game.clearBeforeRender && (b.clearColor(a._bgColor.r, a._bgColor.g, a._bgColor.b, a._bgColor.a), b.clear(b.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(a, this.projection);
        }
    }, d44.WebGLRenderer.prototype.renderDisplayObject = function(a, b, c, e) {
        this.renderSession.blendModeManager.setBlendMode(d44.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flushCount = 0, this.renderSession.flipY = c ? -1 : 1, this.renderSession.projection = b, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, c), a._renderWebGL(this.renderSession, e), this.spriteBatch.end();
    }, d44.WebGLRenderer.prototype.resize = function(a, b) {
        this.width = a * this.resolution, this.height = b * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution;
    }, d44.WebGLRenderer.prototype.updateCompressedTexture = function(a) {
        if (!a.hasLoaded) return !1;
        var b = this.gl, c = a.source;
        return a._glTextures[b.id] || (a._glTextures[b.id] = b.createTexture()), b.activeTexture(b.TEXTURE0 + a.textureIndex), b.bindTexture(b.TEXTURE_2D, a._glTextures[b.id]), b.compressedTexImage2D(b.TEXTURE_2D, 0, c.glExtensionFormat, c.width, c.height, 0, c.textureData), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, a.scaleMode === d44.scaleModes.LINEAR ? b.LINEAR : b.NEAREST), a.mipmap && Phaser.Math.isPowerOfTwo(a.width, a.height) ? (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, a.scaleMode === d44.scaleModes.LINEAR ? b.LINEAR_MIPMAP_LINEAR : b.NEAREST_MIPMAP_NEAREST), b.generateMipmap(b.TEXTURE_2D)) : b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, a.scaleMode === d44.scaleModes.LINEAR ? b.LINEAR : b.NEAREST), a._powerOf2 ? (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.REPEAT), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.REPEAT)) : (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE)), a._dirty[b.id] = !1, !0;
    }, d44.WebGLRenderer.prototype.updateTexture = function(a) {
        if (!a.hasLoaded) return !1;
        if (a.source.compressionAlgorithm) return this.updateCompressedTexture(a);
        var b = this.gl;
        return a._glTextures[b.id] || (a._glTextures[b.id] = b.createTexture()), b.activeTexture(b.TEXTURE0 + a.textureIndex), b.bindTexture(b.TEXTURE_2D, a._glTextures[b.id]), b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultipliedAlpha), b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, a.source), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, a.scaleMode === d44.scaleModes.LINEAR ? b.LINEAR : b.NEAREST), a.mipmap && Phaser.Math.isPowerOfTwo(a.width, a.height) ? (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, a.scaleMode === d44.scaleModes.LINEAR ? b.LINEAR_MIPMAP_LINEAR : b.NEAREST_MIPMAP_NEAREST), b.generateMipmap(b.TEXTURE_2D)) : b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, a.scaleMode === d44.scaleModes.LINEAR ? b.LINEAR : b.NEAREST), a._powerOf2 ? (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.REPEAT), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.REPEAT)) : (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE)), a._dirty[b.id] = !1, !0;
    }, d44.WebGLRenderer.prototype.destroy = function() {
        d44.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, Phaser.CanvasPool.remove(this), d44.instances[this.glContextId] = null, d44.WebGLRenderer.glContextId--;
    }, d44.WebGLRenderer.prototype.mapBlendModes = function() {
        var a = this.gl;
        if (!d44.blendModesWebGL) {
            var b = [], c = d44.blendModes;
            b[c.NORMAL] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.ADD] = [
                a.SRC_ALPHA,
                a.DST_ALPHA
            ], b[c.MULTIPLY] = [
                a.DST_COLOR,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.SCREEN] = [
                a.SRC_ALPHA,
                a.ONE
            ], b[c.OVERLAY] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.DARKEN] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.LIGHTEN] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.COLOR_DODGE] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.COLOR_BURN] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.HARD_LIGHT] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.SOFT_LIGHT] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.DIFFERENCE] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.EXCLUSION] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.HUE] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.SATURATION] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.COLOR] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], b[c.LUMINOSITY] = [
                a.ONE,
                a.ONE_MINUS_SRC_ALPHA
            ], d44.blendModesWebGL = b;
        }
    }, d44.WebGLRenderer.prototype.getMaxTextureUnit = function() {
        var a = this.gl;
        return a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
    }, d44.enableMultiTexture = function() {
        d44._enableMultiTextureToggle = !0;
    }, d44.WebGLRenderer.glContextId = 0, d44.WebGLRenderer.textureArray = [], d44.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999;
    }, d44.WebGLBlendModeManager.prototype.constructor = d44.WebGLBlendModeManager, d44.WebGLBlendModeManager.prototype.setContext = function(a) {
        this.gl = a;
    }, d44.WebGLBlendModeManager.prototype.setBlendMode = function(a) {
        if (this.currentBlendMode === a) return !1;
        this.currentBlendMode = a;
        var b = d44.blendModesWebGL[this.currentBlendMode];
        return b && this.gl.blendFunc(b[0], b[1]), !0;
    }, d44.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null;
    }, d44.WebGLMaskManager = function() {}, d44.WebGLMaskManager.prototype.constructor = d44.WebGLMaskManager, d44.WebGLMaskManager.prototype.setContext = function(a) {
        this.gl = a;
    }, d44.WebGLMaskManager.prototype.pushMask = function(a, b) {
        var c = b.gl;
        a.dirty && d44.WebGLGraphics.updateGraphics(a, c), void 0 !== a._webGL[c.id] && void 0 !== a._webGL[c.id].data && 0 !== a._webGL[c.id].data.length && b.stencilManager.pushStencil(a, a._webGL[c.id].data[0], b);
    }, d44.WebGLMaskManager.prototype.popMask = function(a, b) {
        var c = this.gl;
        void 0 !== a._webGL[c.id] && void 0 !== a._webGL[c.id].data && 0 !== a._webGL[c.id].data.length && b.stencilManager.popStencil(a, a._webGL[c.id].data[0], b);
    }, d44.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null;
    }, d44.WebGLStencilManager = function() {
        this.stencilStack = [], this.reverse = !0, this.count = 0;
    }, d44.WebGLStencilManager.prototype.setContext = function(a) {
        this.gl = a;
    }, d44.WebGLStencilManager.prototype.pushStencil = function(a, b, c) {
        var d = this.gl;
        this.bindGraphics(a, b, c), 0 === this.stencilStack.length && (d.enable(d.STENCIL_TEST), d.clear(d.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(b);
        var e = this.count;
        d.colorMask(!1, !1, !1, !1), d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), 1 === b.mode ? (d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), this.reverse ? (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, e, 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), this.reverse ? d.stencilFunc(d.EQUAL, 255 - (e + 1), 255) : d.stencilFunc(d.EQUAL, e + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (d.stencilFunc(d.EQUAL, e, 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)), d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e + 1, 255) : d.stencilFunc(d.EQUAL, 255 - (e + 1), 255)), d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP), this.count++;
    }, d44.WebGLStencilManager.prototype.bindGraphics = function(a, b, c) {
        this._currentGraphics = a;
        var d, e = this.gl, f = c.projection, g = c.offset;
        1 === b.mode ? (d = c.shaderManager.complexPrimitiveShader, c.shaderManager.setShader(d), e.uniform1f(d.flipY, c.flipY), e.uniformMatrix3fv(d.translationMatrix, !1, a.worldTransform.toArray(!0)), e.uniform2f(d.projectionVector, f.x, -f.y), e.uniform2f(d.offsetVector, -g.x, -g.y), e.uniform3fv(d.tintColor, Phaser.Color.hexToRGBArray(a.tint)), e.uniform3fv(d.color, b.color), e.uniform1f(d.alpha, a.worldAlpha * b.alpha), e.bindBuffer(e.ARRAY_BUFFER, b.buffer), e.vertexAttribPointer(d.aVertexPosition, 2, e.FLOAT, !1, 8, 0), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, b.indexBuffer)) : (d = c.shaderManager.primitiveShader, c.shaderManager.setShader(d), e.uniformMatrix3fv(d.translationMatrix, !1, a.worldTransform.toArray(!0)), e.uniform1f(d.flipY, c.flipY), e.uniform2f(d.projectionVector, f.x, -f.y), e.uniform2f(d.offsetVector, -g.x, -g.y), e.uniform3fv(d.tintColor, Phaser.Color.hexToRGBArray(a.tint)), e.uniform1f(d.alpha, a.worldAlpha), e.bindBuffer(e.ARRAY_BUFFER, b.buffer), e.vertexAttribPointer(d.aVertexPosition, 2, e.FLOAT, !1, 24, 0), e.vertexAttribPointer(d.colorAttribute, 4, e.FLOAT, !1, 24, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, b.indexBuffer));
    }, d44.WebGLStencilManager.prototype.popStencil = function(a, b, c) {
        var d = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) d.disable(d.STENCIL_TEST);
        else {
            var e = this.count;
            this.bindGraphics(a, b, c), d.colorMask(!1, !1, !1, !1), 1 === b.mode ? (this.reverse = !this.reverse, this.reverse ? (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, e + 1, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)) : (this.reverse ? (d.stencilFunc(d.EQUAL, e + 1, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)), d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP);
        }
    }, d44.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null, this.gl = null;
    }, d44.WebGLShaderManager = function() {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for(var a = 0; a < this.maxAttibs; a++)this.attribState[a] = !1;
        this.stack = [];
    }, d44.WebGLShaderManager.prototype.constructor = d44.WebGLShaderManager, d44.WebGLShaderManager.prototype.setContext = function(a) {
        this.gl = a, this.primitiveShader = new d44.PrimitiveShader(a), this.complexPrimitiveShader = new d44.ComplexPrimitiveShader(a), this.defaultShader = new d44.PixiShader(a), this.fastShader = new d44.PixiFastShader(a), this.stripShader = new d44.StripShader(a), this.creatureShader = d44.CreatureShader ? new d44.CreatureShader(a) : null, this.setShader(this.defaultShader);
    }, d44.WebGLShaderManager.prototype.setAttribs = function(a) {
        var b;
        for(b = 0; b < this.tempAttribState.length; b++)this.tempAttribState[b] = !1;
        for(b = 0; b < a.length; b++){
            var c = a[b];
            this.tempAttribState[c] = !0;
        }
        var d = this.gl;
        for(b = 0; b < this.attribState.length; b++)this.attribState[b] !== this.tempAttribState[b] && (this.attribState[b] = this.tempAttribState[b], this.tempAttribState[b] ? d.enableVertexAttribArray(b) : d.disableVertexAttribArray(b));
    }, d44.WebGLShaderManager.prototype.setShader = function(a) {
        return this._currentId !== a._UID && (this._currentId = a._UID, this.currentShader = a, this.gl.useProgram(a.program), this.setAttribs(a.attributes), !0);
    }, d44.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.creatureShader && this.creatureShader.destroy(), this.gl = null;
    }, d44.WebGLSpriteBatch = function(a) {
        this.game = a, this.vertSize = 5, this.size = 2000, this.vertexSize = 24;
        var b = this.vertexSize * this.size * 4, c = 6 * this.size;
        this.vertices = new ArrayBuffer(b), this.positions = new Float32Array(this.vertices), this.colors = new Uint32Array(this.vertices), this.indices = new Uint16Array(c), this.lastIndexCount = 0;
        for(var d = 0, e = 0; d < c; d += 6, e += 4)this.indices[d + 0] = e + 0, this.indices[d + 1] = e + 1, this.indices[d + 2] = e + 2, this.indices[d + 3] = e + 0, this.indices[d + 4] = e + 2, this.indices[d + 5] = e + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = null;
    }, d44.WebGLSpriteBatch.prototype.setContext = function(a) {
        if (this.MAX_TEXTURES = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), this.gl = a, d44._enableMultiTextureToggle) {
            for(var b = "\tif (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", c = 1; c < this.MAX_TEXTURES; ++c)b += "\tif (vTextureIndex == " + c + ".0) {gl_FragColor = texture2D(uSamplerArray[" + c + "], vTextureCoord) * vColor;return;}\n";
            this.defaultShader = new Phaser.Filter(this.game, void 0, [
                "//WebGLSpriteBatch Fragment Shader.",
                "precision lowp float;",
                "varying vec2 vTextureCoord;",
                "varying vec4 vColor;",
                "varying float vTextureIndex;",
                "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];",
                "void main(void) {",
                b,
                "\tgl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;",
                "}"
            ]);
        } else this.defaultShader = new Phaser.Filter(this.game, void 0, [
            "//WebGLSpriteBatch Fragment Shader.",
            "precision lowp float;",
            "varying vec2 vTextureCoord;",
            "varying vec4 vColor;",
            "varying float vTextureIndex;",
            "uniform sampler2D uSampler;",
            "void main(void) {",
            "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;",
            "}"
        ]);
        this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW), this.currentBlendMode = 99999;
        var e = new d44.PixiShader(a);
        e.fragmentSrc = this.defaultShader.fragmentSrc, e.uniforms = {}, e.init(), this.defaultShader.shaders[a.id] = e;
    }, d44.WebGLSpriteBatch.prototype.begin = function(a) {
        this.renderSession = a, this.shader = this.renderSession.shaderManager.defaultShader, this.start();
    }, d44.WebGLSpriteBatch.prototype.end = function() {
        this.flush();
    }, d44.WebGLSpriteBatch.prototype.render = function(a, b) {
        var c = a.texture, e = c.baseTexture, f = this.gl;
        d44.WebGLRenderer.textureArray[e.textureIndex] != e && (this.flush(), f.activeTexture(f.TEXTURE0 + e.textureIndex), f.bindTexture(f.TEXTURE_2D, e._glTextures[f.id]), d44.WebGLRenderer.textureArray[e.textureIndex] = e);
        var g = a.worldTransform;
        b && (g = b), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = c.baseTexture);
        var h = c._uvs;
        if (h) {
            var i, j, k, l, m = a.anchor.x, n = a.anchor.y;
            if (c.trim) {
                var o = c.trim;
                j = o.x - m * o.width, i = j + c.crop.width, l = o.y - n * o.height, k = l + c.crop.height;
            } else i = c.frame.width * (1 - m), j = c.frame.width * -m, k = c.frame.height * (1 - n), l = c.frame.height * -n;
            var p = this.currentBatchSize * this.vertexSize, q = (this.currentBatchSize, c.baseTexture.resolution), r = c.baseTexture.textureIndex, s = g.a / q, t = g.b / q, u = g.c / q, v = g.d / q, w = g.tx, x = g.ty, y = (c.crop.width, c.crop.height);
            if (c.rotated) {
                var z = g.a, A = g.b, B = g.c, C = g.d, D = j, E = i;
                w = g.c * y + w, x = g.d * y + x, s = 0.00000000000000006123233995736766 * z - B, t = 0.00000000000000006123233995736766 * A - C, u = z + 0.00000000000000006123233995736766 * B, v = A + 0.00000000000000006123233995736766 * C, c._updateUvsInverted(), i = k, j = l, k = E, l = D;
            }
            var F = this.colors, G = this.positions, H = a.tint, I = (H >> 16) + (65280 & H) + ((255 & H) << 16) + (255 * a.worldAlpha << 24);
            this.renderSession.roundPixels ? (G[p++] = s * j + u * l + w | 0, G[p++] = v * l + t * j + x | 0, G[p++] = h.x0, G[p++] = h.y0, F[p++] = I, G[p++] = r, G[p++] = s * i + u * l + w | 0, G[p++] = v * l + t * i + x | 0, G[p++] = h.x1, G[p++] = h.y1, F[p++] = I, G[p++] = r, G[p++] = s * i + u * k + w | 0, G[p++] = v * k + t * i + x | 0, G[p++] = h.x2, G[p++] = h.y2, F[p++] = I, G[p++] = r, G[p++] = s * j + u * k + w | 0, G[p++] = v * k + t * j + x | 0, G[p++] = h.x3, G[p++] = h.y3, F[p++] = I, G[p++] = r) : (G[p++] = s * j + u * l + w, G[p++] = v * l + t * j + x, G[p++] = h.x0, G[p++] = h.y0, F[p++] = I, G[p++] = r, G[p++] = s * i + u * l + w, G[p++] = v * l + t * i + x, G[p++] = h.x1, G[p++] = h.y1, F[p++] = I, G[p++] = r, G[p++] = s * i + u * k + w, G[p++] = v * k + t * i + x, G[p++] = h.x2, G[p++] = h.y2, F[p++] = I, G[p++] = r, G[p++] = s * j + u * k + w, G[p++] = v * k + t * j + x, G[p++] = h.x3, G[p++] = h.y3, F[p++] = I, G[p++] = r), this.sprites[this.currentBatchSize++] = a;
        }
    }, d44.WebGLSpriteBatch.prototype.renderTilingSprite = function(a) {
        var b = a.tilingTexture, c = b.baseTexture, e = this.gl, f = a.texture.baseTexture.textureIndex;
        d44.WebGLRenderer.textureArray[f] != c && (this.flush(), e.activeTexture(e.TEXTURE0 + f), e.bindTexture(e.TEXTURE_2D, c._glTextures[e.id]), d44.WebGLRenderer.textureArray[f] = c), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = b.baseTexture), a._uvs || (a._uvs = new d44.TextureUvs);
        var g = a._uvs, h = b.baseTexture.width, i = b.baseTexture.height;
        a.tilePosition.x %= h * a.tileScaleOffset.x, a.tilePosition.y %= i * a.tileScaleOffset.y;
        var j = a.tilePosition.x / (h * a.tileScaleOffset.x), k = a.tilePosition.y / (i * a.tileScaleOffset.y), l = a.width / h / (a.tileScale.x * a.tileScaleOffset.x), m = a.height / i / (a.tileScale.y * a.tileScaleOffset.y);
        g.x0 = 0 - j, g.y0 = 0 - k, g.x1 = 1 * l - j, g.y1 = 0 - k, g.x2 = 1 * l - j, g.y2 = 1 * m - k, g.x3 = 0 - j, g.y3 = 1 * m - k;
        var n = a.tint, o = (n >> 16) + (65280 & n) + ((255 & n) << 16) + (255 * a.worldAlpha << 24), p = this.positions, q = this.colors, r = a.width, s = a.height, t = a.anchor.x, u = a.anchor.y, v = r * (1 - t), w = r * -t, x = s * (1 - u), y = s * -u, z = this.currentBatchSize * this.vertexSize, A = b.baseTexture.resolution, B = a.worldTransform, C = B.a / A, D = B.b / A, E = B.c / A, F = B.d / A, G = B.tx, H = B.ty;
        p[z++] = C * w + E * y + G, p[z++] = F * y + D * w + H, p[z++] = g.x0, p[z++] = g.y0, q[z++] = o, p[z++] = f, p[z++] = C * v + E * y + G, p[z++] = F * y + D * v + H, p[z++] = g.x1, p[z++] = g.y1, q[z++] = o, p[z++] = f, p[z++] = C * v + E * x + G, p[z++] = F * x + D * v + H, p[z++] = g.x2, p[z++] = g.y2, q[z++] = o, p[z++] = f, p[z++] = C * w + E * x + G, p[z++] = F * x + D * w + H, p[z++] = g.x3, p[z++] = g.y3, q[z++] = o, p[z++] = f, this.sprites[this.currentBatchSize++] = a;
    }, d44.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var a, b = this.gl;
            if (this.dirty) {
                this.dirty = !1, a = this.defaultShader.shaders[b.id], b.activeTexture(b.TEXTURE0), b.bindBuffer(b.ARRAY_BUFFER, this.vertexBuffer), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var c = this.vertexSize;
                b.vertexAttribPointer(a.aVertexPosition, 2, b.FLOAT, !1, c, 0), b.vertexAttribPointer(a.aTextureCoord, 2, b.FLOAT, !1, c, 8), b.vertexAttribPointer(a.colorAttribute, 4, b.UNSIGNED_BYTE, !0, c, 16), b.vertexAttribPointer(a.aTextureIndex, 1, b.FLOAT, !1, c, 20);
            }
            if (this.currentBatchSize > 0.5 * this.size) b.bufferSubData(b.ARRAY_BUFFER, 0, this.vertices);
            else {
                b.bindBuffer(b.ARRAY_BUFFER, this.vertexBuffer);
                var e = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                b.bufferSubData(b.ARRAY_BUFFER, 0, e);
            }
            for(var f, g, h, i, j = 0, k = 0, l = null, m = this.renderSession.blendModeManager.currentBlendMode, n = null, o = !1, p = !1, q = 0, r = this.currentBatchSize; q < r; q++){
                i = this.sprites[q], f = i.tilingTexture ? i.tilingTexture.baseTexture : i.texture.baseTexture, g = i.blendMode, h = i.shader || this.defaultShader, o = m !== g, p = n !== h;
                var s = f.skipRender;
                if (s && i.children.length > 0 && (s = !1), (o || p) && (this.renderBatch(l, j, k), k = q, j = 0, l = f, o && (m = g, this.renderSession.blendModeManager.setBlendMode(m)), p)) {
                    n = h, a = n.shaders[b.id], a || (a = new d44.PixiShader(b), a.fragmentSrc = n.fragmentSrc, a.uniforms = n.uniforms, a.init(), n.shaders[b.id] = a), this.renderSession.shaderManager.setShader(a), a.dirty && a.syncUniforms();
                    var t = this.renderSession.projection;
                    b.uniform2f(a.projectionVector, t.x, t.y);
                    var u = this.renderSession.offset;
                    b.uniform2f(a.offsetVector, u.x, u.y);
                }
                j++;
            }
            this.renderBatch(l, j, k), this.currentBatchSize = 0, this.renderSession.flushCount++;
        }
    }, d44.WebGLSpriteBatch.prototype.renderBatch = function(a, b, c) {
        if (0 !== b) {
            var d = this.gl;
            if (a._dirty[d.id]) {
                if (!this.renderSession.renderer.updateTexture(a)) return;
            } else d.bindTexture(d.TEXTURE_2D, a._glTextures[d.id]);
            d.drawElements(d.TRIANGLES, 6 * b, d.UNSIGNED_SHORT, 6 * c * 2), this.renderSession.drawCount++;
        }
    }, d44.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(), this.dirty = !0;
    }, d44.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0;
    }, d44.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null;
    }, d44.WebGLFastSpriteBatch = function(a) {
        this.vertSize = 11, this.maxSize = 6000, this.size = this.maxSize;
        var b = 4 * this.size * this.vertSize, c = 6 * this.maxSize;
        this.vertices = new Float32Array(b), this.indices = new Uint16Array(c), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
        for(var d = 0, e = 0; d < c; d += 6, e += 4)this.indices[d + 0] = e + 0, this.indices[d + 1] = e + 1, this.indices[d + 2] = e + 2, this.indices[d + 3] = e + 0, this.indices[d + 4] = e + 2, this.indices[d + 5] = e + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(a);
    }, d44.WebGLFastSpriteBatch.prototype.constructor = d44.WebGLFastSpriteBatch, d44.WebGLFastSpriteBatch.prototype.setContext = function(a) {
        this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW);
    }, d44.WebGLFastSpriteBatch.prototype.begin = function(a, b) {
        this.renderSession = b, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = a.worldTransform.toArray(!0), this.start();
    }, d44.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush();
    }, d44.WebGLFastSpriteBatch.prototype.render = function(a) {
        var b = a.children, c = b[0];
        if (c.texture._uvs) {
            this.currentBaseTexture = c.texture.baseTexture, c.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(c.blendMode));
            for(var d = 0, e = b.length; d < e; d++)this.renderSprite(b[d]);
            this.flush();
        }
    }, d44.WebGLFastSpriteBatch.prototype.renderSprite = function(a) {
        var b = a.texture, c = b.baseTexture, e = this.gl, f = a.texture.baseTexture.textureIndex;
        if ((d44.WebGLRenderer.textureArray[f] == c || !c._glTextures[e.id] || a.texture.baseTexture.skipRender || (this.flush(), e.activeTexture(e.TEXTURE0 + f), e.bindTexture(e.TEXTURE_2D, c._glTextures[e.id]), d44.WebGLRenderer.textureArray[f] = c, a.texture._uvs)) && a.visible) {
            var g, h, i, j, k, l, m = this.vertices;
            if (g = a.texture._uvs, a.texture.frame.width, a.texture.frame.height, a.texture.trim) {
                var n = a.texture.trim;
                i = n.x - a.anchor.x * n.width, h = i + a.texture.crop.width, k = n.y - a.anchor.y * n.height, j = k + a.texture.crop.height;
            } else h = a.texture.frame.width * (1 - a.anchor.x), i = a.texture.frame.width * -a.anchor.x, j = a.texture.frame.height * (1 - a.anchor.y), k = a.texture.frame.height * -a.anchor.y;
            l = 4 * this.currentBatchSize * this.vertSize, m[l++] = i, m[l++] = k, m[l++] = a.position.x, m[l++] = a.position.y, m[l++] = a.scale.x, m[l++] = a.scale.y, m[l++] = a.rotation, m[l++] = g.x0, m[l++] = g.y1, m[l++] = a.alpha, m[l++] = f, m[l++] = h, m[l++] = k, m[l++] = a.position.x, m[l++] = a.position.y, m[l++] = a.scale.x, m[l++] = a.scale.y, m[l++] = a.rotation, m[l++] = g.x1, m[l++] = g.y1, m[l++] = a.alpha, m[l++] = f, m[l++] = h, m[l++] = j, m[l++] = a.position.x, m[l++] = a.position.y, m[l++] = a.scale.x, m[l++] = a.scale.y, m[l++] = a.rotation, m[l++] = g.x2, m[l++] = g.y2, m[l++] = a.alpha, m[l++] = f, m[l++] = i, m[l++] = j, m[l++] = a.position.x, m[l++] = a.position.y, m[l++] = a.scale.x, m[l++] = a.scale.y, m[l++] = a.rotation, m[l++] = g.x3, m[l++] = g.y3, m[l++] = a.alpha, m[l++] = f, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush();
        }
    }, d44.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var a = this.gl;
            if (!this.currentBaseTexture._glTextures[a.id]) return void this.renderSession.renderer.updateTexture(this.currentBaseTexture, a);
            if (this.currentBatchSize > 0.5 * this.size) a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
            else {
                var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                a.bufferSubData(a.ARRAY_BUFFER, 0, b);
            }
            a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++, this.renderSession.flushCount++;
        }
    }, d44.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush();
    }, d44.WebGLFastSpriteBatch.prototype.start = function() {
        var a = this.gl;
        a.activeTexture(a.TEXTURE0), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var b = this.renderSession.projection;
        a.uniform2f(this.shader.projectionVector, b.x, b.y), a.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var c = 4 * this.vertSize;
        a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, c, 0), a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, !1, c, 8), a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, !1, c, 16), a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, !1, c, 24), a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, c, 28), a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, !1, c, 36), a.vertexAttribPointer(this.shader.aTextureIndex, 1, a.FLOAT, !1, c, 40);
    }, d44.WebGLFilterManager = function() {
        this.filterStack = [], this.offsetX = 0, this.offsetY = 0;
    }, d44.WebGLFilterManager.prototype.constructor = d44.WebGLFilterManager, d44.WebGLFilterManager.prototype.setContext = function(a) {
        this.gl = a, this.texturePool = [], this.initShaderBuffers();
    }, d44.WebGLFilterManager.prototype.begin = function(a, b) {
        this.renderSession = a, this.defaultShader = a.shaderManager.defaultShader;
        var c = this.renderSession.projection;
        this.width = 2 * c.x, this.height = 2 * -c.y, this.buffer = b;
    }, d44.WebGLFilterManager.prototype.pushFilter = function(a) {
        var b = this.gl, c = this.renderSession.projection, e = this.renderSession.offset;
        a._filterArea = a.target.filterArea || a.target.getBounds(), a._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new d44.WebGLStencilManager, this.renderSession.stencilManager.setContext(b), b.disable(b.STENCIL_TEST), this.filterStack.push(a);
        var f = a.filterPasses[0];
        this.offsetX += a._filterArea.x, this.offsetY += a._filterArea.y;
        var g = this.texturePool.pop();
        g ? g.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : g = new d44.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), b.bindTexture(b.TEXTURE_2D, g.texture);
        var h = a._filterArea, i = f.padding;
        h.x -= i, h.y -= i, h.width += 2 * i, h.height += 2 * i, h.x < 0 && (h.x = 0), h.width > this.width && (h.width = this.width), h.y < 0 && (h.y = 0), h.height > this.height && (h.height = this.height), b.bindFramebuffer(b.FRAMEBUFFER, g.frameBuffer), b.viewport(0, 0, h.width * this.renderSession.resolution, h.height * this.renderSession.resolution), c.x = h.width / 2, c.y = -h.height / 2, e.x = -h.x, e.y = -h.y, b.colorMask(!0, !0, !0, !0), b.clearColor(0, 0, 0, 0), b.clear(b.COLOR_BUFFER_BIT), a._glFilterTexture = g;
    }, d44.WebGLFilterManager.prototype.popFilter = function() {
        var a = this.gl, b = this.filterStack.pop(), c = b._filterArea, e = b._glFilterTexture, f = this.renderSession.projection, g = this.renderSession.offset;
        if (b.filterPasses.length > 1) {
            a.viewport(0, 0, c.width * this.renderSession.resolution, c.height * this.renderSession.resolution), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = c.height, this.vertexArray[2] = c.width, this.vertexArray[3] = c.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = c.width, this.vertexArray[7] = 0, a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = c.width / this.width, this.uvArray[5] = c.height / this.height, this.uvArray[6] = c.width / this.width, this.uvArray[7] = c.height / this.height, a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
            var h = e, i = this.texturePool.pop();
            i || (i = new d44.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), i.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.clear(a.COLOR_BUFFER_BIT), a.disable(a.BLEND);
            for(var j = 0; j < b.filterPasses.length - 1; j++){
                var k = b.filterPasses[j];
                a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, h.texture), this.applyFilterPass(k, c, c.width, c.height);
                var l = h;
                h = i, i = l;
            }
            a.enable(a.BLEND), e = h, this.texturePool.push(i);
        }
        var m = b.filterPasses[b.filterPasses.length - 1];
        this.offsetX -= c.x, this.offsetY -= c.y;
        var n = this.width, o = this.height, p = 0, q = 0, r = this.buffer;
        if (0 === this.filterStack.length) a.colorMask(!0, !0, !0, !0);
        else {
            var s = this.filterStack[this.filterStack.length - 1];
            c = s._filterArea, n = c.width, o = c.height, p = c.x, q = c.y, r = s._glFilterTexture.frameBuffer;
        }
        f.x = n / 2, f.y = -o / 2, g.x = p, g.y = q, c = b._filterArea;
        var t = c.x - p, u = c.y - q;
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = t, this.vertexArray[1] = u + c.height, this.vertexArray[2] = t + c.width, this.vertexArray[3] = u + c.height, this.vertexArray[4] = t, this.vertexArray[5] = u, this.vertexArray[6] = t + c.width, this.vertexArray[7] = u, a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = c.width / this.width, this.uvArray[5] = c.height / this.height, this.uvArray[6] = c.width / this.width, this.uvArray[7] = c.height / this.height, a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray), a.viewport(0, 0, n * this.renderSession.resolution, o * this.renderSession.resolution), a.bindFramebuffer(a.FRAMEBUFFER, r), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = b._previous_stencil_mgr, b._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.applyFilterPass(m, c, n, o), this.texturePool.push(e), b._glFilterTexture = null;
    }, d44.WebGLFilterManager.prototype.applyFilterPass = function(a, b, c, e) {
        var f = this.gl, g = a.shaders[f.id];
        g || (g = new d44.PixiShader(f), g.fragmentSrc = a.fragmentSrc, g.uniforms = a.uniforms, g.init(!0), a.shaders[f.id] = g), this.renderSession.shaderManager.setShader(g), f.uniform2f(g.projectionVector, c / 2, -e / 2), f.uniform2f(g.offsetVector, 0, 0), a.uniforms.dimensions && (a.uniforms.dimensions.value[0] = this.width, a.uniforms.dimensions.value[1] = this.height, a.uniforms.dimensions.value[2] = this.vertexArray[0], a.uniforms.dimensions.value[3] = this.vertexArray[5]), g.syncUniforms(), f.bindBuffer(f.ARRAY_BUFFER, this.vertexBuffer), f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.uvBuffer), f.vertexAttribPointer(g.aTextureCoord, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.colorBuffer), f.vertexAttribPointer(g.colorAttribute, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indexBuffer), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), this.renderSession.drawCount++;
    }, d44.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var a = this.gl;
        this.vertexBuffer = a.createBuffer(), this.uvBuffer = a.createBuffer(), this.colorBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), this.vertexArray = new Float32Array([
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW), this.uvArray = new Float32Array([
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW), this.colorArray = new Float32Array([
            1,
            16777215,
            1,
            16777215,
            1,
            16777215,
            1,
            16777215
        ]), a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer), a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([
            0,
            1,
            2,
            1,
            3,
            2
        ]), a.STATIC_DRAW);
    }, d44.WebGLFilterManager.prototype.destroy = function() {
        var a = this.gl;
        this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
        for(var b = 0; b < this.texturePool.length; b++)this.texturePool[b].destroy();
        this.texturePool = null, a.deleteBuffer(this.vertexBuffer), a.deleteBuffer(this.uvBuffer), a.deleteBuffer(this.colorBuffer), a.deleteBuffer(this.indexBuffer);
    };
    var e28 = {
        36054: "Incomplete attachment",
        36055: "Missing attachment",
        36057: "Incomplete dimensions",
        36061: "Framebuffer unsupported"
    };
    return d44.FilterTexture = function(a, c, e, f, g) {
        g = "number" == typeof g ? g : 0, this.gl = a, this.frameBuffer = b53(a, c, e, f || d44.scaleModes.DEFAULT, g), this.texture = this.frameBuffer.targetTexture, this.width = c, this.height = e, this.renderBuffer = this.frameBuffer.renderBuffer;
    }, d44.FilterTexture.prototype.constructor = d44.FilterTexture, d44.FilterTexture.prototype.clear = function() {
        var a = this.gl;
        a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT);
    }, d44.FilterTexture.prototype.resize = function(a, b) {
        if (this.width !== a || this.height !== b) {
            this.width = a, this.height = b;
            var c = this.gl;
            c.bindTexture(c.TEXTURE_2D, this.texture), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null), c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer), c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b);
        }
    }, d44.FilterTexture.prototype.destroy = function() {
        var a = this.gl;
        a.deleteFramebuffer(this.frameBuffer), a.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null;
    }, d44.CanvasBuffer = function(a, b) {
        this.width = a, this.height = b, this.canvas = Phaser.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = a, this.canvas.height = b;
    }, d44.CanvasBuffer.prototype.constructor = d44.CanvasBuffer, d44.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height);
    }, d44.CanvasBuffer.prototype.resize = function(a, b) {
        this.width = this.canvas.width = a, this.height = this.canvas.height = b;
    }, d44.CanvasBuffer.prototype.destroy = function() {
        Phaser.CanvasPool.remove(this);
    }, d44.CanvasMaskManager = function() {}, d44.CanvasMaskManager.prototype.constructor = d44.CanvasMaskManager, d44.CanvasMaskManager.prototype.pushMask = function(a, b) {
        var c = b.context;
        c.save();
        var e = a.alpha, f = a.worldTransform, g = b.resolution;
        c.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g), d44.CanvasGraphics.renderGraphicsMask(a, c), c.clip(), a.worldAlpha = e;
    }, d44.CanvasMaskManager.prototype.popMask = function(a) {
        a.context.restore();
    }, d44.CanvasTinter = function() {}, d44.CanvasTinter.getTintedTexture = function(a, b) {
        var c = a.tintedTexture || Phaser.CanvasPool.create(this);
        return d44.CanvasTinter.tintMethod(a.texture, b, c), c;
    }, d44.CanvasTinter.tintWithMultiply = function(a, b, c) {
        var d = c.getContext("2d"), e = a.crop, f = e.width, g = e.height;
        a.rotated && (f = g, g = e.width), c.width === f && c.height === g || (c.width = f, c.height = g), d.clearRect(0, 0, f, g), d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6), d.fillRect(0, 0, f, g), d.globalCompositeOperation = "multiply", d.drawImage(a.baseTexture.source, e.x, e.y, f, g, 0, 0, f, g), d.globalCompositeOperation = "destination-atop", d.drawImage(a.baseTexture.source, e.x, e.y, f, g, 0, 0, f, g);
    }, d44.CanvasTinter.tintWithPerPixel = function(a, b, c) {
        var e = c.getContext("2d"), f = a.crop, g = f.width, h = f.height;
        a.rotated && (g = h, h = f.width), c.width === g && c.height === h || (c.width = g, c.height = h), e.globalCompositeOperation = "copy", e.drawImage(a.baseTexture.source, f.x, f.y, g, h, 0, 0, g, h);
        for(var i = Phaser.Color.hexToRGBArray(b), j = i[0], k = i[1], l = i[2], m = e.getImageData(0, 0, g, h), n = m.data, o = 0; o < n.length; o += 4)if (n[o + 0] *= j, n[o + 1] *= k, n[o + 2] *= l, !d44.CanvasTinter.canHandleAlpha) {
            var p = n[o + 3];
            n[o + 0] /= 255 / p, n[o + 1] /= 255 / p, n[o + 2] /= 255 / p;
        }
        e.putImageData(m, 0, 0);
    }, d44.CanvasRenderer = function(a) {
        this.game = a, d44.defaultRenderer || (d44.defaultRenderer = this), this.type = Phaser.CANVAS, this.resolution = a.resolution, this.clearBeforeRender = a.clearBeforeRender, this.transparent = a.transparent, this.autoResize = !1, this.width = a.width * this.resolution, this.height = a.height * this.resolution, this.view = a.canvas, this.context = this.view.getContext("2d", {
            alpha: this.transparent
        }), this.refresh = !0, this.count = 0, this.maskManager = new d44.CanvasMaskManager, this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
            roundPixels: !1
        }, this.mapBlendModes(), this.resize(this.width, this.height);
    }, d44.CanvasRenderer.prototype.constructor = d44.CanvasRenderer, d44.CanvasRenderer.prototype.render = function(a) {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : a._bgColor && (this.context.fillStyle = a._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(a);
    }, d44.CanvasRenderer.prototype.setTexturePriority = function(a) {}, d44.CanvasRenderer.prototype.destroy = function(a) {
        void 0 === a && (a = !0), a && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null;
    }, d44.CanvasRenderer.prototype.resize = function(a, b) {
        this.width = a * this.resolution, this.height = b * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === d44.scaleModes.LINEAR);
    }, d44.CanvasRenderer.prototype.renderDisplayObject = function(a, b, c) {
        this.renderSession.context = b || this.context, this.renderSession.resolution = this.resolution, a._renderCanvas(this.renderSession, c);
    }, d44.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!d44.blendModesCanvas) {
            var a = [], b = d44.blendModes, c = this.game.device.canUseMultiply;
            a[b.NORMAL] = "source-over", a[b.ADD] = "lighter", a[b.MULTIPLY] = c ? "multiply" : "source-over", a[b.SCREEN] = c ? "screen" : "source-over", a[b.OVERLAY] = c ? "overlay" : "source-over", a[b.DARKEN] = c ? "darken" : "source-over", a[b.LIGHTEN] = c ? "lighten" : "source-over", a[b.COLOR_DODGE] = c ? "color-dodge" : "source-over", a[b.COLOR_BURN] = c ? "color-burn" : "source-over", a[b.HARD_LIGHT] = c ? "hard-light" : "source-over", a[b.SOFT_LIGHT] = c ? "soft-light" : "source-over", a[b.DIFFERENCE] = c ? "difference" : "source-over", a[b.EXCLUSION] = c ? "exclusion" : "source-over", a[b.HUE] = c ? "hue" : "source-over", a[b.SATURATION] = c ? "saturation" : "source-over", a[b.COLOR] = c ? "color" : "source-over", a[b.LUMINOSITY] = c ? "luminosity" : "source-over", d44.blendModesCanvas = a;
        }
    }, d44.BaseTexture = function(a, b, c) {
        this.resolution = c || 1, this.width = 100, this.height = 100, this.scaleMode = b || d44.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = a, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this.textureIndex = 0, this._dirty = [
            !0,
            !0,
            !0,
            !0
        ], a && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1);
    }, d44.BaseTexture.prototype.constructor = d44.BaseTexture, d44.BaseTexture.prototype.forceLoaded = function(a, b) {
        this.hasLoaded = !0, this.width = a, this.height = b, this.dirty();
    }, d44.BaseTexture.prototype.destroy = function() {
        this.source && Phaser.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU();
    }, d44.BaseTexture.prototype.updateSourceImage = function(a) {
        console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.");
    }, d44.BaseTexture.prototype.dirty = function() {
        for(var a = 0; a < this._glTextures.length; a++)this._dirty[a] = !0;
    }, d44.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for(var a = this._glTextures.length - 1; a >= 0; a--){
            var b = this._glTextures[a], c = d44.glContexts[a];
            c && b && c.deleteTexture(b);
        }
        this._glTextures.length = 0, this.dirty();
    }, d44.BaseTexture.fromCanvas = function(a, b, c) {
        return 0 === a.width && (a.width = 1), 0 === a.height && (a.height = 1), c = c || 1, new d44.BaseTexture(a, b, c);
    }, d44.TextureSilentFail = !1, d44.Texture = function(a, b, c, e) {
        this.noFrame = !1, b || (this.noFrame = !0, b = new d44.Rectangle(0, 0, 1, 1)), a instanceof d44.Texture && (a = a.baseTexture), this.baseTexture = a, this.frame = b, this.trim = e, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = c || new d44.Rectangle(0, 0, 1, 1), this.rotated = !1, a.hasLoaded && (this.noFrame && (b = new d44.Rectangle(0, 0, a.width, a.height)), this.setFrame(b));
    }, d44.Texture.prototype.constructor = d44.Texture, d44.Texture.prototype.onBaseTextureLoaded = function() {
        var a = this.baseTexture;
        this.noFrame && (this.frame = new d44.Rectangle(0, 0, a.width, a.height)), this.setFrame(this.frame);
    }, d44.Texture.prototype.destroy = function(a) {
        a && this.baseTexture.destroy(), this.valid = !1;
    }, d44.Texture.prototype.setFrame = function(a) {
        if (this.noFrame = !1, this.frame = a, this.width = a.width, this.height = a.height, this.crop.x = a.x, this.crop.y = a.y, this.crop.width = a.width, this.crop.height = a.height, !this.trim && (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height)) {
            if (!d44.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            return void (this.valid = !1);
        }
        this.valid = a && a.width && a.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
    }, d44.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new d44.TextureUvs);
        var a = this.crop, b = this.baseTexture.width, c = this.baseTexture.height;
        this._uvs.x0 = a.x / b, this._uvs.y0 = a.y / c, this._uvs.x1 = (a.x + a.width) / b, this._uvs.y1 = a.y / c, this._uvs.x2 = (a.x + a.width) / b, this._uvs.y2 = (a.y + a.height) / c, this._uvs.x3 = a.x / b, this._uvs.y3 = (a.y + a.height) / c;
    }, d44.Texture.prototype._updateUvsInverted = function() {
        this._uvs || (this._uvs = new d44.TextureUvs);
        var a = this.crop, b = this.baseTexture.width, c = this.baseTexture.height;
        this._uvs.x0 = a.x / b, this._uvs.y0 = a.y / c, this._uvs.x1 = (a.x + a.height) / b, this._uvs.y1 = a.y / c, this._uvs.x2 = (a.x + a.height) / b, this._uvs.y2 = (a.y + a.width) / c, this._uvs.x3 = a.x / b, this._uvs.y3 = (a.y + a.width) / c;
    }, d44.Texture.fromCanvas = function(a, b) {
        var c = d44.BaseTexture.fromCanvas(a, b);
        return new d44.Texture(c);
    }, d44.TextureUvs = function() {
        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0;
    }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = d44), exports.PIXI = d44) : "undefined" != typeof define && define.amd ? define("PIXI", function() {
        return c52.PIXI = d44;
    }()) : c52.PIXI = d44, d44;
}).call(this), (function() {
    function a65(a, b) {
        this._scaleFactor = a, this._deltaMode = b, this.originalEvent = null;
    }
    var b54 = this, c53 = c53 || {
        VERSION: "2.8.2",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        WEBGL_MULTI: 4,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        CIRCLE: 21,
        RECTANGLE: 22,
        LINE: 23,
        MATRIX: 24,
        POINT: 25,
        ROUNDEDRECTANGLE: 26,
        CREATURE: 27,
        VIDEO: 28,
        PENDING_ATLAS: -1,
        HORIZONTAL: 0,
        VERTICAL: 1,
        LANDSCAPE: 0,
        PORTRAIT: 1,
        ANGLE_UP: 270,
        ANGLE_DOWN: 90,
        ANGLE_LEFT: 180,
        ANGLE_RIGHT: 0,
        ANGLE_NORTH_EAST: 315,
        ANGLE_NORTH_WEST: 225,
        ANGLE_SOUTH_EAST: 45,
        ANGLE_SOUTH_WEST: 135,
        TOP_LEFT: 0,
        TOP_CENTER: 1,
        TOP_RIGHT: 2,
        LEFT_TOP: 3,
        LEFT_CENTER: 4,
        LEFT_BOTTOM: 5,
        CENTER: 6,
        RIGHT_TOP: 7,
        RIGHT_CENTER: 8,
        RIGHT_BOTTOM: 9,
        BOTTOM_LEFT: 10,
        BOTTOM_CENTER: 11,
        BOTTOM_RIGHT: 12,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        },
        PIXI: PIXI || {},
        _UID: 0
    };
    if (Math.trunc || (Math.trunc = function(a) {
        return a < 0 ? Math.ceil(a) : Math.floor(a);
    }), Function.prototype.bind || (Function.prototype.bind = function() {
        var a66 = Array.prototype.slice;
        return function(b55) {
            function c() {
                var f = e.concat(a66.call(arguments));
                d.apply(this instanceof c ? this : b55, f);
            }
            var d = this, e = a66.call(arguments, 1);
            if ("function" != typeof d) throw new TypeError;
            return c.prototype = function a(b) {
                if (b && (a.prototype = b), !(this instanceof a)) return new a;
            }(d.prototype), c;
        };
    }()), Array.isArray || (Array.isArray = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a);
    }), Array.prototype.forEach || (Array.prototype.forEach = function(a) {
        "use strict";
        if (void 0 === this || null === this) throw new TypeError;
        var b = Object(this), c = b.length >>> 0;
        if ("function" != typeof a) throw new TypeError;
        for(var d = arguments.length >= 2 ? arguments[1] : void 0, e = 0; e < c; e++)e in b && a.call(d, b[e], e, b);
    }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
        var d45 = function(a67) {
            var b56 = new Array;
            window[a67] = function(a) {
                if ("number" == typeof a) {
                    Array.call(this, a), this.length = a;
                    for(var b = 0; b < this.length; b++)this[b] = 0;
                } else {
                    Array.call(this, a.length), this.length = a.length;
                    for(var b = 0; b < this.length; b++)this[b] = a[b];
                }
            }, window[a67].prototype = b56, window[a67].constructor = window[a67];
        };
        d45("Float32Array"), d45("Uint32Array"), d45("Uint16Array"), d45("Int16Array"), d45("ArrayBuffer");
    }
    window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), Object.assign || (Object.assign = function(a, b) {
        "use strict";
        if (null == a) throw new TypeError("Cannot convert undefined or null to object");
        for(var c = Object(a), d = Object.prototype.hasOwnProperty, e = 1; e < arguments.length; e++){
            var f = arguments[e];
            if (null != f) for(var g in f)d.call(f, g) && (c[g] = f[g]);
        }
        return c;
    }), c53.Utils = {
        reverseString: function(a) {
            return a.split("").reverse().join("");
        },
        getProperty: function(a, b) {
            for(var c = b.split("."), d = c.length, e = 0, f = a; e < d;){
                var g = c[e];
                if (null == f) return;
                f = f[g], e++;
            }
            return f;
        },
        setProperty: function(a, b, c) {
            for(var d = b.split("."), e = d.pop(), f = d.length, g = 1, h = d[0]; g < f && (a = a[h]);)h = d[g], g++;
            return a && (a[e] = c), a;
        },
        chanceRoll: function(a) {
            return void 0 === a && (a = 50), a > 0 && 100 * Math.random() <= a;
        },
        randomChoice: function(a, b) {
            return Math.random() < 0.5 ? a : b;
        },
        parseDimension: function(a, b) {
            var c = 0, d = 0;
            return "string" == typeof a ? "%" === a.substr(-1) ? (c = parseInt(a, 10) / 100, d = 0 === b ? window.innerWidth * c : window.innerHeight * c) : d = parseInt(a, 10) : d = a, d;
        },
        pad: function(a, b, c, d) {
            if (void 0 === b) var b = 0;
            if (void 0 === c) var c = " ";
            if (void 0 === d) var d = 3;
            a = a.toString();
            var e = 0;
            if (b + 1 >= a.length) switch(d){
                case 1:
                    a = new Array(b + 1 - a.length).join(c) + a;
                    break;
                case 3:
                    var f = Math.ceil((e = b - a.length) / 2), g = e - f;
                    a = new Array(g + 1).join(c) + a + new Array(f + 1).join(c);
                    break;
                default:
                    a += new Array(b + 1 - a.length).join(c);
            }
            return a;
        },
        isPlainObject: function(a) {
            if ("object" != typeof a || a.nodeType || a === a.window) return !1;
            try {
                if (a.constructor && !({}).hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (a68) {
                return !1;
            }
            return !0;
        },
        extend: function() {
            var a, b, d, e, f, g, h = arguments[0] || {}, i = 1, j = arguments.length, k = !1;
            for("boolean" == typeof h && (k = h, h = arguments[1] || {}, i = 2), j === i && (h = this, --i); i < j; i++)if (null != (a = arguments[i])) for(b in a)d = h[b], e = a[b], h !== e && (k && e && (c53.Utils.isPlainObject(e) || (f = Array.isArray(e))) ? (f ? (f = !1, g = d && Array.isArray(d) ? d : []) : g = d && c53.Utils.isPlainObject(d) ? d : {}, h[b] = c53.Utils.extend(k, g, e)) : void 0 !== e && (h[b] = e));
            return h;
        },
        mixinPrototype: function(a, b, c) {
            void 0 === c && (c = !1);
            for(var d = Object.keys(b), e = 0; e < d.length; e++){
                var f = d[e], g = b[f];
                !c && f in a || (!g || "function" != typeof g.get && "function" != typeof g.set ? a[f] = g : "function" == typeof g.clone ? a[f] = g.clone() : Object.defineProperty(a, f, g));
            }
        },
        mixin: function(a, b) {
            if (!a || "object" != typeof a) return b;
            for(var d in a){
                var e = a[d];
                if (!e.childNodes && !e.cloneNode) {
                    var f = typeof a[d];
                    a[d] && "object" === f ? typeof b[d] === f ? b[d] = c53.Utils.mixin(a[d], b[d]) : b[d] = c53.Utils.mixin(a[d], new e.constructor) : b[d] = a[d];
                }
            }
            return b;
        }
    }, c53.Circle = function(a, b, d) {
        a = a || 0, b = b || 0, d = d || 0, this.x = a, this.y = b, this._diameter = d, this._radius = 0, d > 0 && (this._radius = 0.5 * d), this.type = c53.CIRCLE;
    }, c53.Circle.prototype = {
        circumference: function() {
            return Math.PI * this._radius * 2;
        },
        random: function(a) {
            void 0 === a && (a = new c53.Point);
            var b = 2 * Math.PI * Math.random(), d = Math.random() + Math.random(), e = d > 1 ? 2 - d : d, f = e * Math.cos(b), g = e * Math.sin(b);
            return a.x = this.x + f * this.radius, a.y = this.y + g * this.radius, a;
        },
        getBounds: function() {
            return new c53.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter);
        },
        setTo: function(a, b, c) {
            return this.x = a, this.y = b, this._diameter = c, this._radius = 0.5 * c, this;
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.diameter);
        },
        copyTo: function(a) {
            return a.x = this.x, a.y = this.y, a.diameter = this._diameter, a;
        },
        distance: function(a, b) {
            var d = c53.Math.distance(this.x, this.y, a.x, a.y);
            return b ? Math.round(d) : d;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c53.Circle(this.x, this.y, this.diameter) : a.setTo(this.x, this.y, this.diameter), a;
        },
        contains: function(a, b) {
            return c53.Circle.contains(this, a, b);
        },
        circumferencePoint: function(a, b, d) {
            return c53.Circle.circumferencePoint(this, a, b, d);
        },
        offset: function(a, b) {
            return this.x += a, this.y += b, this;
        },
        offsetPoint: function(a) {
            return this.offset(a.x, a.y);
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
        }
    }, c53.Circle.prototype.constructor = c53.Circle, Object.defineProperty(c53.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter;
        },
        set: function(a) {
            a > 0 && (this._diameter = a, this._radius = 0.5 * a);
        }
    }), Object.defineProperty(c53.Circle.prototype, "radius", {
        get: function() {
            return this._radius;
        },
        set: function(a) {
            a > 0 && (this._radius = a, this._diameter = 2 * a);
        }
    }), Object.defineProperty(c53.Circle.prototype, "left", {
        get: function() {
            return this.x - this._radius;
        },
        set: function(a) {
            a > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - a;
        }
    }), Object.defineProperty(c53.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius;
        },
        set: function(a) {
            a < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = a - this.x;
        }
    }), Object.defineProperty(c53.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius;
        },
        set: function(a) {
            a > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - a;
        }
    }), Object.defineProperty(c53.Circle.prototype, "bottom", {
        get: function() {
            return this.y + this._radius;
        },
        set: function(a) {
            a < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = a - this.y;
        }
    }), Object.defineProperty(c53.Circle.prototype, "area", {
        get: function() {
            return this._radius > 0 ? Math.PI * this._radius * this._radius : 0;
        }
    }), Object.defineProperty(c53.Circle.prototype, "empty", {
        get: function() {
            return 0 === this._diameter;
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0);
        }
    }), c53.Circle.contains = function(a, b, c) {
        if (a.radius > 0 && b >= a.left && b <= a.right && c >= a.top && c <= a.bottom) return (a.x - b) * (a.x - b) + (a.y - c) * (a.y - c) <= a.radius * a.radius;
        return !1;
    }, c53.Circle.equals = function(a, b) {
        return a.x === b.x && a.y === b.y && a.diameter === b.diameter;
    }, c53.Circle.intersects = function(a, b) {
        return c53.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius;
    }, c53.Circle.circumferencePoint = function(a, b, d, e) {
        return void 0 === d && (d = !1), void 0 === e && (e = new c53.Point), !0 === d && (b = c53.Math.degToRad(b)), e.x = a.x + a.radius * Math.cos(b), e.y = a.y + a.radius * Math.sin(b), e;
    }, c53.Circle.intersectsRectangle = function(a, b) {
        var c = Math.abs(a.x - b.x - b.halfWidth);
        if (c > b.halfWidth + a.radius) return !1;
        var d = Math.abs(a.y - b.y - b.halfHeight);
        if (d > b.halfHeight + a.radius) return !1;
        if (c <= b.halfWidth || d <= b.halfHeight) return !0;
        var e = c - b.halfWidth, f = d - b.halfHeight;
        return e * e + f * f <= a.radius * a.radius;
    }, PIXI.Circle = c53.Circle, c53.Ellipse = function(a, b, d, e) {
        a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.x = a, this.y = b, this.width = d, this.height = e, this.type = c53.ELLIPSE;
    }, c53.Ellipse.prototype = {
        setTo: function(a, b, c, d) {
            return this.x = a, this.y = b, this.width = c, this.height = d, this;
        },
        getBounds: function() {
            return new c53.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.width, a.height);
        },
        copyTo: function(a) {
            return a.x = this.x, a.y = this.y, a.width = this.width, a.height = this.height, a;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c53.Ellipse(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height), a;
        },
        contains: function(a, b) {
            return c53.Ellipse.contains(this, a, b);
        },
        random: function(a) {
            void 0 === a && (a = new c53.Point);
            var b = Math.random() * Math.PI * 2, d = Math.random();
            return a.x = Math.sqrt(d) * Math.cos(b), a.y = Math.sqrt(d) * Math.sin(b), a.x = this.x + a.x * this.width / 2, a.y = this.y + a.y * this.height / 2, a;
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]";
        }
    }, c53.Ellipse.prototype.constructor = c53.Ellipse, Object.defineProperty(c53.Ellipse.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(a) {
            this.x = a;
        }
    }), Object.defineProperty(c53.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(a) {
            a < this.x ? this.width = 0 : this.width = a - this.x;
        }
    }), Object.defineProperty(c53.Ellipse.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(a) {
            this.y = a;
        }
    }), Object.defineProperty(c53.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(a) {
            a < this.y ? this.height = 0 : this.height = a - this.y;
        }
    }), Object.defineProperty(c53.Ellipse.prototype, "empty", {
        get: function() {
            return 0 === this.width || 0 === this.height;
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0, 0);
        }
    }), c53.Ellipse.contains = function(a, b, c) {
        if (a.width <= 0 || a.height <= 0) return !1;
        var d = (b - a.x) / a.width - 0.5, e = (c - a.y) / a.height - 0.5;
        return d *= d, e *= e, d + e < 0.25;
    }, PIXI.Ellipse = c53.Ellipse, c53.Line = function(a, b, d, e) {
        a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.start = new c53.Point(a, b), this.end = new c53.Point(d, e), this.type = c53.LINE;
    }, c53.Line.prototype = {
        setTo: function(a, b, c, d) {
            return this.start.setTo(a, b), this.end.setTo(c, d), this;
        },
        fromSprite: function(a, b, c) {
            return void 0 === c && (c = !1), c ? this.setTo(a.centerX, a.centerY, b.centerX, b.centerY) : this.setTo(a.x, a.y, b.x, b.y);
        },
        fromAngle: function(a, b, c, d) {
            return this.start.setTo(a, b), this.end.setTo(a + Math.cos(c) * d, b + Math.sin(c) * d), this;
        },
        rotate: function(a, b) {
            var c = (this.start.x + this.end.x) / 2, d = (this.start.y + this.end.y) / 2;
            return this.start.rotate(c, d, a, b), this.end.rotate(c, d, a, b), this;
        },
        rotateAround: function(a, b, c, d) {
            return this.start.rotate(a, b, c, d), this.end.rotate(a, b, c, d), this;
        },
        intersects: function(a, b, d) {
            return c53.Line.intersectsPoints(this.start, this.end, a.start, a.end, b, d);
        },
        reflect: function(a) {
            return c53.Line.reflect(this, a);
        },
        midPoint: function(a) {
            return void 0 === a && (a = new c53.Point), a.x = (this.start.x + this.end.x) / 2, a.y = (this.start.y + this.end.y) / 2, a;
        },
        centerOn: function(a, b) {
            var c = (this.start.x + this.end.x) / 2, d = (this.start.y + this.end.y) / 2, e = a - c, f = b - d;
            this.start.add(e, f), this.end.add(e, f);
        },
        pointOnLine: function(a, b) {
            return (a - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (b - this.start.y);
        },
        pointOnSegment: function(a, b) {
            var c = Math.min(this.start.x, this.end.x), d = Math.max(this.start.x, this.end.x), e = Math.min(this.start.y, this.end.y), f = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(a, b) && a >= c && a <= d && b >= e && b <= f;
        },
        random: function(a) {
            void 0 === a && (a = new c53.Point);
            var b = Math.random();
            return a.x = this.start.x + b * (this.end.x - this.start.x), a.y = this.start.y + b * (this.end.y - this.start.y), a;
        },
        coordinatesOnLine: function(a, b) {
            void 0 === a && (a = 1), void 0 === b && (b = []);
            var c = Math.round(this.start.x), d = Math.round(this.start.y), e = Math.round(this.end.x), f = Math.round(this.end.y), g = Math.abs(e - c), h = Math.abs(f - d), i = c < e ? 1 : -1, j = d < f ? 1 : -1, k = g - h;
            b.push([
                c,
                d
            ]);
            for(var l = 1; c !== e || d !== f;){
                var m = k << 1;
                m > -h && (k -= h, c += i), m < g && (k += g, d += j), l % a == 0 && b.push([
                    c,
                    d
                ]), l++;
            }
            return b;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c53.Line(this.start.x, this.start.y, this.end.x, this.end.y) : a.setTo(this.start.x, this.start.y, this.end.x, this.end.y), a;
        }
    }, Object.defineProperty(c53.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
        }
    }), Object.defineProperty(c53.Line.prototype, "angle", {
        get: function() {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
        }
    }), Object.defineProperty(c53.Line.prototype, "slope", {
        get: function() {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x);
        }
    }), Object.defineProperty(c53.Line.prototype, "perpSlope", {
        get: function() {
            return -(this.end.x - this.start.x) / (this.end.y - this.start.y);
        }
    }), Object.defineProperty(c53.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    }), Object.defineProperty(c53.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    }), Object.defineProperty(c53.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    }), Object.defineProperty(c53.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x);
        }
    }), Object.defineProperty(c53.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    }), Object.defineProperty(c53.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y);
        }
    }), Object.defineProperty(c53.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x);
        }
    }), Object.defineProperty(c53.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y - this.end.y);
        }
    }), Object.defineProperty(c53.Line.prototype, "normalX", {
        get: function() {
            return Math.cos(this.angle - 1.5707963267948966);
        }
    }), Object.defineProperty(c53.Line.prototype, "normalY", {
        get: function() {
            return Math.sin(this.angle - 1.5707963267948966);
        }
    }), Object.defineProperty(c53.Line.prototype, "normalAngle", {
        get: function() {
            return c53.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI);
        }
    }), c53.Line.intersectsPoints = function(a, b, d, e, f, g) {
        void 0 === f && (f = !0), void 0 === g && (g = new c53.Point);
        var h = b.y - a.y, i = e.y - d.y, j = a.x - b.x, k = d.x - e.x, l = b.x * a.y - a.x * b.y, m = e.x * d.y - d.x * e.y, n = h * k - i * j;
        if (0 === n) return null;
        if (g.x = (j * m - k * l) / n, g.y = (i * l - h * m) / n, f) {
            var o = (e.y - d.y) * (b.x - a.x) - (e.x - d.x) * (b.y - a.y), p = ((e.x - d.x) * (a.y - d.y) - (e.y - d.y) * (a.x - d.x)) / o, q = ((b.x - a.x) * (a.y - d.y) - (b.y - a.y) * (a.x - d.x)) / o;
            return p >= 0 && p <= 1 && q >= 0 && q <= 1 ? g : null;
        }
        return g;
    }, c53.Line.intersects = function(a, b, d, e) {
        return c53.Line.intersectsPoints(a.start, a.end, b.start, b.end, d, e);
    }, c53.Line.intersectsRectangle = function(a, b) {
        if (0 === a.length || b.empty) return !1;
        var c = a.start.x, d = a.start.y, e = a.end.x, f = a.end.y, g = b.x, h = b.y, i = b.right, j = b.bottom, k = 0;
        if (c >= g && c <= i && d >= h && d <= j || e >= g && e <= i && f >= h && f <= j) return !0;
        if (c < g && e >= g) {
            if ((k = d + (f - d) * (g - c) / (e - c)) > h && k <= j) return !0;
        } else if (c > i && e <= i && (k = d + (f - d) * (i - c) / (e - c)) >= h && k <= j) return !0;
        if (d < h && f >= h) {
            if ((k = c + (e - c) * (h - d) / (f - d)) >= g && k <= i) return !0;
        } else if (d > j && f <= j && (k = c + (e - c) * (j - d) / (f - d)) >= g && k <= i) return !0;
        return !1;
    }, c53.Line.reflect = function(a, b) {
        return 2 * b.normalAngle - 3.141592653589793 - a.angle;
    }, c53.Matrix = function(a, b, d, e, f, g) {
        void 0 !== a && null !== a || (a = 1), void 0 !== b && null !== b || (b = 0), void 0 !== d && null !== d || (d = 0), void 0 !== e && null !== e || (e = 1), void 0 !== f && null !== f || (f = 0), void 0 !== g && null !== g || (g = 0), this.a = a, this.b = b, this.c = d, this.d = e, this.tx = f, this.ty = g, this.type = c53.MATRIX;
    }, c53.Matrix.prototype = {
        fromArray: function(a) {
            return this.setTo(a[0], a[1], a[3], a[4], a[2], a[5]);
        },
        setTo: function(a, b, c, d, e, f) {
            return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = e, this.ty = f, this;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c53.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (a.a = this.a, a.b = this.b, a.c = this.c, a.d = this.d, a.tx = this.tx, a.ty = this.ty), a;
        },
        copyTo: function(a) {
            return a.copyFrom(this), a;
        },
        copyFrom: function(a) {
            return this.a = a.a, this.b = a.b, this.c = a.c, this.d = a.d, this.tx = a.tx, this.ty = a.ty, this;
        },
        toArray: function(a, b) {
            return void 0 === b && (b = new Float32Array(9)), a ? (b[0] = this.a, b[1] = this.b, b[2] = 0, b[3] = this.c, b[4] = this.d, b[5] = 0, b[6] = this.tx, b[7] = this.ty, b[8] = 1) : (b[0] = this.a, b[1] = this.c, b[2] = this.tx, b[3] = this.b, b[4] = this.d, b[5] = this.ty, b[6] = 0, b[7] = 0, b[8] = 1), b;
        },
        apply: function(a, b) {
            return void 0 === b && (b = new c53.Point), b.x = this.a * a.x + this.c * a.y + this.tx, b.y = this.b * a.x + this.d * a.y + this.ty, b;
        },
        applyInverse: function(a, b) {
            void 0 === b && (b = new c53.Point);
            var d = 1 / (this.a * this.d + this.c * -this.b), e = a.x, f = a.y;
            return b.x = this.d * d * e + -this.c * d * f + (this.ty * this.c - this.tx * this.d) * d, b.y = this.a * d * f + -this.b * d * e + (-this.ty * this.a + this.tx * this.b) * d, b;
        },
        translate: function(a, b) {
            return this.tx += a, this.ty += b, this;
        },
        scale: function(a, b) {
            return this.a *= a, this.d *= b, this.c *= a, this.b *= b, this.tx *= a, this.ty *= b, this;
        },
        rotate: function(a) {
            var b = Math.cos(a), c = Math.sin(a), d = this.a, e = this.c, f = this.tx;
            return this.a = d * b - this.b * c, this.b = d * c + this.b * b, this.c = e * b - this.d * c, this.d = e * c + this.d * b, this.tx = f * b - this.ty * c, this.ty = f * c + this.ty * b, this;
        },
        append: function(a) {
            var b = this.a, c = this.b, d = this.c, e = this.d;
            return this.a = a.a * b + a.b * d, this.b = a.a * c + a.b * e, this.c = a.c * b + a.d * d, this.d = a.c * c + a.d * e, this.tx = a.tx * b + a.ty * d + this.tx, this.ty = a.tx * c + a.ty * e + this.ty, this;
        },
        identity: function() {
            return this.setTo(1, 0, 0, 1, 0, 0);
        }
    }, c53.identityMatrix = new c53.Matrix, PIXI.Matrix = c53.Matrix, PIXI.identityMatrix = c53.identityMatrix, c53.Point = function(a, b) {
        a = a || 0, b = b || 0, this.x = a, this.y = b, this.type = c53.POINT;
    }, c53.Point.prototype = {
        copyFrom: function(a) {
            return this.setTo(a.x, a.y);
        },
        invert: function() {
            return this.setTo(this.y, this.x);
        },
        setTo: function(a, b) {
            return c53.Point.set(this, a, b);
        },
        set: function(a, b) {
            return c53.Point.set(this, a, b);
        },
        setToPolar: function(a, b, d) {
            return null == b && (b = 1), d && (a = c53.Math.degToRad(a)), this.setTo(Math.cos(a) * b, Math.sin(a) * b);
        },
        add: function(a, b) {
            return this.x += a, this.y += b, this;
        },
        subtract: function(a, b) {
            return this.x -= a, this.y -= b, this;
        },
        multiply: function(a, b) {
            return this.x *= a, this.y *= b, this;
        },
        divide: function(a, b) {
            return this.x /= a, this.y /= b, this;
        },
        clampX: function(a, b) {
            return this.x = c53.Math.clamp(this.x, a, b), this;
        },
        clampY: function(a, b) {
            return this.y = c53.Math.clamp(this.y, a, b), this;
        },
        clamp: function(a, b) {
            return this.x = c53.Math.clamp(this.x, a, b), this.y = c53.Math.clamp(this.y, a, b), this;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c53.Point(this.x, this.y) : a.setTo(this.x, this.y), a;
        },
        copyTo: function(a) {
            return a.x = this.x, a.y = this.y, a;
        },
        distance: function(a, b) {
            return c53.Point.distance(this, a, b);
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y;
        },
        angle: function(a, b) {
            return void 0 === b && (b = !1), b ? c53.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x);
        },
        rotate: function(a, b, d, e, f) {
            return c53.Point.rotate(this, a, b, d, e, f);
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        setMagnitude: function(a) {
            return this.normalize().multiply(a, a);
        },
        normalize: function() {
            if (!this.isZero()) {
                var a = this.getMagnitude();
                this.x /= a, this.y /= a;
            }
            return this;
        },
        limit: function(a) {
            return this.getMagnitudeSq() > a * a && this.setMagnitude(a), this;
        },
        isZero: function() {
            return 0 === this.x && 0 === this.y;
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y;
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x;
        },
        perp: function() {
            return this.setTo(-this.y, this.x);
        },
        rperp: function() {
            return this.setTo(this.y, -this.x);
        },
        normalRightHand: function() {
            return this.setTo(-1 * this.y, this.x);
        },
        floor: function() {
            return this.setTo(Math.floor(this.x), Math.floor(this.y));
        },
        ceil: function() {
            return this.setTo(Math.ceil(this.x), Math.ceil(this.y));
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]";
        }
    }, c53.Point.prototype.constructor = c53.Point, c53.Point.add = function(a, b, d) {
        return void 0 === d && (d = new c53.Point), d.x = a.x + b.x, d.y = a.y + b.y, d;
    }, c53.Point.subtract = function(a, b, d) {
        return void 0 === d && (d = new c53.Point), d.x = a.x - b.x, d.y = a.y - b.y, d;
    }, c53.Point.multiply = function(a, b, d) {
        return void 0 === d && (d = new c53.Point), d.x = a.x * b.x, d.y = a.y * b.y, d;
    }, c53.Point.divide = function(a, b, d) {
        return void 0 === d && (d = new c53.Point), d.x = a.x / b.x, d.y = a.y / b.y, d;
    }, c53.Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    }, c53.Point.angle = function(a, b) {
        return Math.atan2(a.y - b.y, a.x - b.x);
    }, c53.Point.negative = function(a, b) {
        return void 0 === b && (b = new c53.Point), b.setTo(-a.x, -a.y);
    }, c53.Point.multiplyAdd = function(a, b, d, e) {
        return void 0 === e && (e = new c53.Point), e.setTo(a.x + b.x * d, a.y + b.y * d);
    }, c53.Point.interpolate = function(a, b, d, e) {
        return void 0 === e && (e = new c53.Point), e.setTo(a.x + (b.x - a.x) * d, a.y + (b.y - a.y) * d);
    }, c53.Point.perp = function(a, b) {
        return void 0 === b && (b = new c53.Point), b.setTo(-a.y, a.x);
    }, c53.Point.rperp = function(a, b) {
        return void 0 === b && (b = new c53.Point), b.setTo(a.y, -a.x);
    }, c53.Point.distance = function(a, b, d) {
        var e = c53.Math.distance(a.x, a.y, b.x, b.y);
        return d ? Math.round(e) : e;
    }, c53.Point.project = function(a, b, d) {
        void 0 === d && (d = new c53.Point);
        var e = a.dot(b) / b.getMagnitudeSq();
        return 0 !== e && d.setTo(e * b.x, e * b.y), d;
    }, c53.Point.projectUnit = function(a, b, d) {
        void 0 === d && (d = new c53.Point);
        var e = a.dot(b);
        return 0 !== e && d.setTo(e * b.x, e * b.y), d;
    }, c53.Point.normalRightHand = function(a, b) {
        return void 0 === b && (b = new c53.Point), b.setTo(-1 * a.y, a.x);
    }, c53.Point.normalize = function(a, b) {
        void 0 === b && (b = new c53.Point);
        var d = a.getMagnitude();
        return 0 !== d && b.setTo(a.x / d, a.y / d), b;
    }, c53.Point.rotate = function(a, b, d, e, f, g) {
        if (f && (e = c53.Math.degToRad(e)), void 0 === g) {
            a.subtract(b, d);
            var h = Math.sin(e), i = Math.cos(e), j = i * a.x - h * a.y, k = h * a.x + i * a.y;
            a.x = j + b, a.y = k + d;
        } else {
            var l = e + Math.atan2(a.y - d, a.x - b);
            a.x = b + g * Math.cos(l), a.y = d + g * Math.sin(l);
        }
        return a;
    }, c53.Point.centroid = function(a, b) {
        if (void 0 === b && (b = new c53.Point), "[object Array]" !== Object.prototype.toString.call(a)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
        var d = a.length;
        if (d < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        if (1 === d) return b.copyFrom(a[0]), b;
        for(var e = 0; e < d; e++)c53.Point.add(b, a[e], b);
        return b.divide(d, d), b;
    }, c53.Point.parse = function(a, b, d) {
        b = b || "x", d = d || "y";
        var e = new c53.Point;
        return a[b] && (e.x = parseInt(a[b], 10)), a[d] && (e.y = parseInt(a[d], 10)), e;
    }, c53.Point.isPoint = function(a) {
        return null != a && "number" == typeof a.x && "number" == typeof a.y;
    }, c53.Point.set = function(a, b, c) {
        return a.x = b || 0, a.y = c || (0 !== c ? a.x : 0), a;
    }, PIXI.Point = c53.Point, c53.Polygon = function() {
        this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = c53.POLYGON;
    }, c53.Polygon.prototype = {
        toNumberArray: function(a) {
            void 0 === a && (a = []);
            for(var b = 0; b < this._points.length; b++)"number" == typeof this._points[b] ? (a.push(this._points[b]), a.push(this._points[b + 1]), b++) : (a.push(this._points[b].x), a.push(this._points[b].y));
            return a;
        },
        flatten: function() {
            return this._points = this.toNumberArray(), this.flattened = !0, this;
        },
        clone: function(a) {
            var b = this._points.slice();
            return void 0 === a || null === a ? a = new c53.Polygon(b) : a.setTo(b), a;
        },
        contains: function(a, b) {
            var c = !1;
            if (this.flattened) for(var d = -2, e = this._points.length - 2; (d += 2) < this._points.length; e = d){
                var f = this._points[d], g = this._points[d + 1], h = this._points[e], i = this._points[e + 1];
                (g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f && (c = !c);
            }
            else for(var d = -1, e = this._points.length - 1; ++d < this._points.length; e = d){
                var f = this._points[d].x, g = this._points[d].y, h = this._points[e].x, i = this._points[e].y;
                (g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f && (c = !c);
            }
            return c;
        },
        setTo: function(a) {
            if (this.area = 0, this._points = [], arguments.length > 0) {
                Array.isArray(a) || (a = Array.prototype.slice.call(arguments));
                for(var b = Number.MAX_VALUE, c = 0, d = a.length; c < d; c++){
                    if ("number" == typeof a[c]) {
                        var e = new PIXI.Point(a[c], a[c + 1]);
                        c++;
                    } else if (Array.isArray(a[c])) var e = new PIXI.Point(a[c][0], a[c][1]);
                    else var e = new PIXI.Point(a[c].x, a[c].y);
                    this._points.push(e), e.y < b && (b = e.y);
                }
                this.calculateArea(b);
            }
            return this;
        },
        calculateArea: function(a) {
            for(var b, c, d, e, f = 0, g = this._points.length; f < g; f++)b = this._points[f], c = f === g - 1 ? this._points[0] : this._points[f + 1], d = (b.y - a + (c.y - a)) / 2, e = b.x - c.x, this.area += d * e;
            return this.area;
        }
    }, c53.Polygon.prototype.constructor = c53.Polygon, Object.defineProperty(c53.Polygon.prototype, "points", {
        get: function() {
            return this._points;
        },
        set: function(a) {
            null != a ? this.setTo(a) : this.setTo();
        }
    }), PIXI.Polygon = c53.Polygon, c53.Rectangle = function(a, b, d, e) {
        a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.x = a, this.y = b, this.width = d, this.height = e, this.type = c53.RECTANGLE;
    }, c53.Rectangle.prototype = {
        offset: function(a, b) {
            return this.x += a, this.y += b, this;
        },
        offsetPoint: function(a) {
            return this.offset(a.x, a.y);
        },
        setTo: function(a, b, c, d) {
            return this.x = a, this.y = b, this.width = c, this.height = d, this;
        },
        scale: function(a, b) {
            return void 0 === b && (b = a), this.width *= a, this.height *= b, this;
        },
        centerOn: function(a, b) {
            return this.centerX = a, this.centerY = b, this;
        },
        floor: function() {
            this.x = Math.floor(this.x), this.y = Math.floor(this.y);
        },
        floorAll: function() {
            this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height);
        },
        ceil: function() {
            this.x = Math.ceil(this.x), this.y = Math.ceil(this.y);
        },
        ceilAll: function() {
            this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height);
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.width, a.height);
        },
        copyTo: function(a) {
            return a.x = this.x, a.y = this.y, a.width = this.width, a.height = this.height, a;
        },
        inflate: function(a, b) {
            return c53.Rectangle.inflate(this, a, b);
        },
        size: function(a) {
            return c53.Rectangle.size(this, a);
        },
        resize: function(a, b) {
            return this.width = a, this.height = b, this;
        },
        clone: function(a) {
            return c53.Rectangle.clone(this, a);
        },
        contains: function(a, b) {
            return c53.Rectangle.contains(this, a, b);
        },
        containsRect: function(a) {
            return c53.Rectangle.containsRect(a, this);
        },
        equals: function(a) {
            return c53.Rectangle.equals(this, a);
        },
        intersection: function(a, b) {
            return c53.Rectangle.intersection(this, a, b);
        },
        intersects: function(a) {
            return c53.Rectangle.intersects(this, a);
        },
        intersectsRaw: function(a, b, d, e, f) {
            return c53.Rectangle.intersectsRaw(this, a, b, d, e, f);
        },
        union: function(a, b) {
            return c53.Rectangle.union(this, a, b);
        },
        random: function(a) {
            return void 0 === a && (a = new c53.Point), a.x = this.randomX, a.y = this.randomY, a;
        },
        getPoint: function(a, b) {
            switch(void 0 === b && (b = new c53.Point), a){
                default:
                case c53.TOP_LEFT:
                    return b.set(this.x, this.y);
                case c53.TOP_CENTER:
                    return b.set(this.centerX, this.y);
                case c53.TOP_RIGHT:
                    return b.set(this.right, this.y);
                case c53.LEFT_CENTER:
                    return b.set(this.x, this.centerY);
                case c53.CENTER:
                    return b.set(this.centerX, this.centerY);
                case c53.RIGHT_CENTER:
                    return b.set(this.right, this.centerY);
                case c53.BOTTOM_LEFT:
                    return b.set(this.x, this.bottom);
                case c53.BOTTOM_CENTER:
                    return b.set(this.centerX, this.bottom);
                case c53.BOTTOM_RIGHT:
                    return b.set(this.right, this.bottom);
            }
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]";
        }
    }, Object.defineProperty(c53.Rectangle.prototype, "halfWidth", {
        get: function() {
            return Math.round(this.width / 2);
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2);
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(a) {
            a <= this.y ? this.height = 0 : this.height = a - this.y;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "bottomLeft", {
        get: function() {
            return new c53.Point(this.x, this.bottom);
        },
        set: function(a) {
            this.x = a.x, this.bottom = a.y;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new c53.Point(this.right, this.bottom);
        },
        set: function(a) {
            this.right = a.x, this.bottom = a.y;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(a) {
            a >= this.right ? this.width = 0 : this.width = this.right - a, this.x = a;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(a) {
            a <= this.x ? this.width = 0 : this.width = a - this.x;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "perimeter", {
        get: function() {
            return 2 * this.width + 2 * this.height;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "centerX", {
        get: function() {
            return this.x + this.halfWidth;
        },
        set: function(a) {
            this.x = a - this.halfWidth;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight;
        },
        set: function(a) {
            this.y = a - this.halfHeight;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "randomX", {
        get: function() {
            return this.x + Math.random() * this.width;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "randomY", {
        get: function() {
            return this.y + Math.random() * this.height;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(a) {
            a >= this.bottom ? (this.height = 0, this.y = a) : this.height = this.bottom - a;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "topLeft", {
        get: function() {
            return new c53.Point(this.x, this.y);
        },
        set: function(a) {
            this.x = a.x, this.y = a.y;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "topRight", {
        get: function() {
            return new c53.Point(this.x + this.width, this.y);
        },
        set: function(a) {
            this.right = a.x, this.y = a.y;
        }
    }), Object.defineProperty(c53.Rectangle.prototype, "empty", {
        get: function() {
            return !this.width || !this.height;
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0, 0);
        }
    }), c53.Rectangle.prototype.constructor = c53.Rectangle, c53.Rectangle.inflate = function(a, b, c) {
        return a.x -= b, a.width += 2 * b, a.y -= c, a.height += 2 * c, a;
    }, c53.Rectangle.inflatePoint = function(a, b) {
        return c53.Rectangle.inflate(a, b.x, b.y);
    }, c53.Rectangle.size = function(a, b) {
        return void 0 === b || null === b ? b = new c53.Point(a.width, a.height) : b.setTo(a.width, a.height), b;
    }, c53.Rectangle.clone = function(a, b) {
        return void 0 === b || null === b ? b = new c53.Rectangle(a.x, a.y, a.width, a.height) : b.setTo(a.x, a.y, a.width, a.height), b;
    }, c53.Rectangle.contains = function(a, b, c) {
        return !(a.width <= 0 || a.height <= 0) && b >= a.x && b < a.right && c >= a.y && c < a.bottom;
    }, c53.Rectangle.containsRaw = function(a, b, c, d, e, f) {
        return e >= a && e < a + c && f >= b && f < b + d;
    }, c53.Rectangle.containsPoint = function(a, b) {
        return c53.Rectangle.contains(a, b.x, b.y);
    }, c53.Rectangle.containsRect = function(a, b) {
        return !(a.volume > b.volume) && a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom;
    }, c53.Rectangle.equals = function(a, b) {
        return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
    }, c53.Rectangle.sameDimensions = function(a, b) {
        return a.width === b.width && a.height === b.height;
    }, c53.Rectangle.intersection = function(a, b, d) {
        return void 0 === d && (d = new c53.Rectangle), c53.Rectangle.intersects(a, b) && (d.x = Math.max(a.x, b.x), d.y = Math.max(a.y, b.y), d.width = Math.min(a.right, b.right) - d.x, d.height = Math.min(a.bottom, b.bottom) - d.y), d;
    }, c53.Rectangle.intersects = function(a, b) {
        return !(a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0) && !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);
    }, c53.Rectangle.intersectsRaw = function(a, b, c, d, e, f) {
        return void 0 === f && (f = 0), !(b > a.right + f || c < a.left - f || d > a.bottom + f || e < a.top - f);
    }, c53.Rectangle.union = function(a, b, d) {
        return void 0 === d && (d = new c53.Rectangle), d.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));
    }, c53.Rectangle.aabb = function(a69, b) {
        void 0 === b && (b = new c53.Rectangle);
        var d = Number.NEGATIVE_INFINITY, e = Number.POSITIVE_INFINITY, f = Number.NEGATIVE_INFINITY, g = Number.POSITIVE_INFINITY;
        return a69.forEach(function(a) {
            a.x > d && (d = a.x), a.x < e && (e = a.x), a.y > f && (f = a.y), a.y < g && (g = a.y);
        }), b.setTo(e, g, d - e, f - g), b;
    }, PIXI.Rectangle = c53.Rectangle, PIXI.EmptyRectangle = new c53.Rectangle(0, 0, 0, 0), c53.RoundedRectangle = function(a, b, d, e, f) {
        void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = 20), this.x = a, this.y = b, this.width = d, this.height = e, this.radius = f || 20, this.type = c53.ROUNDEDRECTANGLE;
    }, c53.RoundedRectangle.prototype = {
        clone: function() {
            return new c53.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        },
        contains: function(a, b) {
            if (this.width <= 0 || this.height <= 0) return !1;
            var c = this.x;
            if (a >= c && a <= c + this.width) {
                var d = this.y;
                if (b >= d && b <= d + this.height) return !0;
            }
            return !1;
        }
    }, c53.RoundedRectangle.prototype.constructor = c53.RoundedRectangle, PIXI.RoundedRectangle = c53.RoundedRectangle, c53.Camera = function(a, b, d, e, f, g) {
        this.game = a, this.world = a.world, this.id = 0, this.view = new c53.Rectangle(d, e, f, g), this.bounds = new c53.Rectangle(d, e, f, g), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
            x: !1,
            y: !1
        }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new c53.Point(1, 1), this.onShakeComplete = new c53.Signal, this.onFlashComplete = new c53.Signal, this.onFadeComplete = new c53.Signal, this.fx = null, this._targetPosition = new c53.Point, this._edge = 0, this._position = new c53.Point, this._shake = {
            intensity: 0,
            duration: 0,
            horizontal: !1,
            vertical: !1,
            shakeBounds: !0,
            x: 0,
            y: 0
        }, this._fxDuration = 0, this._fxType = 0;
    }, c53.Camera.FOLLOW_LOCKON = 0, c53.Camera.FOLLOW_PLATFORMER = 1, c53.Camera.FOLLOW_TOPDOWN = 2, c53.Camera.FOLLOW_TOPDOWN_TIGHT = 3, c53.Camera.SHAKE_BOTH = 4, c53.Camera.SHAKE_HORIZONTAL = 5, c53.Camera.SHAKE_VERTICAL = 6, c53.Camera.ENABLE_FX = !0, c53.Camera.prototype = {
        boot: function() {
            this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, c53.Graphics && c53.Camera.ENABLE_FX && (this.fx = new c53.Graphics(this.game), this.game.stage.addChild(this.fx));
        },
        preUpdate: function() {
            this.totalInView = 0;
        },
        follow: function(a, b, d, e) {
            void 0 === b && (b = c53.Camera.FOLLOW_LOCKON), void 0 === d && (d = 1), void 0 === e && (e = 1), this.target = a, this.lerp.set(d, e);
            var f;
            switch(b){
                case c53.Camera.FOLLOW_PLATFORMER:
                    var g = this.width / 8, h = this.height / 3;
                    this.deadzone = new c53.Rectangle((this.width - g) / 2, (this.height - h) / 2 - 0.25 * h, g, h);
                    break;
                case c53.Camera.FOLLOW_TOPDOWN:
                    f = Math.max(this.width, this.height) / 4, this.deadzone = new c53.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f);
                    break;
                case c53.Camera.FOLLOW_TOPDOWN_TIGHT:
                    f = Math.max(this.width, this.height) / 8, this.deadzone = new c53.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f);
                    break;
                case c53.Camera.FOLLOW_LOCKON:
                default:
                    this.deadzone = null;
            }
        },
        unfollow: function() {
            this.target = null;
        },
        focusOn: function(a) {
            this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight));
        },
        focusOnXY: function(a, b) {
            this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight));
        },
        shake: function(a, b, d, e, f) {
            return void 0 === a && (a = 0.05), void 0 === b && (b = 500), void 0 === d && (d = !0), void 0 === e && (e = c53.Camera.SHAKE_BOTH), void 0 === f && (f = !0), !(!d && this._shake.duration > 0) && (this._shake.intensity = a, this._shake.duration = b, this._shake.shakeBounds = f, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = e === c53.Camera.SHAKE_BOTH || e === c53.Camera.SHAKE_HORIZONTAL, this._shake.vertical = e === c53.Camera.SHAKE_BOTH || e === c53.Camera.SHAKE_VERTICAL, !0);
        },
        flash: function(a, b, c, d) {
            return void 0 === a && (a = 16777215), void 0 === b && (b = 500), void 0 === c && (c = !1), void 0 === d && (d = 1), !(!this.fx || !c && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(a, d), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = b, this._fxType = 0, !0);
        },
        fade: function(a, b, c, d) {
            return void 0 === a && (a = 0), void 0 === b && (b = 500), void 0 === c && (c = !1), void 0 === d && (d = 1), !(!this.fx || !c && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(a, d), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = b, this._fxType = 1, !0);
        },
        update: function() {
            this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y;
        },
        updateFX: function() {
            0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()));
        },
        updateShake: function() {
            this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height));
        },
        updateTarget: function() {
            this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y;
        },
        setBoundsToWorld: function() {
            this.bounds && this.bounds.copyFrom(this.game.world.bounds);
        },
        checkBounds: function() {
            this.atLimit.x = !1, this.atLimit.y = !1;
            var a = this.view.x + this._shake.x, b = this.view.right + this._shake.x, c = this.view.y + this._shake.y, d = this.view.bottom + this._shake.y;
            a <= this.bounds.x * this.scale.x ? (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)) : b >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), c <= this.bounds.top * this.scale.y ? (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)) : d >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0));
        },
        setPosition: function(a, b) {
            this.view.x = a, this.view.y = b, this.bounds && this.checkBounds();
        },
        setSize: function(a, b) {
            this.view.width = a, this.view.height = b;
        },
        reset: function() {
            this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this._shake.x = 0, this._shake.y = 0, this.resetFX();
        },
        resetFX: function() {
            this.fx && (this.fx.clear(), this.fx.alpha = 0), this._fxDuration = 0;
        }
    }, c53.Camera.prototype.constructor = c53.Camera, Object.defineProperty(c53.Camera.prototype, "x", {
        get: function() {
            return this.view.x;
        },
        set: function(a) {
            this.view.x = a, this.bounds && this.checkBounds();
        }
    }), Object.defineProperty(c53.Camera.prototype, "y", {
        get: function() {
            return this.view.y;
        },
        set: function(a) {
            this.view.y = a, this.bounds && this.checkBounds();
        }
    }), Object.defineProperty(c53.Camera.prototype, "position", {
        get: function() {
            return this._position.set(this.view.x, this.view.y), this._position;
        },
        set: function(a) {
            void 0 !== a.x && (this.view.x = a.x), void 0 !== a.y && (this.view.y = a.y), this.bounds && this.checkBounds();
        }
    }), Object.defineProperty(c53.Camera.prototype, "width", {
        get: function() {
            return this.view.width;
        },
        set: function(a) {
            this.view.width = a;
        }
    }), Object.defineProperty(c53.Camera.prototype, "height", {
        get: function() {
            return this.view.height;
        },
        set: function(a) {
            this.view.height = a;
        }
    }), Object.defineProperty(c53.Camera.prototype, "shakeIntensity", {
        get: function() {
            return this._shake.intensity;
        },
        set: function(a) {
            this._shake.intensity = a;
        }
    }), c53.State = function() {
        this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null;
    }, c53.State.prototype = {
        init: function() {},
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        preRender: function() {},
        render: function() {},
        resize: function() {},
        paused: function() {},
        resumed: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    }, c53.State.prototype.constructor = c53.State, c53.StateManager = function(a, b) {
        this.game = a, this.states = {}, this._pendingState = null, void 0 !== b && null !== b && (this._pendingState = b), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new c53.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null;
    }, c53.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0);
        },
        add: function(a, b, d) {
            void 0 === d && (d = !1);
            var e;
            return b instanceof c53.State ? e = b : "object" == typeof b ? (e = b, e.game = this.game) : "function" == typeof b && (e = new b(this.game)), this.states[a] = e, d && (this.game.isBooted ? this.start(a) : this._pendingState = a), e;
        },
        remove: function(a) {
            this.current === a && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[a];
        },
        start: function(a, b, c) {
            void 0 === b && (b = !0), void 0 === c && (c = !1), this.checkState(a) && (this._pendingState = a, this._clearWorld = b, this._clearCache = c, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)));
        },
        restart: function(a, b) {
            void 0 === a && (a = !0), void 0 === b && (b = !1), this._pendingState = this.current, this._clearWorld = a, this._clearCache = b, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2));
        },
        dummy: function() {},
        preUpdate: function() {
            if (this._pendingState && this.game.isBooted) {
                var a = this.current;
                if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, a), this.current !== this._pendingState) return;
                this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete();
            }
        },
        clearCurrentState: function() {
            this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()));
        },
        checkState: function(a) {
            return this.states[a] ? !!(this.states[a].preload || this.states[a].create || this.states[a].update || this.states[a].render) || (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + a), !1);
        },
        link: function(a) {
            this.states[a].game = this.game, this.states[a].add = this.game.add, this.states[a].make = this.game.make, this.states[a].camera = this.game.camera, this.states[a].cache = this.game.cache, this.states[a].input = this.game.input, this.states[a].load = this.game.load, this.states[a].math = this.game.math, this.states[a].sound = this.game.sound, this.states[a].scale = this.game.scale, this.states[a].state = this, this.states[a].stage = this.game.stage, this.states[a].time = this.game.time, this.states[a].tweens = this.game.tweens, this.states[a].world = this.game.world, this.states[a].particles = this.game.particles, this.states[a].rnd = this.game.rnd, this.states[a].physics = this.game.physics, this.states[a].key = a;
        },
        unlink: function(a) {
            this.states[a] && (this.states[a].game = null, this.states[a].add = null, this.states[a].make = null, this.states[a].camera = null, this.states[a].cache = null, this.states[a].input = null, this.states[a].load = null, this.states[a].math = null, this.states[a].sound = null, this.states[a].scale = null, this.states[a].state = null, this.states[a].stage = null, this.states[a].time = null, this.states[a].tweens = null, this.states[a].world = null, this.states[a].particles = null, this.states[a].rnd = null, this.states[a].physics = null);
        },
        setCurrentState: function(a) {
            this.callbackContext = this.states[a], this.link(a), this.onInitCallback = this.states[a].init || this.dummy, this.onPreloadCallback = this.states[a].preload || null, this.onLoadRenderCallback = this.states[a].loadRender || null, this.onLoadUpdateCallback = this.states[a].loadUpdate || null, this.onCreateCallback = this.states[a].create || null, this.onUpdateCallback = this.states[a].update || null, this.onPreRenderCallback = this.states[a].preRender || null, this.onRenderCallback = this.states[a].render || null, this.onResizeCallback = this.states[a].resize || null, this.onPausedCallback = this.states[a].paused || null, this.onResumedCallback = this.states[a].resumed || null, this.onPauseUpdateCallback = this.states[a].pauseUpdate || null, this.onShutDownCallback = this.states[a].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = a, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), a === this._pendingState && (this._args = []), this.game._kickstart = !0;
        },
        getCurrentState: function() {
            return this.states[this.current];
        },
        loadComplete: function() {
            !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0;
        },
        pause: function() {
            this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game);
        },
        resume: function() {
            this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game);
        },
        update: function() {
            this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        },
        pauseUpdate: function() {
            this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        },
        preRender: function(a) {
            this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, a);
        },
        resize: function(a, b) {
            this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, a, b);
        },
        render: function() {
            this._created ? this.onRenderCallback && (this.game.renderType === c53.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game);
        },
        destroy: function() {
            this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = "";
        }
    }, c53.StateManager.prototype.constructor = c53.StateManager, Object.defineProperty(c53.StateManager.prototype, "created", {
        get: function() {
            return this._created;
        }
    }), c53.Signal = function() {}, c53.Signal.prototype = {
        _bindings: null,
        _prevParams: null,
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        _boundDispatch: !1,
        validateListener: function(a, b) {
            if ("function" != typeof a) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
        },
        _registerListener: function(a, b, d, e, f) {
            var g, h = this._indexOfListener(a, d);
            if (-1 !== h) {
                if (g = this._bindings[h], g.isOnce() !== b) throw new Error("You cannot add" + (b ? "" : "Once") + "() then add" + (b ? "Once" : "") + "() the same listener without removing the relationship first.");
            } else g = new c53.SignalBinding(this, a, b, d, e, f), this._addBinding(g);
            return this.memorize && this._prevParams && g.execute(this._prevParams), g;
        },
        _addBinding: function(a) {
            this._bindings || (this._bindings = []);
            var b = this._bindings.length;
            do b--;
            while (this._bindings[b] && a._priority <= this._bindings[b]._priority)
            this._bindings.splice(b + 1, 0, a);
        },
        _indexOfListener: function(a, b) {
            if (!this._bindings) return -1;
            void 0 === b && (b = null);
            for(var c, d = this._bindings.length; d--;)if (c = this._bindings[d], c._listener === a && c.context === b) return d;
            return -1;
        },
        has: function(a, b) {
            return -1 !== this._indexOfListener(a, b);
        },
        add: function(a, b, c) {
            this.validateListener(a, "add");
            var d = [];
            if (arguments.length > 3) for(var e = 3; e < arguments.length; e++)d.push(arguments[e]);
            return this._registerListener(a, !1, b, c, d);
        },
        addOnce: function(a, b, c) {
            this.validateListener(a, "addOnce");
            var d = [];
            if (arguments.length > 3) for(var e = 3; e < arguments.length; e++)d.push(arguments[e]);
            return this._registerListener(a, !0, b, c, d);
        },
        remove: function(a, b) {
            this.validateListener(a, "remove");
            var c = this._indexOfListener(a, b);
            return -1 !== c && (this._bindings[c]._destroy(), this._bindings.splice(c, 1)), a;
        },
        removeAll: function(a) {
            if (void 0 === a && (a = null), this._bindings) {
                for(var b = this._bindings.length; b--;)a ? this._bindings[b].context === a && (this._bindings[b]._destroy(), this._bindings.splice(b, 1)) : this._bindings[b]._destroy();
                a || (this._bindings.length = 0);
            }
        },
        getNumListeners: function() {
            return this._bindings ? this._bindings.length : 0;
        },
        halt: function() {
            this._shouldPropagate = !1;
        },
        dispatch: function() {
            if (this.active && this._bindings) {
                var a, b = Array.prototype.slice.call(arguments), c = this._bindings.length;
                if (this.memorize && (this._prevParams = b), c) {
                    a = this._bindings.slice(), this._shouldPropagate = !0;
                    do c--;
                    while (a[c] && this._shouldPropagate && !1 !== a[c].execute(b))
                }
            }
        },
        forget: function() {
            this._prevParams && (this._prevParams = null);
        },
        dispose: function() {
            this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null);
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        }
    }, Object.defineProperty(c53.Signal.prototype, "boundDispatch", {
        get: function() {
            var a = this;
            return this._boundDispatch || (this._boundDispatch = function() {
                return a.dispatch.apply(a, arguments);
            });
        }
    }), c53.Signal.prototype.constructor = c53.Signal, c53.SignalBinding = function(a, b, c, d, e, f) {
        this._listener = b, c && (this._isOnce = !0), null != d && (this.context = d), this._signal = a, e && (this._priority = e), f && f.length && (this._args = f);
    }, c53.SignalBinding.prototype = {
        context: null,
        _isOnce: !1,
        _priority: 0,
        _args: null,
        callCount: 0,
        active: !0,
        params: null,
        execute: function(a) {
            var b, c;
            return this.active && this._listener && (c = this.params ? this.params.concat(a) : a, this._args && (c = c.concat(this._args)), b = this._listener.apply(this.context, c), this.callCount++, this._isOnce && this.detach()), b;
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        isBound: function() {
            return !!this._signal && !!this._listener;
        },
        isOnce: function() {
            return this._isOnce;
        },
        getListener: function() {
            return this._listener;
        },
        getSignal: function() {
            return this._signal;
        },
        _destroy: function() {
            delete this._signal, delete this._listener, delete this.context;
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        }
    }, c53.SignalBinding.prototype.constructor = c53.SignalBinding, c53.Filter = function(a, b, d) {
        this.game = a, this.type = c53.WEBGL_FILTER, this.passes = [
            this
        ], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new c53.Point;
        var e = new Date;
        if (this.uniforms = {
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            time: {
                type: "1f",
                value: 0
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            },
            date: {
                type: "4fv",
                value: [
                    e.getFullYear(),
                    e.getMonth(),
                    e.getDate(),
                    60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds()
                ]
            },
            sampleRate: {
                type: "1f",
                value: 44100
            },
            iChannel0: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel1: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel2: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel3: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            }
        }, b) for(var f in b)this.uniforms[f] = b[f];
        "string" == typeof d && (d = d.split("\n")), this.fragmentSrc = d || [];
    }, c53.Filter.prototype = {
        init: function() {},
        setResolution: function(a, b) {
            this.uniforms.resolution.value.x = a, this.uniforms.resolution.value.y = b;
        },
        update: function(a) {
            if (a) {
                var b = a.x / this.game.width, c = 1 - a.y / this.game.height;
                b === this.prevPoint.x && c === this.prevPoint.y || (this.uniforms.mouse.value.x = b.toFixed(2), this.uniforms.mouse.value.y = c.toFixed(2), this.prevPoint.set(b, c));
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds();
        },
        addToWorld: function(a, b, d, e, f, g) {
            void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 !== d && null !== d ? this.width = d : d = this.width, void 0 !== e && null !== e ? this.height = e : e = this.height;
            var h = this.game.add.image(a, b, c53.Cache.DEFAULT);
            return h.width = d, h.height = e, h.anchor.set(f, g), h.filters = [
                this
            ], h;
        },
        syncUniforms: function() {
            for(var a = 0; a < this.shaders.length; a++)this.shaders[a].dirty = !0;
        },
        destroy: function() {
            this.passes.length = 0, this.shaders.length = 0, this.fragmentSrc.length = 0, this.game = null, this.uniforms = null, this.prevPoint = null;
        }
    }, c53.Filter.prototype.constructor = c53.Filter, Object.defineProperty(c53.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x;
        },
        set: function(a) {
            this.uniforms.resolution.value.x = a;
        }
    }), Object.defineProperty(c53.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y;
        },
        set: function(a) {
            this.uniforms.resolution.value.y = a;
        }
    }), c53.Plugin = function(a, b) {
        void 0 === b && (b = null), this.game = a, this.parent = b, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1;
    }, c53.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.game = null, this.parent = null, this.active = !1, this.visible = !1;
        }
    }, c53.Plugin.prototype.constructor = c53.Plugin, c53.PluginManager = function(a) {
        this.game = a, this.plugins = [], this._len = 0, this._i = 0;
    }, c53.PluginManager.prototype = {
        add: function(a) {
            var b = Array.prototype.slice.call(arguments, 1), c = !1;
            return "function" == typeof a ? a = new a(this.game, this) : (a.game = this.game, a.parent = this), "function" == typeof a.preUpdate && (a.hasPreUpdate = !0, c = !0), "function" == typeof a.update && (a.hasUpdate = !0, c = !0), "function" == typeof a.postUpdate && (a.hasPostUpdate = !0, c = !0), "function" == typeof a.render && (a.hasRender = !0, c = !0), "function" == typeof a.postRender && (a.hasPostRender = !0, c = !0), c ? ((a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) && (a.active = !0), (a.hasRender || a.hasPostRender) && (a.visible = !0), this._len = this.plugins.push(a), "function" == typeof a.init && a.init.apply(a, b), a) : null;
        },
        remove: function(a, b) {
            for(void 0 === b && (b = !0), this._i = this._len; this._i--;)if (this.plugins[this._i] === a) return b && a.destroy(), this.plugins.splice(this._i, 1), void this._len--;
        },
        removeAll: function() {
            for(this._i = this._len; this._i--;)this.plugins[this._i].destroy();
            this.plugins.length = 0, this._len = 0;
        },
        preUpdate: function() {
            for(this._i = this._len; this._i--;)this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate();
        },
        update: function() {
            for(this._i = this._len; this._i--;)this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update();
        },
        postUpdate: function() {
            for(this._i = this._len; this._i--;)this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate();
        },
        render: function() {
            for(this._i = this._len; this._i--;)this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render();
        },
        postRender: function() {
            for(this._i = this._len; this._i--;)this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender();
        },
        destroy: function() {
            this.removeAll(), this.game = null;
        }
    }, c53.PluginManager.prototype.constructor = c53.PluginManager, c53.Stage = function(a) {
        this.game = a, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            color: 0,
            rgba: "#000000"
        }, this.game.transparent || (this._bgColor.a = 1), a.config && this.parseConfig(a.config);
    }, c53.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c53.Stage.prototype.constructor = c53.Stage, c53.Stage.prototype.parseConfig = function(a) {
        a.disableVisibilityChange && (this.disableVisibilityChange = a.disableVisibilityChange), a.backgroundColor && this.setBackgroundColor(a.backgroundColor);
    }, c53.Stage.prototype.boot = function() {
        c53.DOM.getOffset(this.game.canvas, this.offset), c53.Canvas.setUserSelect(this.game.canvas, "none"), c53.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility();
    }, c53.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        for(var a = 0; a < this.children.length;){
            var b = this.children[a];
            b.preUpdate(), this === b.parent && a++;
        }
    }, c53.Stage.prototype.update = function() {
        for(var a = this.children.length; a--;)this.children[a].update();
    }, c53.Stage.prototype.postUpdate = function() {
        this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
        for(var a = 0; a < this.children.length; a++)this.children[a].postUpdate();
        this.updateTransform();
    }, c53.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for(var a = 0; a < this.children.length; a++)this.children[a].updateTransform();
    }, c53.Stage.prototype.checkVisibility = function() {
        void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
        var a = this;
        this._onChange = function(b) {
            return a.visibilityChange(b);
        }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
            c53.Stage.prototype.visibilityChange.call(a, {
                type: "pause"
            });
        }), CocoonJS.App.onActivated.addEventListener(function() {
            c53.Stage.prototype.visibilityChange.call(a, {
                type: "resume"
            });
        }));
    }, c53.Stage.prototype.visibilityChange = function(a) {
        if ("pagehide" === a.type || "blur" === a.type || "pageshow" === a.type || "focus" === a.type) return void ("pagehide" === a.type || "blur" === a.type ? this.game.focusLoss(a) : "pageshow" !== a.type && "focus" !== a.type || this.game.focusGain(a));
        this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === a.type ? this.game.gamePaused(a) : this.game.gameResumed(a));
    }, c53.Stage.prototype.setBackgroundColor = function(a) {
        this.game.transparent || (c53.Color.valueToColor(a, this._bgColor), c53.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1);
    }, c53.Stage.prototype.destroy = function() {
        this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null;
    }, Object.defineProperty(c53.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._bgColor.color;
        },
        set: function(a) {
            this.setBackgroundColor(a);
        }
    }), Object.defineProperty(c53.Stage.prototype, "smoothed", {
        get: function() {
            return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR;
        },
        set: function(a) {
            PIXI.scaleModes.DEFAULT = a ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST;
        }
    }), c53.Group = function(a, b, d, e, f, g) {
        void 0 === e && (e = !1), void 0 === f && (f = !1), void 0 === g && (g = c53.Physics.ARCADE), this.game = a, void 0 === b && (b = a.world), this.name = d || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), e ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : b && (b.addChild(this), this.z = b.children.length), this.type = c53.GROUP, this.physicsType = c53.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = c53.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.updateOnlyExistingChildren = !1, this.onChildInputDown = new c53.Signal, this.onChildInputUp = new c53.Signal, this.onChildInputOver = new c53.Signal, this.onChildInputOut = new c53.Signal, this.enableBody = f, this.enableBodyDebug = !1, this.physicsBodyType = g, this.physicsSortDirection = null, this.onDestroy = new c53.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new c53.Point, this.hash = [], this._sortProperty = "z";
    }, c53.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c53.Group.prototype.constructor = c53.Group, c53.Group.RETURN_NONE = 0, c53.Group.RETURN_TOTAL = 1, c53.Group.RETURN_CHILD = 2, c53.Group.RETURN_ALL = 3, c53.Group.SORT_ASCENDING = -1, c53.Group.SORT_DESCENDING = 1, c53.Group.prototype.add = function(a, b, c) {
        return void 0 === b && (b = !1), a.parent === this ? a : (a.body && a.parent && a.parent.hash && a.parent.removeFromHash(a), void 0 === c ? (a.z = this.children.length, this.addChild(a)) : (this.addChildAt(a, c), this.updateZ()), this.enableBody && a.hasOwnProperty("body") && null === a.body ? this.game.physics.enable(a, this.physicsBodyType) : a.body && this.addToHash(a), !this.inputEnableChildren || a.input && !a.inputEnabled || (a.inputEnabled = !0), !b && a.events && a.events.onAddedToGroup$dispatch(a, this), null === this.cursor && (this.cursor = a), a);
    }, c53.Group.prototype.addAt = function(a, b, c) {
        return this.add(a, c, b);
    }, c53.Group.prototype.addToHash = function(a) {
        if (a.parent === this) {
            if (-1 === this.hash.indexOf(a)) return this.hash.push(a), !0;
        }
        return !1;
    }, c53.Group.prototype.removeFromHash = function(a) {
        if (a) {
            var b = this.hash.indexOf(a);
            if (-1 !== b) return this.hash.splice(b, 1), !0;
        }
        return !1;
    }, c53.Group.prototype.addMultiple = function(a, b) {
        if (a instanceof c53.Group) a.moveAll(this, b);
        else if (Array.isArray(a)) for(var d = 0; d < a.length; d++)this.add(a[d], b);
        return a;
    }, c53.Group.prototype.getAt = function(a) {
        return a < 0 || a >= this.children.length ? -1 : this.getChildAt(a);
    }, c53.Group.prototype.create = function(a, b, c, d, e, f) {
        void 0 === e && (e = !0);
        var g = new this.classType(this.game, a, b, c, d);
        return g.exists = e, g.visible = e, g.alive = e, this.add(g, !1, f);
    };
    c53.Group.prototype.createMultiple = function(a, b57, c54, d) {
        void 0 === c54 && (c54 = 0), void 0 === d && (d = !1), Array.isArray(b57) || (b57 = [
            b57
        ]), Array.isArray(c54) || (c54 = [
            c54
        ]);
        var e = this, f = [];
        return b57.forEach(function(b) {
            c54.forEach(function(c) {
                for(var g = 0; g < a; g++)f.push(e.create(0, 0, b, c, d));
            });
        }), f;
    }, c53.Group.prototype.updateZ = function() {
        for(var a = this.children.length; a--;)this.children[a].z = a;
    }, c53.Group.prototype.align = function(a, b, d, e, f, g) {
        if (void 0 === f && (f = c53.TOP_LEFT), void 0 === g && (g = 0), 0 === this.children.length || g > this.children.length || -1 === a && -1 === b) return !1;
        for(var h = new c53.Rectangle(0, 0, d, e), i = a * d, j = b * e, k = g; k < this.children.length; k++){
            var l = this.children[k];
            if (l.alignIn) {
                if (l.alignIn(h, f), -1 === a) h.y += e, h.y === j && (h.x += d, h.y = 0);
                else if (-1 === b) h.x += d, h.x === i && (h.x = 0, h.y += e);
                else if (h.x += d, h.x === i && (h.x = 0, h.y += e, h.y === j)) return !0;
            }
        }
        return !0;
    }, c53.Group.prototype.resetCursor = function(a) {
        if (void 0 === a && (a = 0), a > this.children.length - 1 && (a = 0), this.cursor) return this.cursorIndex = a, this.cursor = this.children[this.cursorIndex], this.cursor;
    }, c53.Group.prototype.next = function() {
        if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor;
    }, c53.Group.prototype.previous = function() {
        if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor;
    }, c53.Group.prototype.swap = function(a, b) {
        this.swapChildren(a, b), this.updateZ();
    }, c53.Group.prototype.bringToTop = function(a) {
        return a.parent === this && this.getIndex(a) < this.children.length && (this.remove(a, !1, !0), this.add(a, !0)), a;
    }, c53.Group.prototype.sendToBack = function(a) {
        return a.parent === this && this.getIndex(a) > 0 && (this.remove(a, !1, !0), this.addAt(a, 0, !0)), a;
    }, c53.Group.prototype.moveUp = function(a) {
        if (a.parent === this && this.getIndex(a) < this.children.length - 1) {
            var b = this.getIndex(a), c = this.getAt(b + 1);
            c && this.swap(a, c);
        }
        return a;
    }, c53.Group.prototype.moveDown = function(a) {
        if (a.parent === this && this.getIndex(a) > 0) {
            var b = this.getIndex(a), c = this.getAt(b - 1);
            c && this.swap(a, c);
        }
        return a;
    }, c53.Group.prototype.xy = function(a, b, c) {
        if (a < 0 || a > this.children.length) return -1;
        this.getChildAt(a).x = b, this.getChildAt(a).y = c;
    }, c53.Group.prototype.reverse = function() {
        this.children.reverse(), this.updateZ();
    }, c53.Group.prototype.getIndex = function(a) {
        return this.children.indexOf(a);
    }, c53.Group.prototype.getByName = function(a) {
        for(var b = 0; b < this.children.length; b++)if (this.children[b].name === a) return this.children[b];
        return null;
    }, c53.Group.prototype.replace = function(a, b) {
        var d = this.getIndex(a);
        if (-1 !== d) return b.parent && (b.parent instanceof c53.Group ? b.parent.remove(b) : b.parent.removeChild(b)), this.remove(a), this.addAt(b, d), a;
    }, c53.Group.prototype.hasProperty = function(a, b) {
        var c = b.length;
        return 1 === c && b[0] in a || 2 === c && b[0] in a && b[1] in a[b[0]] || 3 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] || 4 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] && b[3] in a[b[0]][b[1]][b[2]];
    }, c53.Group.prototype.setProperty = function(a, b, c, d, e) {
        if (void 0 === e && (e = !1), d = d || 0, !this.hasProperty(a, b) && (!e || d > 0)) return !1;
        var f = b.length;
        return 1 === f ? 0 === d ? a[b[0]] = c : 1 === d ? a[b[0]] += c : 2 === d ? a[b[0]] -= c : 3 === d ? a[b[0]] *= c : 4 === d && (a[b[0]] /= c) : 2 === f ? 0 === d ? a[b[0]][b[1]] = c : 1 === d ? a[b[0]][b[1]] += c : 2 === d ? a[b[0]][b[1]] -= c : 3 === d ? a[b[0]][b[1]] *= c : 4 === d && (a[b[0]][b[1]] /= c) : 3 === f ? 0 === d ? a[b[0]][b[1]][b[2]] = c : 1 === d ? a[b[0]][b[1]][b[2]] += c : 2 === d ? a[b[0]][b[1]][b[2]] -= c : 3 === d ? a[b[0]][b[1]][b[2]] *= c : 4 === d && (a[b[0]][b[1]][b[2]] /= c) : 4 === f && (0 === d ? a[b[0]][b[1]][b[2]][b[3]] = c : 1 === d ? a[b[0]][b[1]][b[2]][b[3]] += c : 2 === d ? a[b[0]][b[1]][b[2]][b[3]] -= c : 3 === d ? a[b[0]][b[1]][b[2]][b[3]] *= c : 4 === d && (a[b[0]][b[1]][b[2]][b[3]] /= c)), !0;
    }, c53.Group.prototype.checkProperty = function(a, b, d, e) {
        if (void 0 === e && (e = !1), this !== a.parent) return !1;
        var f = c53.Utils.getProperty(a, b);
        return !(void 0 === f && e || f !== d);
    }, c53.Group.prototype.set = function(a, b, c, d, e, f, g) {
        if (void 0 === g && (g = !1), b = b.split("."), void 0 === d && (d = !1), void 0 === e && (e = !1), (!1 === d || d && a.alive) && (!1 === e || e && a.visible)) return this.setProperty(a, b, c, f, g);
    }, c53.Group.prototype.setAll = function(a, b, c, d, e, f) {
        void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === f && (f = !1), a = a.split("."), e = e || 0;
        for(var g = 0; g < this.children.length; g++)(!c || c && this.children[g].alive) && (!d || d && this.children[g].visible) && this.setProperty(this.children[g], a, b, e, f);
    }, c53.Group.prototype.setAllChildren = function(a, b, d, e, f, g) {
        void 0 === d && (d = !1), void 0 === e && (e = !1), void 0 === g && (g = !1), f = f || 0;
        for(var h = 0; h < this.children.length; h++)(!d || d && this.children[h].alive) && (!e || e && this.children[h].visible) && (this.children[h] instanceof c53.Group ? this.children[h].setAllChildren(a, b, d, e, f, g) : this.setProperty(this.children[h], a.split("."), b, f, g));
    }, c53.Group.prototype.checkAll = function(a, b, c, d, e) {
        void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === e && (e = !1);
        for(var f = 0; f < this.children.length; f++){
            var g = this.children[f];
            if ((!c || c && g.alive) && (!d || d && g.visible) && !this.checkProperty(g, a, b, e)) return !1;
        }
        return !0;
    }, c53.Group.prototype.checkAny = function(a, b, c, d) {
        void 0 === c && (c = !1), void 0 === d && (d = !1);
        for(var e = 0; e < this.children.length; e++){
            var f = this.children[e];
            if ((!c || c && f.alive) && (!d || d && f.visible) && this.checkProperty(f, a, b)) return !0;
        }
        return !1;
    }, c53.Group.prototype.addAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 1);
    }, c53.Group.prototype.subAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 2);
    }, c53.Group.prototype.multiplyAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 3);
    }, c53.Group.prototype.divideAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 4);
    }, c53.Group.prototype.killAll = function() {
        this.callAllExists("kill", !0);
    }, c53.Group.prototype.reviveAll = function() {
        this.callAllExists("revive", !1);
    }, c53.Group.prototype.resetAll = function(a, b, c, d, e) {
        this.forEach(this.resetChild, this, e, a, b, c, d);
    }, c53.Group.prototype.callAllExists = function(a, b) {
        var c;
        if (arguments.length > 2) {
            c = [];
            for(var d = 2; d < arguments.length; d++)c.push(arguments[d]);
        }
        for(var d = 0; d < this.children.length; d++)this.children[d].exists === b && this.children[d][a] && this.children[d][a].apply(this.children[d], c);
    }, c53.Group.prototype.callbackFromArray = function(a, b, c) {
        if (1 === c) {
            if (a[b[0]]) return a[b[0]];
        } else if (2 === c) {
            if (a[b[0]][b[1]]) return a[b[0]][b[1]];
        } else if (3 === c) {
            if (a[b[0]][b[1]][b[2]]) return a[b[0]][b[1]][b[2]];
        } else if (4 === c) {
            if (a[b[0]][b[1]][b[2]][b[3]]) return a[b[0]][b[1]][b[2]][b[3]];
        } else if (a[b]) return a[b];
        return !1;
    }, c53.Group.prototype.callAll = function(a, b) {
        if (void 0 !== a) {
            a = a.split(".");
            var c = a.length;
            if (void 0 === b || null === b || "" === b) b = null;
            else if ("string" == typeof b) {
                b = b.split(".");
                var d = b.length;
            }
            var e;
            if (arguments.length > 2) {
                e = [];
                for(var f = 2; f < arguments.length; f++)e.push(arguments[f]);
            }
            for(var g = null, h = null, f = 0; f < this.children.length; f++)g = this.callbackFromArray(this.children[f], a, c), b && g ? (h = this.callbackFromArray(this.children[f], b, d), g && g.apply(h, e)) : g && g.apply(this.children[f], e);
        }
    }, c53.Group.prototype.preUpdate = function() {
        if (this.pendingDestroy) return this.destroy(), !1;
        if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
        for(var a = 0; a < this.children.length;){
            var b = this.children[a];
            b.preUpdate(), this === b.parent && a++;
        }
        return !0;
    }, c53.Group.prototype.update = function() {
        for(var a = this.children.length; a--;){
            var b = this.children.length;
            a >= b && (a = b - 1);
            var c = this.children[a];
            this.updateOnlyExistingChildren && !c.exists || c.update();
        }
    }, c53.Group.prototype.postUpdate = function() {
        this.fixedToCamera && (this.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
        for(var a = 0; a < this.children.length; a++)this.children[a].postUpdate();
    }, c53.Group.prototype.filter = function(a, b) {
        for(var d = -1, e = this.children.length, f = []; ++d < e;){
            var g = this.children[d];
            (!b || b && g.exists) && a(g, d, this.children) && f.push(g);
        }
        return new c53.ArraySet(f);
    }, c53.Group.prototype.forEach = function(a, b, c) {
        if (void 0 === c && (c = !1), arguments.length <= 3) for(var d = 0; d < this.children.length; d++)(!c || c && this.children[d].exists) && a.call(b, this.children[d]);
        else {
            for(var e = [
                null
            ], d = 3; d < arguments.length; d++)e.push(arguments[d]);
            for(var d = 0; d < this.children.length; d++)(!c || c && this.children[d].exists) && (e[0] = this.children[d], a.apply(b, e));
        }
    }, c53.Group.prototype.forEachExists = function(a, b) {
        var d;
        if (arguments.length > 2) {
            d = [
                null
            ];
            for(var e = 2; e < arguments.length; e++)d.push(arguments[e]);
        }
        this.iterate("exists", !0, c53.Group.RETURN_TOTAL, a, b, d);
    }, c53.Group.prototype.forEachAlive = function(a, b) {
        var d;
        if (arguments.length > 2) {
            d = [
                null
            ];
            for(var e = 2; e < arguments.length; e++)d.push(arguments[e]);
        }
        this.iterate("alive", !0, c53.Group.RETURN_TOTAL, a, b, d);
    }, c53.Group.prototype.forEachDead = function(a, b) {
        var d;
        if (arguments.length > 2) {
            d = [
                null
            ];
            for(var e = 2; e < arguments.length; e++)d.push(arguments[e]);
        }
        this.iterate("alive", !1, c53.Group.RETURN_TOTAL, a, b, d);
    }, c53.Group.prototype.sort = function(a, b) {
        this.children.length < 2 || (void 0 === a && (a = "z"), void 0 === b && (b = c53.Group.SORT_ASCENDING), this._sortProperty = a, b === c53.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ());
    }, c53.Group.prototype.customSort = function(a, b) {
        this.children.length < 2 || (this.children.sort(a.bind(b)), this.updateZ());
    }, c53.Group.prototype.ascendingSortHandler = function(a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1;
    }, c53.Group.prototype.descendingSortHandler = function(a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0;
    }, c53.Group.prototype.iterate = function(a, b, d, e, f, g) {
        if (0 === this.children.length) {
            if (d === c53.Group.RETURN_TOTAL) return 0;
            if (d === c53.Group.RETURN_ALL) return [];
        }
        var h = 0;
        if (d === c53.Group.RETURN_ALL) var i = [];
        for(var j = 0; j < this.children.length; j++)if (this.children[j][a] === b) {
            if (h++, e && (g ? (g[0] = this.children[j], e.apply(f, g)) : e.call(f, this.children[j])), d === c53.Group.RETURN_CHILD) return this.children[j];
            d === c53.Group.RETURN_ALL && i.push(this.children[j]);
        }
        return d === c53.Group.RETURN_TOTAL ? h : d === c53.Group.RETURN_ALL ? i : null;
    }, c53.Group.prototype.getFirstExists = function(a, b, d, e, f, g) {
        void 0 === b && (b = !1), "boolean" != typeof a && (a = !0);
        var h = this.iterate("exists", a, c53.Group.RETURN_CHILD);
        return null === h && b ? this.create(d, e, f, g) : this.resetChild(h, d, e, f, g);
    }, c53.Group.prototype.getFirstAlive = function(a, b, d, e, f) {
        void 0 === a && (a = !1);
        var g = this.iterate("alive", !0, c53.Group.RETURN_CHILD);
        return null === g && a ? this.create(b, d, e, f) : this.resetChild(g, b, d, e, f);
    }, c53.Group.prototype.getFirstDead = function(a, b, d, e, f) {
        void 0 === a && (a = !1);
        var g = this.iterate("alive", !1, c53.Group.RETURN_CHILD);
        return null === g && a ? this.create(b, d, e, f) : this.resetChild(g, b, d, e, f);
    }, c53.Group.prototype.resetChild = function(a, b, c, d, e) {
        return null === a ? null : (void 0 === b && (b = null), void 0 === c && (c = null), null !== b && null !== c && a.reset(b, c), void 0 !== d && a.loadTexture(d, e), a);
    }, c53.Group.prototype.getTop = function() {
        if (this.children.length > 0) return this.children[this.children.length - 1];
    }, c53.Group.prototype.getBottom = function() {
        if (this.children.length > 0) return this.children[0];
    }, c53.Group.prototype.getClosestTo = function(a, b, d) {
        for(var e = Number.MAX_VALUE, f = 0, g = null, h = 0; h < this.children.length; h++){
            var i = this.children[h];
            i.exists && (f = Math.abs(c53.Point.distance(a, i))) < e && (!b || b.call(d, i, f)) && (e = f, g = i);
        }
        return g;
    }, c53.Group.prototype.getFurthestFrom = function(a, b, d) {
        for(var e = 0, f = 0, g = null, h = 0; h < this.children.length; h++){
            var i = this.children[h];
            i.exists && (f = Math.abs(c53.Point.distance(a, i))) > e && (!b || b.call(d, i, f)) && (e = f, g = i);
        }
        return g;
    }, c53.Group.prototype.countLiving = function() {
        return this.iterate("alive", !0, c53.Group.RETURN_TOTAL);
    }, c53.Group.prototype.countDead = function() {
        return this.iterate("alive", !1, c53.Group.RETURN_TOTAL);
    }, c53.Group.prototype.getRandom = function(a, b) {
        return void 0 === a && (a = 0), void 0 === b && (b = this.children.length), 0 === b ? null : c53.ArrayUtils.getRandomItem(this.children, a, b);
    }, c53.Group.prototype.getRandomExists = function(a, b) {
        var c = this.getAll("exists", !0, a, b);
        return this.game.rnd.pick(c);
    }, c53.Group.prototype.getAll = function(a, b, c, d) {
        void 0 === c && (c = 0), void 0 === d && (d = this.children.length);
        for(var e = [], f = c; f < d; f++){
            var g = this.children[f];
            a ? g[a] === b && e.push(g) : e.push(g);
        }
        return e;
    }, c53.Group.prototype.remove = function(a, b, c) {
        if (void 0 === b && (b = !1), void 0 === c && (c = !1), 0 === this.children.length || -1 === this.children.indexOf(a)) return !1;
        c || !a.events || a.destroyPhase || a.events.onRemovedFromGroup$dispatch(a, this);
        var d = this.removeChild(a);
        return this.removeFromHash(a), this.updateZ(), this.cursor === a && this.next(), b && d && d.destroy(!0), !0;
    }, c53.Group.prototype.moveAll = function(a, b) {
        if (void 0 === b && (b = !1), this.children.length > 0 && a instanceof c53.Group) {
            do a.add(this.children[0], b);
            while (this.children.length > 0)
            this.hash = [], this.cursor = null;
        }
        return a;
    }, c53.Group.prototype.removeAll = function(a, b, c) {
        if (void 0 === a && (a = !1), void 0 === b && (b = !1), void 0 === c && (c = !1), 0 !== this.children.length) {
            do {
                !b && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                var d = this.removeChild(this.children[0]);
                this.removeFromHash(d), a && d && d.destroy(!0, c);
            }while (this.children.length > 0)
            this.hash = [], this.cursor = null;
        }
    }, c53.Group.prototype.removeBetween = function(a, b, c, d) {
        if (void 0 === b && (b = this.children.length - 1), void 0 === c && (c = !1), void 0 === d && (d = !1), 0 !== this.children.length) {
            if (a > b || a < 0 || b > this.children.length) return !1;
            for(var e = b; e >= a;){
                !d && this.children[e].events && this.children[e].events.onRemovedFromGroup$dispatch(this.children[e], this);
                var f = this.removeChild(this.children[e]);
                this.removeFromHash(f), c && f && f.destroy(!0), this.cursor === this.children[e] && (this.cursor = null), e--;
            }
            this.updateZ();
        }
    }, c53.Group.prototype.scatter = function(a, b58) {
        null == a && (a = this.game.world.bounds), this.forEach(function(b) {
            b.position.set(a.randomX, a.randomY);
        }, null, b58);
    }, c53.Group.prototype.shuffle = function() {
        c53.ArrayUtils.shuffle(this.children), this.updateZ();
    }, c53.Group.prototype.destroy = function(a, b) {
        null === this.game || this.ignoreDestroy || (void 0 === a && (a = !0), void 0 === b && (b = !1), this.onDestroy.dispatch(this, a, b), this.removeAll(a), this.cursor = null, this.filters = null, this.pendingDestroy = !1, b || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1));
    }, Object.defineProperty(c53.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", !0, c53.Group.RETURN_TOTAL);
        }
    }), Object.defineProperty(c53.Group.prototype, "length", {
        get: function() {
            return this.children.length;
        }
    }), Object.defineProperty(c53.Group.prototype, "angle", {
        get: function() {
            return c53.Math.radToDeg(this.rotation);
        },
        set: function(a) {
            this.rotation = c53.Math.degToRad(a);
        }
    }), Object.defineProperty(c53.Group.prototype, "centerX", {
        get: function() {
            return this.getBounds(this.parent).centerX;
        },
        set: function(a) {
            var b = this.getBounds(this.parent), c = this.x - b.x;
            this.x = a + c - b.halfWidth;
        }
    }), Object.defineProperty(c53.Group.prototype, "centerY", {
        get: function() {
            return this.getBounds(this.parent).centerY;
        },
        set: function(a) {
            var b = this.getBounds(this.parent), c = this.y - b.y;
            this.y = a + c - b.halfHeight;
        }
    }), Object.defineProperty(c53.Group.prototype, "left", {
        get: function() {
            return this.getBounds(this.parent).left;
        },
        set: function(a) {
            var b = this.getBounds(this.parent), c = this.x - b.x;
            this.x = a + c;
        }
    }), Object.defineProperty(c53.Group.prototype, "right", {
        get: function() {
            return this.getBounds(this.parent).right;
        },
        set: function(a) {
            var b = this.getBounds(this.parent), c = this.x - b.x;
            this.x = a + c - b.width;
        }
    }), Object.defineProperty(c53.Group.prototype, "top", {
        get: function() {
            return this.getBounds(this.parent).top;
        },
        set: function(a) {
            var b = this.getBounds(this.parent), c = this.y - b.y;
            this.y = a + c;
        }
    }), Object.defineProperty(c53.Group.prototype, "bottom", {
        get: function() {
            return this.getBounds(this.parent).bottom;
        },
        set: function(a) {
            var b = this.getBounds(this.parent), c = this.y - b.y;
            this.y = a + c - b.height;
        }
    }), c53.World = function(a) {
        c53.Group.call(this, a, null, "__world", !1), this.bounds = new c53.Rectangle(0, 0, a.width, a.height), this.camera = null, this._definedSize = !1, this._width = a.width, this._height = a.height, this.game.state.onStateChange.add(this.stateChange, this);
    }, c53.World.prototype = Object.create(c53.Group.prototype), c53.World.prototype.constructor = c53.World, c53.World.prototype.boot = function() {
        this.camera = new c53.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot();
    }, c53.World.prototype.stateChange = function() {
        this.x = 0, this.y = 0, this.camera.reset();
    }, c53.World.prototype.setBounds = function(a, b, c, d) {
        this._definedSize = !0, this._width = c, this._height = d, this.bounds.setTo(a, b, c, d), this.x = a, this.y = b, this.camera.bounds && this.camera.bounds.setTo(a, b, Math.max(c, this.game.width), Math.max(d, this.game.height)), this.game.physics.setBoundsToWorld();
    }, c53.World.prototype.resize = function(a, b) {
        this._definedSize && (a < this._width && (a = this._width), b < this._height && (b = this._height)), this.bounds.width = a, this.bounds.height = b, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld();
    }, c53.World.prototype.shutdown = function() {
        this.destroy(!0, !0);
    }, c53.World.prototype.wrap = function(a, b, c, d, e) {
        void 0 === b && (b = 0), void 0 === c && (c = !1), void 0 === d && (d = !0), void 0 === e && (e = !0), c ? (a.getBounds(), d && (a.x + a._currentBounds.width < this.bounds.x ? a.x = this.bounds.right : a.x > this.bounds.right && (a.x = this.bounds.left)), e && (a.y + a._currentBounds.height < this.bounds.top ? a.y = this.bounds.bottom : a.y > this.bounds.bottom && (a.y = this.bounds.top))) : (d && a.x + b < this.bounds.x ? a.x = this.bounds.right + b : d && a.x - b > this.bounds.right && (a.x = this.bounds.left - b), e && a.y + b < this.bounds.top ? a.y = this.bounds.bottom + b : e && a.y - b > this.bounds.bottom && (a.y = this.bounds.top - b));
    }, Object.defineProperty(c53.World.prototype, "width", {
        get: function() {
            return this.bounds.width;
        },
        set: function(a) {
            a < this.game.width && (a = this.game.width), this.bounds.width = a, this._width = a, this._definedSize = !0;
        }
    }), Object.defineProperty(c53.World.prototype, "height", {
        get: function() {
            return this.bounds.height;
        },
        set: function(a) {
            a < this.game.height && (a = this.game.height), this.bounds.height = a, this._height = a, this._definedSize = !0;
        }
    }), Object.defineProperty(c53.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth + this.bounds.x;
        }
    }), Object.defineProperty(c53.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight + this.bounds.y;
        }
    }), Object.defineProperty(c53.World.prototype, "randomX", {
        get: function() {
            return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width);
        }
    }), Object.defineProperty(c53.World.prototype, "randomY", {
        get: function() {
            return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height);
        }
    }), c53.Game = function(a, b, d, e, f, g, h, i) {
        return this.id = c53.GAMES.push(this) - 1, this.config = null, this.physicsConfig = i, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.multiTexture = !1, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = c53.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = c53.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new c53.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
            enableDebug: !0
        }, void 0 !== a && (this._width = a), void 0 !== b && (this._height = b), void 0 !== d && (this.renderType = d), void 0 !== e && (this.parent = e), void 0 !== g && (this.transparent = g), void 0 !== h && (this.antialias = h), this.rnd = new c53.RandomDataGenerator([
            (Date.now() * Math.random()).toString()
        ]), this.state = new c53.StateManager(this, f)), this.device.whenReady(this.boot, this), this;
    }, c53.Game.prototype = {
        parseConfig: function(a) {
            this.config = a, void 0 === a.enableDebug && (this.config.enableDebug = !0), a.width && (this._width = a.width), a.height && (this._height = a.height), a.renderer && (this.renderType = a.renderer), a.parent && (this.parent = a.parent), void 0 !== a.transparent && (this.transparent = a.transparent), void 0 !== a.antialias && (this.antialias = a.antialias), void 0 !== a.multiTexture && (this.multiTexture = a.multiTexture), a.resolution && (this.resolution = a.resolution), void 0 !== a.preserveDrawingBuffer && (this.preserveDrawingBuffer = a.preserveDrawingBuffer), a.physicsConfig && (this.physicsConfig = a.physicsConfig);
            var b = [
                (Date.now() * Math.random()).toString()
            ];
            a.seed && (b = a.seed), this.rnd = new c53.RandomDataGenerator(b);
            var d = null;
            a.state && (d = a.state), this.state = new c53.StateManager(this, d);
        },
        boot: function() {
            this.isBooted || (this.onPause = new c53.Signal, this.onResume = new c53.Signal, this.onBlur = new c53.Signal, this.onFocus = new c53.Signal, this.isBooted = !0, PIXI.game = this, this.math = c53.Math, this.scale = new c53.ScaleManager(this, this._width, this._height), this.stage = new c53.Stage(this), this.setUpRenderer(), this.world = new c53.World(this), this.add = new c53.GameObjectFactory(this), this.make = new c53.GameObjectCreator(this), this.cache = new c53.Cache(this), this.load = new c53.Loader(this), this.time = new c53.Time(this), this.tweens = new c53.TweenManager(this), this.input = new c53.Input(this), this.sound = new c53.SoundManager(this), this.physics = new c53.Physics(this, this.physicsConfig), this.particles = new c53.Particles(this), this.create = new c53.Create(this), this.plugins = new c53.PluginManager(this), this.net = new c53.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new c53.Utils.Debug(this), this.debug.boot()) : this.debug = {
                preUpdate: function() {},
                update: function() {},
                reset: function() {},
                isDisabled: !0
            }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new c53.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new c53.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start());
        },
        showDebugHeader: function() {
            if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                var a = c53.VERSION, b = "Canvas", d = "HTML Audio", e = 1;
                if (this.renderType === c53.WEBGL ? (b = "WebGL", e++) : this.renderType === c53.HEADLESS && (b = "Headless"), this.device.webAudio && (d = "WebAudio", e++), this.device.chrome) {
                    for(var f = [
                        "%c %c %c Phaser CE v" + a + " | Pixi.js | " + b + " | " + d + "  %c %c %c http://phaser.io %c%c%c",
                        "background: #fb8cb3",
                        "background: #d44a52",
                        "color: #ffffff; background: #871905;",
                        "background: #d44a52",
                        "background: #fb8cb3",
                        "background: #ffffff"
                    ], g = 0; g < 3; g++)g < e ? f.push("color: #ff2424; background: #fff") : f.push("color: #959595; background: #fff");
                    console.log.apply(console, f);
                } else window.console && console.log("Phaser v" + a + " | Pixi.js | " + b + " | " + d + " | http://phaser.io");
            }
        },
        setUpRenderer: function() {
            if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = c53.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === c53.HEADLESS || this.renderType === c53.CANVAS || this.renderType === c53.AUTO && !this.device.webGL) {
                if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context, this.renderType === c53.AUTO && (this.renderType = c53.CANVAS);
            } else (this.multiTexture || this.renderType === c53.WEBGL_MULTI) && (PIXI.enableMultiTexture(), this.multiTexture = !0), this.renderType = c53.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
            this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === c53.CANVAS), this.renderType !== c53.HEADLESS && (this.stage.smoothed = this.antialias, c53.Canvas.addToDOM(this.canvas, this.parent, !1), c53.Canvas.setTouchAction(this.canvas));
        },
        contextLost: function(a) {
            a.preventDefault(), this.renderer.contextLost = !0;
        },
        contextRestored: function() {
            this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1;
        },
        update: function(a) {
            if (this.time.update(a), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void (this._kickstart = !1);
            if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 10000, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
            else {
                var b = 1000 * this.time.slowMotion / this.time.desiredFps;
                this._deltaTime += Math.max(Math.min(3 * b, this.time.elapsed), 0);
                var c = 0;
                for(this.updatesThisFrame = Math.floor(this._deltaTime / b), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= b && (this._deltaTime -= b, this.currentUpdateID = c, this.updateLogic(this.time.desiredFpsMult), c++, !this.forceSingleUpdate || 1 !== c);)this.time.refresh();
                c > this._lastCount ? this._spiraling++ : c < this._lastCount && (this._spiraling = 0), this._lastCount = c, this.updateRender(this._deltaTime / b);
            }
        },
        updateLogic: function(a) {
            this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(a), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(a), this.plugins.preUpdate(a), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform();
        },
        updateRender: function(a) {
            this.lockRender || (this.state.preRender(a), this.renderType !== c53.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(a), this.state.render(a)), this.plugins.postRender(a));
        },
        enableStep: function() {
            this.stepping = !0, this.pendingStep = !1, this.stepCount = 0;
        },
        disableStep: function() {
            this.stepping = !1, this.pendingStep = !1;
        },
        step: function() {
            this.pendingStep = !1, this.stepCount++;
        },
        destroy: function() {
            this.raf.stop(), this.debug.destroy && this.debug.destroy(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.debug = null, this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), c53.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, c53.GAMES[this.id] = null;
        },
        gamePaused: function(a) {
            this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !0));
        },
        gameResumed: function(a) {
            this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !1));
        },
        focusLoss: function(a) {
            this.onBlur.dispatch(a), this.stage.disableVisibilityChange || this.gamePaused(a);
        },
        focusGain: function(a) {
            this.onFocus.dispatch(a), this.stage.disableVisibilityChange || this.gameResumed(a);
        }
    }, c53.Game.prototype.constructor = c53.Game, Object.defineProperty(c53.Game.prototype, "paused", {
        get: function() {
            return this._paused;
        },
        set: function(a) {
            !0 === a ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1);
        }
    }), c53.Input = function(a) {
        this.game = a, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = c53.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2000, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new c53.ArraySet, this._localPoint = new c53.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0;
    }, c53.Input.MOUSE_OVERRIDES_TOUCH = 0, c53.Input.TOUCH_OVERRIDES_MOUSE = 1, c53.Input.MOUSE_TOUCH_COMBINE = 2, c53.Input.MAX_POINTERS = 10, c53.Input.prototype = {
        boot: function() {
            this.mousePointer = new c53.Pointer(this.game, 0, c53.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new c53.Mouse(this.game), this.touch = new c53.Touch(this.game), this.mspointer = new c53.MSPointer(this.game), c53.Keyboard && (this.keyboard = new c53.Keyboard(this.game)), c53.Gamepad && (this.gamepad = new c53.Gamepad(this.game)), this.onDown = new c53.Signal, this.onUp = new c53.Signal, this.onTap = new c53.Signal, this.onHold = new c53.Signal, this.scale = new c53.Point(1, 1), this.speed = new c53.Point, this.position = new c53.Point, this._oldPosition = new c53.Point, this.circle = new c53.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = c53.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.game.device.mspointer || this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
            var a = this;
            this._onClickTrampoline = function(b) {
                a.onClickTrampoline(b);
            }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1);
        },
        destroy: function() {
            this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], c53.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline);
        },
        setInteractiveCandidateHandler: function(a, b) {
            this.customCandidateHandler = a, this.customCandidateHandlerContext = b;
        },
        addMoveCallback: function(a, b) {
            this.moveCallbacks.push({
                callback: a,
                context: b
            });
        },
        deleteMoveCallback: function(a, b) {
            for(var c = this.moveCallbacks.length; c--;)if (this.moveCallbacks[c].callback === a && this.moveCallbacks[c].context === b) return void this.moveCallbacks.splice(c, 1);
        },
        addPointer: function() {
            if (this.pointers.length >= c53.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + c53.Input.MAX_POINTERS + " pointers reached."), null;
            var a = this.pointers.length + 1, b = new c53.Pointer(this.game, a, c53.PointerMode.TOUCH);
            return this.pointers.push(b), this["pointer" + a] = b, b;
        },
        update: function() {
            if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) return void this._pollCounter++;
            this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
            for(var a = 0; a < this.pointers.length; a++)this.pointers[a].update();
            this._pollCounter = 0;
        },
        reset: function(a) {
            if (this.game.isBooted && !this.resetLocked) {
                void 0 === a && (a = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(a), this.gamepad && this.gamepad.reset();
                for(var b = 0; b < this.pointers.length; b++)this.pointers[b].reset();
                "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = ""), a && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new c53.Signal, this.onUp = new c53.Signal, this.onTap = new c53.Signal, this.onHold = new c53.Signal, this.moveCallbacks = []), this._pollCounter = 0;
            }
        },
        resetSpeed: function(a, b) {
            this._oldPosition.setTo(a, b), this.speed.setTo(0, 0);
        },
        startPointer: function(a) {
            if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
            if (!this.pointer1.active) return this.pointer1.start(a);
            if (!this.pointer2.active) return this.pointer2.start(a);
            for(var b = 2; b < this.pointers.length; b++){
                var c = this.pointers[b];
                if (!c.active) return c.start(a);
            }
            return null;
        },
        updatePointer: function(a) {
            if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.move(a);
            if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.move(a);
            for(var b = 2; b < this.pointers.length; b++){
                var c = this.pointers[b];
                if (c.active && c.identifier === a.identifier) return c.move(a);
            }
            return null;
        },
        stopPointer: function(a) {
            if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.stop(a);
            if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.stop(a);
            for(var b = 2; b < this.pointers.length; b++){
                var c = this.pointers[b];
                if (c.active && c.identifier === a.identifier) return c.stop(a);
            }
            return null;
        },
        countActivePointers: function(a) {
            void 0 === a && (a = this.pointers.length);
            for(var b = a, c = 0; c < this.pointers.length && b > 0; c++)this.pointers[c].active && b--;
            return a - b;
        },
        getPointer: function(a) {
            void 0 === a && (a = !1);
            for(var b = 0; b < this.pointers.length; b++){
                var c = this.pointers[b];
                if (c.active === a) return c;
            }
            return null;
        },
        getPointerFromIdentifier: function(a) {
            for(var b = 0; b < this.pointers.length; b++){
                var c = this.pointers[b];
                if (c.identifier === a) return c;
            }
            return null;
        },
        getPointerFromId: function(a) {
            for(var b = 0; b < this.pointers.length; b++){
                var c = this.pointers[b];
                if (c.pointerId === a) return c;
            }
            return null;
        },
        getLocalPosition: function(a, b, d) {
            void 0 === d && (d = new c53.Point);
            var e = a.worldTransform, f = 1 / (e.a * e.d + e.c * -e.b);
            return d.setTo(e.d * f * b.x + -e.c * f * b.y + (e.ty * e.c - e.tx * e.d) * f, e.a * f * b.y + -e.b * f * b.x + (-e.ty * e.a + e.tx * e.b) * f);
        },
        hitTest: function(a, b, d) {
            if (!a.worldVisible) return !1;
            if (this.getLocalPosition(a, b, this._localPoint), d.copyFrom(this._localPoint), a.hitArea && a.hitArea.contains) return a.hitArea.contains(this._localPoint.x, this._localPoint.y);
            if (c53.Creature && a instanceof c53.Creature) {
                var e = Math.abs(a.width), f = Math.abs(a.height), g = a.x - e * a.anchorX;
                if (this.game.camera.x + b.x >= g && this.game.camera.x + b.x < g + e) {
                    var h = a.y - f * a.anchorY;
                    if (this.game.camera.y + b.y >= h && this.game.camera.y + b.y < h + f) return !0;
                }
            } else if (a instanceof c53.TileSprite) {
                var e = a.width, f = a.height, g = -e * a.anchor.x;
                if (this._localPoint.x >= g && this._localPoint.x < g + e) {
                    var h = -f * a.anchor.y;
                    if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0;
                }
            } else if (a instanceof PIXI.Sprite) {
                var e = a.texture.frame.width / a.texture.baseTexture.resolution, f = a.texture.frame.height / a.texture.baseTexture.resolution, g = -e * a.anchor.x;
                if (this._localPoint.x >= g && this._localPoint.x < g + e) {
                    var h = -f * a.anchor.y;
                    if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0;
                }
            } else if (a instanceof c53.Graphics) for(var i = 0; i < a.graphicsData.length; i++){
                var j = a.graphicsData[i];
                if (j.fill && j.shape && j.shape.contains(this._localPoint.x, this._localPoint.y)) return !0;
            }
            for(var i = 0; i < a.children.length; i++)if (this.hitTest(a.children[i], b, d)) return !0;
            return !1;
        },
        onClickTrampoline: function() {
            this.activePointer.processClickTrampolines();
        }
    }, c53.Input.prototype.constructor = c53.Input, Object.defineProperty(c53.Input.prototype, "x", {
        get: function() {
            return this._x;
        },
        set: function(a) {
            this._x = Math.floor(a);
        }
    }), Object.defineProperty(c53.Input.prototype, "y", {
        get: function() {
            return this._y;
        },
        set: function(a) {
            this._y = Math.floor(a);
        }
    }), Object.defineProperty(c53.Input.prototype, "pollLocked", {
        get: function() {
            return this.pollRate > 0 && this._pollCounter < this.pollRate;
        }
    }), Object.defineProperty(c53.Input.prototype, "totalInactivePointers", {
        get: function() {
            return this.pointers.length - this.countActivePointers();
        }
    }), Object.defineProperty(c53.Input.prototype, "totalActivePointers", {
        get: function() {
            return this.countActivePointers();
        }
    }), Object.defineProperty(c53.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x;
        }
    }), Object.defineProperty(c53.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y;
        }
    }), c53.Mouse = function(a) {
        this.game = a, this.input = a.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new c53.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null;
    }, c53.Mouse.NO_BUTTON = -1, c53.Mouse.LEFT_BUTTON = 0, c53.Mouse.MIDDLE_BUTTON = 1, c53.Mouse.RIGHT_BUTTON = 2, c53.Mouse.BACK_BUTTON = 3, c53.Mouse.FORWARD_BUTTON = 4, c53.Mouse.WHEEL_UP = 1, c53.Mouse.WHEEL_DOWN = -1, c53.Mouse.prototype = {
        start: function() {
            if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                var b = this;
                this._onMouseDown = function(a) {
                    return b.onMouseDown(a);
                }, this._onMouseMove = function(a) {
                    return b.onMouseMove(a);
                }, this._onMouseUp = function(a) {
                    return b.onMouseUp(a);
                }, this._onMouseUpGlobal = function(a) {
                    return b.onMouseUpGlobal(a);
                }, this._onMouseOutGlobal = function(a) {
                    return b.onMouseOutGlobal(a);
                }, this._onMouseOut = function(a) {
                    return b.onMouseOut(a);
                }, this._onMouseOver = function(a) {
                    return b.onMouseOver(a);
                }, this._onMouseWheel = function(a) {
                    return b.onMouseWheel(a);
                };
                var c = this.game.canvas;
                c.addEventListener("mousedown", this._onMouseDown, !0), c.addEventListener("mousemove", this._onMouseMove, !0), c.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), c.addEventListener("mouseover", this._onMouseOver, !0), c.addEventListener("mouseout", this._onMouseOut, !0));
                var d = this.game.device.wheelEvent;
                d && (c.addEventListener(d, this._onMouseWheel, !0), "mousewheel" === d ? this._wheelEvent = new a65(-0.025, 1) : "DOMMouseScroll" === d && (this._wheelEvent = new a65(1, 1)));
            }
        },
        onMouseDown: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.start(a));
        },
        onMouseMove: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.move(a));
        },
        onMouseUp: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.stop(a));
        },
        onMouseUpGlobal: function(a) {
            this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), a.identifier = 0, this.input.mousePointer.stop(a));
        },
        onMouseOutGlobal: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(a), this.input.mousePointer.leftButton.stop(a), this.input.mousePointer.rightButton.stop(a));
        },
        onMouseOut: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && this.stopOnGameOut && (a.identifier = 0, this.input.mousePointer.stop(a));
        },
        onMouseOver: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, a);
        },
        onMouseWheel: function(a) {
            this._wheelEvent && (a = this._wheelEvent.bindEvent(a)), this.event = a, this.capture && a.preventDefault(), this.wheelDelta = c53.Math.clamp(-a.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, a);
        },
        requestPointerLock: function() {
            if (this.game.device.pointerLock) {
                var a70 = this.game.canvas;
                a70.requestPointerLock = a70.requestPointerLock || a70.mozRequestPointerLock || a70.webkitRequestPointerLock, a70.requestPointerLock();
                var b = this;
                this._pointerLockChange = function(a) {
                    return b.pointerLockChange(a);
                }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
            }
        },
        pointerLockChange: function(a) {
            var b = this.game.canvas;
            document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b ? (this.locked = !0, this.pointerLock.dispatch(!0, a)) : (this.locked = !1, this.pointerLock.dispatch(!1, a));
        },
        releasePointerLock: function() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
        },
        stop: function() {
            var a = this.game.canvas;
            a.removeEventListener("mousedown", this._onMouseDown, !0), a.removeEventListener("mousemove", this._onMouseMove, !0), a.removeEventListener("mouseup", this._onMouseUp, !0), a.removeEventListener("mouseover", this._onMouseOver, !0), a.removeEventListener("mouseout", this._onMouseOut, !0);
            var b = this.game.device.wheelEvent;
            b && a.removeEventListener(b, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
        }
    }, c53.Mouse.prototype.constructor = c53.Mouse, a65.prototype = {}, a65.prototype.constructor = a65, a65.prototype.bindEvent = function(b59) {
        if (!a65._stubsGenerated && b59) {
            var c = function(a) {
                return function() {
                    var b = this.originalEvent[a];
                    return "function" != typeof b ? b : b.bind(this.originalEvent);
                };
            };
            for(var d in b59)d in a65.prototype || Object.defineProperty(a65.prototype, d, {
                get: c(d)
            });
            a65._stubsGenerated = !0;
        }
        return this.originalEvent = b59, this;
    }, Object.defineProperties(a65.prototype, {
        type: {
            value: "wheel"
        },
        deltaMode: {
            get: function() {
                return this._deltaMode;
            }
        },
        deltaY: {
            get: function() {
                return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0;
            }
        },
        deltaX: {
            get: function() {
                return this._scaleFactor * this.originalEvent.wheelDeltaX || 0;
            }
        },
        deltaZ: {
            value: 0
        }
    }), c53.MSPointer = function(a) {
        this.game = a, this.input = a.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null;
    }, c53.MSPointer.prototype = {
        start: function() {
            if (null === this._onMSPointerDown) {
                var a = this;
                if (this.game.device.mspointer) {
                    this._onMSPointerDown = function(b) {
                        return a.onPointerDown(b);
                    }, this._onMSPointerMove = function(b) {
                        return a.onPointerMove(b);
                    }, this._onMSPointerUp = function(b) {
                        return a.onPointerUp(b);
                    }, this._onMSPointerUpGlobal = function(b) {
                        return a.onPointerUpGlobal(b);
                    }, this._onMSPointerOut = function(b) {
                        return a.onPointerOut(b);
                    }, this._onMSPointerOver = function(b) {
                        return a.onPointerOver(b);
                    };
                    var b60 = this.game.canvas;
                    b60.addEventListener("MSPointerDown", this._onMSPointerDown, !1), b60.addEventListener("MSPointerMove", this._onMSPointerMove, !1), b60.addEventListener("MSPointerUp", this._onMSPointerUp, !1), b60.addEventListener("pointerdown", this._onMSPointerDown, !1), b60.addEventListener("pointermove", this._onMSPointerMove, !1), b60.addEventListener("pointerup", this._onMSPointerUp, !1), b60.style["-ms-content-zooming"] = "none", b60.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), b60.addEventListener("MSPointerOver", this._onMSPointerOver, !0), b60.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), b60.addEventListener("pointerover", this._onMSPointerOver, !0), b60.addEventListener("pointerout", this._onMSPointerOut, !0));
                }
            }
        },
        onPointerDown: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.start(a) : this.input.startPointer(a));
        },
        onPointerMove: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.move(a) : this.input.updatePointer(a));
        },
        onPointerUp: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.stop(a) : this.input.stopPointer(a));
        },
        onPointerUpGlobal: function(a) {
            if ("mouse" !== a.pointerType && 4 !== a.pointerType || this.input.mousePointer.withinGame) {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && b.withinGame && this.onPointerUp(a);
            } else this.onPointerUp(a);
        },
        onPointerOut: function(a) {
            if (this.event = a, this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType) this.input.mousePointer.withinGame = !1;
            else {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && (b.withinGame = !1);
            }
            this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, a), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (a.identifier = 0, b ? b.stop(a) : this.input.mousePointer.stop(a));
        },
        onPointerOver: function(a) {
            if (this.event = a, this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType) this.input.mousePointer.withinGame = !0;
            else {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && (b.withinGame = !0);
            }
            this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, a);
        },
        stop: function() {
            var a = this.game.canvas;
            a.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), a.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), a.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), a.removeEventListener("pointerdown", this._onMSPointerDown, !1), a.removeEventListener("pointermove", this._onMSPointerMove, !1), a.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), a.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), a.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), a.removeEventListener("pointerover", this._onMSPointerOver, !0), a.removeEventListener("pointerout", this._onMSPointerOut, !0);
        }
    }, c53.MSPointer.prototype.constructor = c53.MSPointer, c53.DeviceButton = function(a, b) {
        this.parent = a, this.game = a.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = b, this.onDown = new c53.Signal, this.onUp = new c53.Signal, this.onFloat = new c53.Signal;
    }, c53.DeviceButton.prototype = {
        start: function(a, b) {
            this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = a, this.value = b, a && (this.altKey = a.altKey, this.shiftKey = a.shiftKey, this.ctrlKey = a.ctrlKey), this.onDown.dispatch(this, b));
        },
        stop: function(a, b) {
            this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = a, this.value = b, a && (this.altKey = a.altKey, this.shiftKey = a.shiftKey, this.ctrlKey = a.ctrlKey), this.onUp.dispatch(this, b));
        },
        padFloat: function(a) {
            this.isDown = !1, this.isUp = !1, this.value = a, this.onFloat.dispatch(this, a);
        },
        justPressed: function(a) {
            return a = a || 250, this.isDown && this.timeDown + a > this.game.time.time;
        },
        justReleased: function(a) {
            return a = a || 250, this.isUp && this.timeUp + a > this.game.time.time;
        },
        reset: function() {
            this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1;
        },
        destroy: function() {
            this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null;
        }
    }, c53.DeviceButton.prototype.constructor = c53.DeviceButton, Object.defineProperty(c53.DeviceButton.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.time - this.timeDown;
        }
    }), c53.Pointer = function(a, b, d) {
        this.game = a, this.id = b, this.type = c53.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = d || c53.PointerMode.CURSOR | c53.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new c53.DeviceButton(this, c53.Pointer.LEFT_BUTTON), this.middleButton = new c53.DeviceButton(this, c53.Pointer.MIDDLE_BUTTON), this.rightButton = new c53.DeviceButton(this, c53.Pointer.RIGHT_BUTTON), this.backButton = new c53.DeviceButton(this, c53.Pointer.BACK_BUTTON), this.forwardButton = new c53.DeviceButton(this, c53.Pointer.FORWARD_BUTTON), this.eraserButton = new c53.DeviceButton(this, c53.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === b, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new c53.Point, this.positionDown = new c53.Point, this.positionUp = new c53.Point, this.circle = new c53.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null;
    }, c53.Pointer.NO_BUTTON = 0, c53.Pointer.LEFT_BUTTON = 1, c53.Pointer.RIGHT_BUTTON = 2, c53.Pointer.MIDDLE_BUTTON = 4, c53.Pointer.BACK_BUTTON = 8, c53.Pointer.FORWARD_BUTTON = 16, c53.Pointer.ERASER_BUTTON = 32, c53.Pointer.prototype = {
        resetButtons: function() {
            this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset());
        },
        processButtonsDown: function(a, b) {
            c53.Pointer.LEFT_BUTTON & a && this.leftButton.start(b), c53.Pointer.RIGHT_BUTTON & a && this.rightButton.start(b), c53.Pointer.MIDDLE_BUTTON & a && this.middleButton.start(b), c53.Pointer.BACK_BUTTON & a && this.backButton.start(b), c53.Pointer.FORWARD_BUTTON & a && this.forwardButton.start(b), c53.Pointer.ERASER_BUTTON & a && this.eraserButton.start(b);
        },
        processButtonsUp: function(a, b) {
            a === c53.Mouse.LEFT_BUTTON && this.leftButton.stop(b), a === c53.Mouse.RIGHT_BUTTON && this.rightButton.stop(b), a === c53.Mouse.MIDDLE_BUTTON && this.middleButton.stop(b), a === c53.Mouse.BACK_BUTTON && this.backButton.stop(b), a === c53.Mouse.FORWARD_BUTTON && this.forwardButton.stop(b), 5 === a && this.eraserButton.stop(b);
        },
        updateButtons: function(a) {
            this.button = a.button;
            var b = "down" === a.type.toLowerCase().substr(-4);
            void 0 !== a.buttons ? b ? this.processButtonsDown(a.buttons, a) : this.processButtonsUp(a.button, a) : b ? this.leftButton.start(a) : (this.leftButton.stop(a), this.rightButton.stop(a)), 1 === a.buttons && a.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(a), this.rightButton.start(a)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0);
        },
        start: function(a) {
            var b = this.game.input;
            return a.pointerId && (this.pointerId = a.pointerId), this.identifier = a.identifier, this.target = a.target, this.isMouse ? this.updateButtons(a) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(a, !0), this.positionDown.setTo(this.x, this.y), (b.multiInputOverride === c53.Input.MOUSE_OVERRIDES_TOUCH || b.multiInputOverride === c53.Input.MOUSE_TOUCH_COMBINE || b.multiInputOverride === c53.Input.TOUCH_OVERRIDES_MOUSE && 0 === b.totalActivePointers) && (b.x = this.x, b.y = this.y, b.position.setTo(this.x, this.y), b.onDown.dispatch(this, a), b.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this;
        },
        update: function() {
            var a = this.game.input;
            this.active && (this.dirty && (a.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= a.holdRate && ((a.multiInputOverride === c53.Input.MOUSE_OVERRIDES_TOUCH || a.multiInputOverride === c53.Input.MOUSE_TOUCH_COMBINE || a.multiInputOverride === c53.Input.TOUCH_OVERRIDES_MOUSE && 0 === a.totalActivePointers) && a.onHold.dispatch(this), this._holdSent = !0), a.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + a.recordRate, this._history.push({
                x: this.position.x,
                y: this.position.y
            }), this._history.length > a.recordLimit && this._history.shift()));
        },
        move: function(a, b) {
            var d = this.game.input;
            if (!d.pollLocked) {
                void 0 === b && (b = !1), void 0 !== a.button && (this.button = a.button), b && this.isMouse && this.updateButtons(a), this.clientX = a.clientX, this.clientY = a.clientY, this.pageX = a.pageX, this.pageY = a.pageY, this.screenX = a.screenX, this.screenY = a.screenY, this.isMouse && d.mouse.locked && !b && (this.rawMovementX = a.movementX || a.mozMovementX || a.webkitMovementX || 0, this.rawMovementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * d.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * d.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (d.multiInputOverride === c53.Input.MOUSE_OVERRIDES_TOUCH || d.multiInputOverride === c53.Input.MOUSE_TOUCH_COMBINE || d.multiInputOverride === c53.Input.TOUCH_OVERRIDES_MOUSE && 0 === d.totalActivePointers) && (d.activePointer = this, d.x = this.x, d.y = this.y, d.position.setTo(d.x, d.y), d.circle.x = d.x, d.circle.y = d.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                for(var e = d.moveCallbacks.length; e--;)d.moveCallbacks[e].callback.call(d.moveCallbacks[e].context, this, this.x, this.y, b);
                return null === this.targetObject || this.game.paused && !this.targetObject.noPause || !0 !== this.targetObject.isDragged ? d.interactiveItems.total > 0 && this.processInteractiveObjects(b) : !1 === this.targetObject.update(this) && (this.targetObject = null), this;
            }
        },
        processInteractiveObjects: function(a) {
            var b = 0, c = -1, d = null, e = this.game.input.interactiveItems.first;
            for(this.interactiveCandidates = []; e;)e.checked = !1, !e.validForInput(c, b, !1) || this.game.paused && !e.sprite.noPause || (e.checked = !0, (a && e.checkPointerDown(this, !0) || !a && e.checkPointerOver(this, !0)) && (b = e.sprite.renderOrderID, c = e.priorityID, d = e, this.interactiveCandidates.push(e))), e = this.game.input.interactiveItems.next;
            for(e = this.game.input.interactiveItems.first; e;)!e.checked && e.validForInput(c, b, !0) && (a && e.checkPointerDown(this, !1) || !a && e.checkPointerOver(this, !1)) && (b = e.sprite.renderOrderID, c = e.priorityID, d = e, this.interactiveCandidates.push(e)), e = this.game.input.interactiveItems.next;
            return this.game.input.customCandidateHandler && (d = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, d)), this.swapTarget(d, !1), null !== this.targetObject;
        },
        swapTarget: function(a, b) {
            void 0 === b && (b = !1), null === a ? this.targetObject && (this.targetObject._pointerOutHandler(this, b), this.targetObject = null) : null === this.targetObject ? (this.targetObject = a, a._pointerOverHandler(this, b)) : this.targetObject === a ? !1 === a.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, b), this.targetObject = a, this.targetObject._pointerOverHandler(this, b));
        },
        leave: function(a) {
            this.withinGame = !1, this.move(a, !1);
        },
        stop: function(a) {
            var b = this.game.input;
            return this._stateReset && this.withinGame ? void a.preventDefault() : (this.timeUp = this.game.time.time, (b.multiInputOverride === c53.Input.MOUSE_OVERRIDES_TOUCH || b.multiInputOverride === c53.Input.MOUSE_TOUCH_COMBINE || b.multiInputOverride === c53.Input.TOUCH_OVERRIDES_MOUSE && 0 === b.totalActivePointers) && (b.onUp.dispatch(this, a), this.duration >= 0 && this.duration <= b.tapRate && (this.timeUp - this.previousTapTime < b.doubleTapRate ? b.onTap.dispatch(this, !0) : b.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(a) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(a.pageX, a.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && b.currentPointers--, b.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this);
        },
        justPressed: function(a) {
            return a = a || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + a > this.game.time.time;
        },
        justReleased: function(a) {
            return a = a || this.game.input.justReleasedRate, this.isUp && this.timeUp + a > this.game.time.time;
        },
        addClickTrampoline: function(a, b, c, d) {
            if (this.isDown) {
                for(var e = this._clickTrampolines = this._clickTrampolines || [], f = 0; f < e.length; f++)if (e[f].name === a) {
                    e.splice(f, 1);
                    break;
                }
                e.push({
                    name: a,
                    targetObject: this.targetObject,
                    callback: b,
                    callbackContext: c,
                    callbackArgs: d
                });
            }
        },
        processClickTrampolines: function() {
            var a = this._clickTrampolines;
            if (a) {
                for(var b = 0; b < a.length; b++){
                    var c = a[b];
                    c.targetObject === this._trampolineTargetObject && c.callback.apply(c.callbackContext, c.callbackArgs);
                }
                this._clickTrampolines = null, this._trampolineTargetObject = null;
            }
        },
        reset: function() {
            !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null;
        },
        resetMovement: function() {
            this.movementX = 0, this.movementY = 0;
        }
    }, c53.Pointer.prototype.constructor = c53.Pointer, Object.defineProperty(c53.Pointer.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.time - this.timeDown;
        }
    }), Object.defineProperty(c53.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x;
        }
    }), Object.defineProperty(c53.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y;
        }
    }), c53.PointerMode = {
        CURSOR: 1,
        CONTACT: 2
    }, c53.Touch = function(a) {
        this.game = a, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null;
    }, c53.Touch.prototype = {
        start: function() {
            if (null === this._onTouchStart) {
                var a = this;
                this.game.device.touch && (this._onTouchStart = function(b) {
                    return a.onTouchStart(b);
                }, this._onTouchMove = function(b) {
                    return a.onTouchMove(b);
                }, this._onTouchEnd = function(b) {
                    return a.onTouchEnd(b);
                }, this._onTouchEnter = function(b) {
                    return a.onTouchEnter(b);
                }, this._onTouchLeave = function(b) {
                    return a.onTouchLeave(b);
                }, this._onTouchCancel = function(b) {
                    return a.onTouchCancel(b);
                }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)));
            }
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove = function(a) {
                a.preventDefault();
            }, document.addEventListener("touchmove", this._documentTouchMove, !1);
        },
        addTouchLockCallback: function(a, b, c) {
            void 0 === c && (c = !1), this.touchLockCallbacks.push({
                callback: a,
                context: b,
                onEnd: c
            });
        },
        removeTouchLockCallback: function(a, b) {
            for(var c = this.touchLockCallbacks.length; c--;)if (this.touchLockCallbacks[c].callback === a && this.touchLockCallbacks[c].context === b) return this.touchLockCallbacks.splice(c, 1), !0;
            return !1;
        },
        onTouchStart: function(a) {
            for(var b = this.touchLockCallbacks.length; b--;){
                var c = this.touchLockCallbacks[b];
                !c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1);
            }
            if (this.event = a, this.game.input.enabled && this.enabled) {
                this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
                for(var b = 0; b < a.changedTouches.length; b++)this.game.input.startPointer(a.changedTouches[b]);
            }
        },
        onTouchCancel: function(a) {
            if (this.event = a, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, a), this.game.input.enabled && this.enabled) {
                this.preventDefault && a.preventDefault();
                for(var b = 0; b < a.changedTouches.length; b++)this.game.input.stopPointer(a.changedTouches[b]);
            }
        },
        onTouchEnter: function(a) {
            this.event = a, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, a), this.game.input.enabled && this.enabled && this.preventDefault && a.preventDefault();
        },
        onTouchLeave: function(a) {
            this.event = a, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
        },
        onTouchMove: function(a) {
            this.event = a, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
            for(var b = 0; b < a.changedTouches.length; b++)this.game.input.updatePointer(a.changedTouches[b]);
        },
        onTouchEnd: function(a) {
            for(var b = this.touchLockCallbacks.length; b--;){
                var c = this.touchLockCallbacks[b];
                c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1);
            }
            this.event = a, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
            for(var b = 0; b < a.changedTouches.length; b++)this.game.input.stopPointer(a.changedTouches[b]);
        },
        stop: function() {
            this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel));
        }
    }, c53.Touch.prototype.constructor = c53.Touch, c53.InputHandler = function(a) {
        this.sprite = a, this.game = a.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new c53.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new c53.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new c53.Point, this.snapPoint = new c53.Point, this._dragPoint = new c53.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new c53.Point, this._pointerData = [], this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            camX: 0,
            camY: 0,
            isDown: !1,
            isUp: !1,
            isOver: !1,
            isOut: !1,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: !1
        });
    }, c53.InputHandler.prototype = {
        start: function(a, b) {
            if (a = a || 0, void 0 === b && (b = !1), !1 === this.enabled) {
                this.game.input.interactiveItems.add(this), this.useHandCursor = b, this.priorityID = a;
                for(var d = 0; d < 10; d++)this._pointerData[d] = {
                    id: d,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                };
                this.snapOffset = new c53.Point, this.enabled = !0, this._wasEnabled = !0;
            }
            return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite;
        },
        addedToGroup: function() {
            this._dragPhase || this._wasEnabled && !this.enabled && this.start();
        },
        removedFromGroup: function() {
            this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1);
        },
        reset: function() {
            this.enabled = !1;
            for(var a = 0; a < 10; a++)this._pointerData[a] = {
                id: a,
                x: 0,
                y: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            };
        },
        stop: function() {
            !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this));
        },
        destroy: function() {
            this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null);
        },
        validForInput: function(a, b, c) {
            return void 0 === c && (c = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && !(!c && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > a || this.priorityID === a && this.sprite.renderOrderID > b);
        },
        isPixelPerfect: function() {
            return this.pixelPerfectClick || this.pixelPerfectOver;
        },
        pointerX: function(a) {
            return a = a || 0, this._pointerData[a].x;
        },
        pointerY: function(a) {
            return a = a || 0, this._pointerData[a].y;
        },
        pointerDown: function(a) {
            return a = a || 0, this._pointerData[a].isDown;
        },
        pointerUp: function(a) {
            return a = a || 0, this._pointerData[a].isUp;
        },
        pointerTimeDown: function(a) {
            return a = a || 0, this._pointerData[a].timeDown;
        },
        pointerTimeUp: function(a) {
            return a = a || 0, this._pointerData[a].timeUp;
        },
        pointerOver: function(a) {
            if (!this.enabled) return !1;
            if (void 0 === a) {
                for(var b = 0; b < 10; b++)if (this._pointerData[b].isOver) return !0;
                return !1;
            }
            return this._pointerData[a].isOver;
        },
        pointerOut: function(a) {
            if (!this.enabled) return !1;
            if (void 0 !== a) return this._pointerData[a].isOut;
            for(var b = 0; b < 10; b++)if (this._pointerData[b].isOut) return !0;
        },
        pointerTimeOver: function(a) {
            return a = a || 0, this._pointerData[a].timeOver;
        },
        pointerTimeOut: function(a) {
            return a = a || 0, this._pointerData[a].timeOut;
        },
        pointerDragged: function(a) {
            return a = a || 0, this._pointerData[a].isDragged;
        },
        checkPointerDown: function(a, b) {
            return !!(a.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (void 0 === b && (b = !1), !(!b && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y));
        },
        checkPointerOver: function(a, b) {
            return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (void 0 === b && (b = !1), !(!b && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y));
        },
        checkPixel: function(a, b, c) {
            if (this.sprite.texture.baseTexture.source) {
                if (null === a && null === b) {
                    this.game.input.getLocalPosition(this.sprite, c, this._tempPoint);
                    var a = this._tempPoint.x, b = this._tempPoint.y;
                }
                if (0 !== this.sprite.anchor.x && (a -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (b -= -this.sprite.texture.frame.height * this.sprite.anchor.y), a += this.sprite.texture.frame.x, b += this.sprite.texture.frame.y, this.sprite.texture.trim && (a -= this.sprite.texture.trim.x, b -= this.sprite.texture.trim.y, a < this.sprite.texture.crop.x || a > this.sprite.texture.crop.right || b < this.sprite.texture.crop.y || b > this.sprite.texture.crop.bottom)) return this._dx = a, this._dy = b, !1;
                this._dx = a, this._dy = b, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1);
                if (this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0;
            }
            return !1;
        },
        update: function(a) {
            if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = c53.Math.distance(a.x, a.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(a), !0) : this.draggable && this._draggedPointerID === a.id ? this.updateDrag(a, !1) : this._pointerData[a.id].isOver ? this.checkPointerOver(a) ? (this._pointerData[a.id].x = a.x - this.sprite.x, this._pointerData[a.id].y = a.y - this.sprite.y, !0) : (this._pointerOutHandler(a), !1) : void 0 : (this._pointerOutHandler(a), !1);
        },
        _pointerOverHandler: function(a, b) {
            if (null !== this.sprite) {
                var d = this._pointerData[a.id];
                if (!1 === d.isOver || a.dirty) {
                    var e = !1 === d.isOver;
                    d.isOver = !0, d.isOut = !1, d.timeOver = this.game.time.time, d.x = a.x - this.sprite.x, d.y = a.y - this.sprite.y, this.useHandCursor && !1 === d.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !b && e && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, a), this.sprite.parent && this.sprite.parent.type === c53.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, a);
                }
            }
        },
        _pointerOutHandler: function(a, b) {
            if (null !== this.sprite) {
                var d = this._pointerData[a.id];
                d.isOver = !1, d.isOut = !0, d.timeOut = this.game.time.time, this.useHandCursor && !1 === d.isDragged && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), !b && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === c53.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, a));
            }
        },
        _touchedHandler: function(a) {
            if (null !== this.sprite) {
                var b = this._pointerData[a.id];
                if (!b.isDown && b.isOver) {
                    if (this.pixelPerfectClick && !this.checkPixel(null, null, a)) return;
                    if (b.isDown = !0, b.isUp = !1, b.timeDown = this.game.time.time, this.downPoint.set(a.x, a.y), a.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === c53.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, a), null === this.sprite)) return;
                    this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(a) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, a)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop();
                }
            }
        },
        dragTimeElapsed: function(a) {
            this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(a);
        },
        _releasedHandler: function(a) {
            if (null !== this.sprite) {
                var b = this._pointerData[a.id];
                if (b.isDown && a.isUp) {
                    b.isDown = !1, b.isUp = !0, b.timeUp = this.game.time.time, b.downDuration = b.timeUp - b.timeDown;
                    var d = this.checkPointerOver(a);
                    this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === a.id) || this.sprite.events.onInputUp$dispatch(this.sprite, a, d), this.sprite && this.sprite.parent && this.sprite.parent.type === c53.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, a, d), d && (d = this.checkPointerOver(a))), b.isOver = d, !d && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), a.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === a.id && this.stopDrag(a);
                }
            }
        },
        updateDrag: function(a, b) {
            if (void 0 === b && (b = !1), a.isUp) return this.stopDrag(a), !1;
            var c = this.globalToLocal(a), d = c.x + this._dragPoint.x + this.dragOffset.x, e = c.y + this._dragPoint.y + this.dragOffset.y;
            if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = d), this.allowVerticalDrag && (this.sprite.cameraOffset.y = e), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
            else {
                var f = this.game.camera.x - this._pointerData[a.id].camX, g = this.game.camera.y - this._pointerData[a.id].camY;
                this.allowHorizontalDrag && (this.sprite.x = d + f), this.allowVerticalDrag && (this.sprite.y = e + g), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y));
            }
            return this.sprite.events.onDragUpdate.dispatch(this.sprite, a, d, e, this.snapPoint, b), !0;
        },
        justOver: function(a, b) {
            return a = a || 0, b = b || 500, this._pointerData[a].isOver && this.overDuration(a) < b;
        },
        justOut: function(a, b) {
            return a = a || 0, b = b || 500, this._pointerData[a].isOut && this.game.time.time - this._pointerData[a].timeOut < b;
        },
        justPressed: function(a, b) {
            return a = a || 0, b = b || 500, this._pointerData[a].isDown && this.downDuration(a) < b;
        },
        justReleased: function(a, b) {
            return a = a || 0, b = b || 500, this._pointerData[a].isUp && this.game.time.time - this._pointerData[a].timeUp < b;
        },
        overDuration: function(a) {
            return a = a || 0, this._pointerData[a].isOver ? this.game.time.time - this._pointerData[a].timeOver : -1;
        },
        downDuration: function(a) {
            return a = a || 0, this._pointerData[a].isDown ? this.game.time.time - this._pointerData[a].timeDown : -1;
        },
        enableDrag: function(a, b, d, e, f, g) {
            void 0 === a && (a = !1), void 0 === b && (b = !1), void 0 === d && (d = !1), void 0 === e && (e = 255), void 0 === f && (f = null), void 0 === g && (g = null), this._dragPoint = new c53.Point, this.draggable = !0, this.bringToTop = b, this.dragOffset = new c53.Point, this.dragFromCenter = a, this.pixelPerfectClick = d, this.pixelPerfectAlpha = e, f && (this.boundsRect = f), g && (this.boundsSprite = g);
        },
        disableDrag: function() {
            if (this._pointerData) for(var a = 0; a < 10; a++)this._pointerData[a].isDragged = !1;
            this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1;
        },
        startDrag: function(a) {
            var b = this.sprite.x, d = this.sprite.y, e = this.globalToLocal(a);
            if (this.isDragged = !0, this._draggedPointerID = a.id, this._pointerData[a.id].camX = this.game.camera.x, this._pointerData[a.id].camY = this.game.camera.y, this._pointerData[a.id].isDragged = !0, this.sprite.fixedToCamera) {
                if (this.dragFromCenter) {
                    var f = this.sprite.getBounds(), g = this.globalToLocal(new c53.Point(f.centerX, f.centerY));
                    this.sprite.cameraOffset.x = e.x + (this.sprite.cameraOffset.x - g.x), this.sprite.cameraOffset.y = e.y + (this.sprite.cameraOffset.y - g.y);
                }
                this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y);
            } else {
                if (this.dragFromCenter) {
                    var f = this.sprite.getBounds(), g = this.globalToLocal(new c53.Point(f.centerX, f.centerY));
                    this.sprite.x = e.x + (this.sprite.x - g.x), this.sprite.y = e.y + (this.sprite.y - g.y);
                }
                this._dragPoint.setTo(this.sprite.x - e.x, this.sprite.y - e.y);
            }
            this.updateDrag(a, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(b, d), this.sprite.events.onDragStart$dispatch(this.sprite, a, b, d), this._pendingDrag = !1;
        },
        globalToLocalX: function(a) {
            return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.x, a *= this.game.scale.grid.scaleFluidInversed.x), a;
        },
        globalToLocalY: function(a) {
            return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.y, a *= this.game.scale.grid.scaleFluidInversed.y), a;
        },
        globalToLocal: function(a) {
            return this.sprite.parent ? this.game.input.getLocalPosition(this.sprite.parent, {
                x: a.x,
                y: a.y
            }) : a;
        },
        stopDrag: function(a) {
            this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[a.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, a), !1 === this.checkPointerOver(a) && this._pointerOutHandler(a);
        },
        setDragLock: function(a, b) {
            void 0 === a && (a = !0), void 0 === b && (b = !0), this.allowHorizontalDrag = a, this.allowVerticalDrag = b;
        },
        enableSnap: function(a, b, c, d, e, f) {
            void 0 === c && (c = !0), void 0 === d && (d = !1), void 0 === e && (e = 0), void 0 === f && (f = 0), this.snapX = a, this.snapY = b, this.snapOffsetX = e, this.snapOffsetY = f, this.snapOnDrag = c, this.snapOnRelease = d;
        },
        disableSnap: function() {
            this.snapOnDrag = !1, this.snapOnRelease = !1;
        },
        checkBoundsRect: function() {
            this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)));
        },
        checkBoundsSprite: function() {
            this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)));
        }
    }, c53.InputHandler.prototype.constructor = c53.InputHandler, c53.Gamepad = function(a) {
        this.game = a, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [
            new c53.SinglePad(a, this),
            new c53.SinglePad(a, this),
            new c53.SinglePad(a, this),
            new c53.SinglePad(a, this)
        ];
    }, c53.Gamepad.prototype = {
        addCallbacks: function(a, b) {
            void 0 !== b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback, this.callbackContext = a);
        },
        start: function() {
            if (!this._active) {
                this._active = !0;
                var a = this;
                this._onGamepadConnected = function(b) {
                    return a.onGamepadConnected(b);
                }, this._onGamepadDisconnected = function(b) {
                    return a.onGamepadDisconnected(b);
                }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1);
            }
        },
        onGamepadConnected: function(a) {
            var b = a.gamepad;
            this._rawPads.push(b), this._gamepads[b.index].connect(b);
        },
        onGamepadDisconnected: function(a) {
            var b = a.gamepad;
            for(var c in this._rawPads)this._rawPads[c].index === b.index && this._rawPads.splice(c, 1);
            this._gamepads[b.index].disconnect();
        },
        update: function() {
            this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus();
        },
        _pollGamepads: function() {
            if (this._active) {
                if (navigator.getGamepads) var a = navigator.getGamepads();
                else if (navigator.webkitGetGamepads) var a = navigator.webkitGetGamepads();
                else if (navigator.webkitGamepads) var a = navigator.webkitGamepads();
                if (a) {
                    this._rawPads = [];
                    for(var b = !1, c = 0; c < a.length && (typeof a[c] !== this._prevRawGamepadTypes[c] && (b = !0, this._prevRawGamepadTypes[c] = typeof a[c]), a[c] && this._rawPads.push(a[c]), 3 !== c); c++);
                    for(var d = 0; d < this._gamepads.length; d++)this._gamepads[d]._rawPad = this._rawPads[d];
                    if (b) {
                        for(var e, f = {
                            rawIndices: {},
                            padIndices: {}
                        }, g = 0; g < this._gamepads.length; g++)if (e = this._gamepads[g], e.connected) for(var h = 0; h < this._rawPads.length; h++)this._rawPads[h].index === e.index && (f.rawIndices[e.index] = !0, f.padIndices[g] = !0);
                        for(var i = 0; i < this._gamepads.length; i++)if (e = this._gamepads[i], !f.padIndices[i]) {
                            this._rawPads.length < 1 && e.disconnect();
                            for(var j = 0; j < this._rawPads.length && !f.padIndices[i]; j++){
                                var k = this._rawPads[j];
                                if (k) {
                                    if (f.rawIndices[k.index]) {
                                        e.disconnect();
                                        continue;
                                    }
                                    e.connect(k), f.rawIndices[k.index] = !0, f.padIndices[i] = !0;
                                } else e.disconnect();
                            }
                        }
                    }
                }
            }
        },
        setDeadZones: function(a) {
            for(var b = 0; b < this._gamepads.length; b++)this._gamepads[b].deadZone = a;
        },
        stop: function() {
            this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected);
        },
        reset: function() {
            this.update();
            for(var a = 0; a < this._gamepads.length; a++)this._gamepads[a].reset();
        },
        justPressed: function(a, b) {
            for(var c = 0; c < this._gamepads.length; c++)if (!0 === this._gamepads[c].justPressed(a, b)) return !0;
            return !1;
        },
        justReleased: function(a, b) {
            for(var c = 0; c < this._gamepads.length; c++)if (!0 === this._gamepads[c].justReleased(a, b)) return !0;
            return !1;
        },
        isDown: function(a) {
            for(var b = 0; b < this._gamepads.length; b++)if (!0 === this._gamepads[b].isDown(a)) return !0;
            return !1;
        },
        destroy: function() {
            this.stop();
            for(var a = 0; a < this._gamepads.length; a++)this._gamepads[a].destroy();
        }
    }, c53.Gamepad.prototype.constructor = c53.Gamepad, Object.defineProperty(c53.Gamepad.prototype, "active", {
        get: function() {
            return this._active;
        }
    }), Object.defineProperty(c53.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable;
        }
    }), Object.defineProperty(c53.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length;
        }
    }), Object.defineProperty(c53.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0];
        }
    }), Object.defineProperty(c53.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1];
        }
    }), Object.defineProperty(c53.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2];
        }
    }), Object.defineProperty(c53.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3];
        }
    }), c53.Gamepad.BUTTON_0 = 0, c53.Gamepad.BUTTON_1 = 1, c53.Gamepad.BUTTON_2 = 2, c53.Gamepad.BUTTON_3 = 3, c53.Gamepad.BUTTON_4 = 4, c53.Gamepad.BUTTON_5 = 5, c53.Gamepad.BUTTON_6 = 6, c53.Gamepad.BUTTON_7 = 7, c53.Gamepad.BUTTON_8 = 8, c53.Gamepad.BUTTON_9 = 9, c53.Gamepad.BUTTON_10 = 10, c53.Gamepad.BUTTON_11 = 11, c53.Gamepad.BUTTON_12 = 12, c53.Gamepad.BUTTON_13 = 13, c53.Gamepad.BUTTON_14 = 14, c53.Gamepad.BUTTON_15 = 15, c53.Gamepad.AXIS_0 = 0, c53.Gamepad.AXIS_1 = 1, c53.Gamepad.AXIS_2 = 2, c53.Gamepad.AXIS_3 = 3, c53.Gamepad.AXIS_4 = 4, c53.Gamepad.AXIS_5 = 5, c53.Gamepad.AXIS_6 = 6, c53.Gamepad.AXIS_7 = 7, c53.Gamepad.AXIS_8 = 8, c53.Gamepad.AXIS_9 = 9, c53.Gamepad.XBOX360_A = 0, c53.Gamepad.XBOX360_B = 1, c53.Gamepad.XBOX360_X = 2, c53.Gamepad.XBOX360_Y = 3, c53.Gamepad.XBOX360_LEFT_BUMPER = 4, c53.Gamepad.XBOX360_RIGHT_BUMPER = 5, c53.Gamepad.XBOX360_LEFT_TRIGGER = 6, c53.Gamepad.XBOX360_RIGHT_TRIGGER = 7, c53.Gamepad.XBOX360_BACK = 8, c53.Gamepad.XBOX360_START = 9, c53.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, c53.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, c53.Gamepad.XBOX360_DPAD_LEFT = 14;
    c53.Gamepad.XBOX360_DPAD_RIGHT = 15, c53.Gamepad.XBOX360_DPAD_UP = 12, c53.Gamepad.XBOX360_DPAD_DOWN = 13, c53.Gamepad.XBOX360_STICK_LEFT_X = 0, c53.Gamepad.XBOX360_STICK_LEFT_Y = 1, c53.Gamepad.XBOX360_STICK_RIGHT_X = 2, c53.Gamepad.XBOX360_STICK_RIGHT_Y = 3, c53.Gamepad.PS3XC_X = 0, c53.Gamepad.PS3XC_CIRCLE = 1, c53.Gamepad.PS3XC_SQUARE = 2, c53.Gamepad.PS3XC_TRIANGLE = 3, c53.Gamepad.PS3XC_L1 = 4, c53.Gamepad.PS3XC_R1 = 5, c53.Gamepad.PS3XC_L2 = 6, c53.Gamepad.PS3XC_R2 = 7, c53.Gamepad.PS3XC_SELECT = 8, c53.Gamepad.PS3XC_START = 9, c53.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, c53.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, c53.Gamepad.PS3XC_DPAD_UP = 12, c53.Gamepad.PS3XC_DPAD_DOWN = 13, c53.Gamepad.PS3XC_DPAD_LEFT = 14, c53.Gamepad.PS3XC_DPAD_RIGHT = 15, c53.Gamepad.PS3XC_STICK_LEFT_X = 0, c53.Gamepad.PS3XC_STICK_LEFT_Y = 1, c53.Gamepad.PS3XC_STICK_RIGHT_X = 2, c53.Gamepad.PS3XC_STICK_RIGHT_Y = 3, c53.SinglePad = function(a, b) {
        this.game = a, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = 0.26, this._padParent = b, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0;
    }, c53.SinglePad.prototype = {
        addCallbacks: function(a, b) {
            void 0 !== b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback, this.callbackContext = a);
        },
        getButton: function(a) {
            return this._buttons[a] ? this._buttons[a] : null;
        },
        pollStatus: function() {
            if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                for(var a = 0; a < this._buttonsLen; a++){
                    var b = isNaN(this._rawPad.buttons[a]) ? this._rawPad.buttons[a].value : this._rawPad.buttons[a];
                    b !== this._buttons[a].value && (1 === b ? this.processButtonDown(a, b) : 0 === b ? this.processButtonUp(a, b) : this.processButtonFloat(a, b));
                }
                for(var c = 0; c < this._axesLen; c++){
                    var d = this._rawPad.axes[c];
                    d > 0 && d > this.deadZone || d < 0 && d < -this.deadZone ? this.processAxisChange(c, d) : this.processAxisChange(c, 0);
                }
                this._prevTimestamp = this._rawPad.timestamp;
            }
        },
        connect: function(a) {
            var b = !this.connected;
            this.connected = !0, this.index = a.index, this._rawPad = a, this._buttons = [], this._buttonsLen = a.buttons.length, this._axes = [], this._axesLen = a.axes.length;
            for(var d = 0; d < this._axesLen; d++)this._axes[d] = a.axes[d];
            for(var e in a.buttons)e = parseInt(e, 10), this._buttons[e] = new c53.DeviceButton(this, e);
            b && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), b && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext);
        },
        disconnect: function() {
            var a = this.connected, b = this.index;
            this.connected = !1, this.index = null, this._rawPad = void 0;
            for(var c = 0; c < this._buttonsLen; c++)this._buttons[c].destroy();
            this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, a && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, b), a && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext);
        },
        destroy: function() {
            this._rawPad = void 0;
            for(var a = 0; a < this._buttonsLen; a++)this._buttons[a].destroy();
            this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null;
        },
        processAxisChange: function(a, b) {
            this._axes[a] !== b && (this._axes[a] = b, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, a, b), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, a, b));
        },
        processButtonDown: function(a, b) {
            this._buttons[a] && this._buttons[a].start(null, b), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, a, b, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, a, b);
        },
        processButtonUp: function(a, b) {
            this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, a, b, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].stop(null, b);
        },
        processButtonFloat: function(a, b) {
            this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, a, b, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].padFloat(b);
        },
        axis: function(a) {
            return !!this._axes[a] && this._axes[a];
        },
        isDown: function(a) {
            return !!this._buttons[a] && this._buttons[a].isDown;
        },
        isUp: function(a) {
            return !!this._buttons[a] && this._buttons[a].isUp;
        },
        justReleased: function(a, b) {
            if (this._buttons[a]) return this._buttons[a].justReleased(b);
        },
        justPressed: function(a, b) {
            if (this._buttons[a]) return this._buttons[a].justPressed(b);
        },
        buttonValue: function(a) {
            return this._buttons[a] ? this._buttons[a].value : null;
        },
        reset: function() {
            for(var a = 0; a < this._axes.length; a++)this._axes[a] = 0;
        }
    }, c53.SinglePad.prototype.constructor = c53.SinglePad, c53.Key = function(a, b) {
        this.game = a, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.durationUp = -2500, this.repeats = 0, this.keyCode = b, this.onDown = new c53.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new c53.Signal, this._justDown = !1, this._justUp = !1;
    }, c53.Key.prototype = {
        update: function() {
            this._enabled && (this.isDown ? (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) : this.durationUp = this.game.time.time - this.timeUp);
        },
        processKeyDown: function(a) {
            this._enabled && (this.event = a, this.isDown || (this.altKey = a.altKey, this.ctrlKey = a.ctrlKey, this.shiftKey = a.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.durationUp = this.game.time.time - this.timeUp, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)));
        },
        processKeyUp: function(a) {
            this._enabled && (this.event = a, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this.durationUp = 0, this._justUp = !0, this.onUp.dispatch(this)));
        },
        reset: function(a) {
            void 0 === a && (a = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this.durationUp = -2500, this._enabled = !0, this._justDown = !1, this._justUp = !1, a && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null);
        },
        downDuration: function(a) {
            return void 0 === a && (a = 50), this.isDown && this.duration < a;
        },
        upDuration: function(a) {
            return void 0 === a && (a = 50), !this.isDown && this.game.time.time - this.timeUp < a;
        },
        justPressed: function() {
            return this.isDown && 0 === this.duration;
        },
        justReleased: function() {
            return !this.isDown && 0 === this.durationUp;
        }
    }, Object.defineProperty(c53.Key.prototype, "justDown", {
        get: function() {
            var a = this._justDown;
            return this._justDown = !1, a;
        }
    }), Object.defineProperty(c53.Key.prototype, "justUp", {
        get: function() {
            var a = this._justUp;
            return this._justUp = !1, a;
        }
    }), Object.defineProperty(c53.Key.prototype, "enabled", {
        get: function() {
            return this._enabled;
        },
        set: function(a) {
            (a = !!a) !== this._enabled && (a || this.reset(!1), this._enabled = a);
        }
    }), c53.Key.prototype.constructor = c53.Key, c53.Keyboard = function(a) {
        this.game = a, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0;
    }, c53.Keyboard.prototype = {
        addCallbacks: function(a, b, c, d) {
            this.callbackContext = a, void 0 !== b && null !== b && (this.onDownCallback = b), void 0 !== c && null !== c && (this.onUpCallback = c), void 0 !== d && null !== d && (this.onPressCallback = d);
        },
        addKey: function(a) {
            return this._keys[a] || (this._keys[a] = new c53.Key(this.game, a), this.addKeyCapture(a)), this._keys[a];
        },
        addKeys: function(a) {
            var b = {};
            for(var c in a)b[c] = this.addKey(a[c]);
            return b;
        },
        removeKey: function(a) {
            this._keys[a] && (this._keys[a] = null, this.removeKeyCapture(a));
        },
        createCursorKeys: function() {
            return this.addKeys({
                up: c53.KeyCode.UP,
                down: c53.KeyCode.DOWN,
                left: c53.KeyCode.LEFT,
                right: c53.KeyCode.RIGHT
            });
        },
        start: function() {
            if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                var a = this;
                this._onKeyDown = function(b) {
                    return a.processKeyDown(b);
                }, this._onKeyUp = function(b) {
                    return a.processKeyUp(b);
                }, this._onKeyPress = function(b) {
                    return a.processKeyPress(b);
                }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1);
            }
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null;
        },
        destroy: function() {
            this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0;
        },
        addKeyCapture: function(a) {
            if ("object" == typeof a) for(var b in a)this._capture[a[b]] = !0;
            else this._capture[a] = !0;
        },
        removeKeyCapture: function(a) {
            delete this._capture[a];
        },
        clearCaptures: function() {
            this._capture = {};
        },
        update: function() {
            for(this._i = this._keys.length; this._i--;)this._keys[this._i] && this._keys[this._i].update();
        },
        processKeyDown: function(a) {
            if (this.event = a, this.game.input.enabled && this.enabled) {
                var b = a.keyCode;
                this._capture[b] && a.preventDefault(), this._keys[b] || (this._keys[b] = new c53.Key(this.game, b)), this._keys[b].processKeyDown(a), this._k = b, this.onDownCallback && this.onDownCallback.call(this.callbackContext, a);
            }
        },
        processKeyPress: function(a) {
            this.pressEvent = a, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(a.charCode), a);
        },
        processKeyUp: function(a) {
            if (this.event = a, this.game.input.enabled && this.enabled) {
                var b = a.keyCode;
                this._capture[b] && a.preventDefault(), this._keys[b] || (this._keys[b] = new c53.Key(this.game, b)), this._keys[b].processKeyUp(a), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a);
            }
        },
        reset: function(a) {
            void 0 === a && (a = !0), this.event = null;
            for(var b = this._keys.length; b--;)this._keys[b] && this._keys[b].reset(a);
        },
        downDuration: function(a, b) {
            return this._keys[a] ? this._keys[a].downDuration(b) : null;
        },
        upDuration: function(a, b) {
            return this._keys[a] ? this._keys[a].upDuration(b) : null;
        },
        justPressed: function(a) {
            return this._keys[a] ? this._keys[a].justPressed() : null;
        },
        justReleased: function(a) {
            return this._keys[a] ? this._keys[a].justReleased() : null;
        },
        isDown: function(a) {
            return this._keys[a] ? this._keys[a].isDown : null;
        }
    }, Object.defineProperty(c53.Keyboard.prototype, "lastChar", {
        get: function() {
            return this.event && 32 === this.event.charCode ? "" : this.pressEvent ? String.fromCharCode(this.pressEvent.charCode) : null;
        }
    }), Object.defineProperty(c53.Keyboard.prototype, "lastKey", {
        get: function() {
            return this._keys[this._k];
        }
    }), c53.Keyboard.prototype.constructor = c53.Keyboard, c53.KeyCode = {
        A: "A".charCodeAt(0),
        B: "B".charCodeAt(0),
        C: "C".charCodeAt(0),
        D: "D".charCodeAt(0),
        E: "E".charCodeAt(0),
        F: "F".charCodeAt(0),
        G: "G".charCodeAt(0),
        H: "H".charCodeAt(0),
        I: "I".charCodeAt(0),
        J: "J".charCodeAt(0),
        K: "K".charCodeAt(0),
        L: "L".charCodeAt(0),
        M: "M".charCodeAt(0),
        N: "N".charCodeAt(0),
        O: "O".charCodeAt(0),
        P: "P".charCodeAt(0),
        Q: "Q".charCodeAt(0),
        R: "R".charCodeAt(0),
        S: "S".charCodeAt(0),
        T: "T".charCodeAt(0),
        U: "U".charCodeAt(0),
        V: "V".charCodeAt(0),
        W: "W".charCodeAt(0),
        X: "X".charCodeAt(0),
        Y: "Y".charCodeAt(0),
        Z: "Z".charCodeAt(0),
        ZERO: "0".charCodeAt(0),
        ONE: "1".charCodeAt(0),
        TWO: "2".charCodeAt(0),
        THREE: "3".charCodeAt(0),
        FOUR: "4".charCodeAt(0),
        FIVE: "5".charCodeAt(0),
        SIX: "6".charCodeAt(0),
        SEVEN: "7".charCodeAt(0),
        EIGHT: "8".charCodeAt(0),
        NINE: "9".charCodeAt(0),
        NUMPAD_0: 96,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_5: 101,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_ADD: 107,
        NUMPAD_ENTER: 108,
        NUMPAD_SUBTRACT: 109,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        F13: 124,
        F14: 125,
        F15: 126,
        COLON: 186,
        EQUALS: 187,
        COMMA: 188,
        UNDERSCORE: 189,
        PERIOD: 190,
        QUESTION_MARK: 191,
        TILDE: 192,
        OPEN_BRACKET: 219,
        BACKWARD_SLASH: 220,
        CLOSED_BRACKET: 221,
        QUOTES: 222,
        BACKSPACE: 8,
        TAB: 9,
        CLEAR: 12,
        ENTER: 13,
        SHIFT: 16,
        CONTROL: 17,
        ALT: 18,
        CAPS_LOCK: 20,
        ESC: 27,
        SPACEBAR: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        PLUS: 43,
        MINUS: 44,
        INSERT: 45,
        DELETE: 46,
        HELP: 47,
        NUM_LOCK: 144
    };
    for(var e29 in c53.KeyCode)c53.KeyCode.hasOwnProperty(e29) && !e29.match(/[a-z]/) && (c53.Keyboard[e29] = c53.KeyCode[e29]);
    c53.Component = function() {}, c53.Component.Angle = function() {}, c53.Component.Angle.prototype = {
        angle: {
            get: function() {
                return c53.Math.wrapAngle(c53.Math.radToDeg(this.rotation));
            },
            set: function(a) {
                this.rotation = c53.Math.degToRad(c53.Math.wrapAngle(a));
            }
        }
    }, c53.Component.Animation = function() {}, c53.Component.Animation.prototype = {
        play: function(a, b, c, d) {
            if (this.animations) return this.animations.play(a, b, c, d);
        }
    }, c53.Component.AutoCull = function() {}, c53.Component.AutoCull.prototype = {
        autoCull: !1,
        inCamera: {
            get: function() {
                return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds);
            }
        }
    }, c53.Component.Bounds = function() {}, c53.Component.Bounds.prototype = {
        offsetX: {
            get: function() {
                return this.anchor.x * this.width;
            }
        },
        offsetY: {
            get: function() {
                return this.anchor.y * this.height;
            }
        },
        centerX: {
            get: function() {
                return this.x - this.offsetX + 0.5 * this.width;
            },
            set: function(a) {
                this.x = a + this.offsetX - 0.5 * this.width;
            }
        },
        centerY: {
            get: function() {
                return this.y - this.offsetY + 0.5 * this.height;
            },
            set: function(a) {
                this.y = a + this.offsetY - 0.5 * this.height;
            }
        },
        left: {
            get: function() {
                return this.x - this.offsetX;
            },
            set: function(a) {
                this.x = a + this.offsetX;
            }
        },
        right: {
            get: function() {
                return this.x + this.width - this.offsetX;
            },
            set: function(a) {
                this.x = a - this.width + this.offsetX;
            }
        },
        top: {
            get: function() {
                return this.y - this.offsetY;
            },
            set: function(a) {
                this.y = a + this.offsetY;
            }
        },
        bottom: {
            get: function() {
                return this.y + this.height - this.offsetY;
            },
            set: function(a) {
                this.y = a - this.height + this.offsetY;
            }
        },
        alignIn: function(a, b, d, e) {
            switch(void 0 === d && (d = 0), void 0 === e && (e = 0), b){
                default:
                case c53.TOP_LEFT:
                    this.left = a.left - d, this.top = a.top - e;
                    break;
                case c53.TOP_CENTER:
                    this.centerX = a.centerX + d, this.top = a.top - e;
                    break;
                case c53.TOP_RIGHT:
                    this.right = a.right + d, this.top = a.top - e;
                    break;
                case c53.LEFT_CENTER:
                    this.left = a.left - d, this.centerY = a.centerY + e;
                    break;
                case c53.CENTER:
                    this.centerX = a.centerX + d, this.centerY = a.centerY + e;
                    break;
                case c53.RIGHT_CENTER:
                    this.right = a.right + d, this.centerY = a.centerY + e;
                    break;
                case c53.BOTTOM_LEFT:
                    this.left = a.left - d, this.bottom = a.bottom + e;
                    break;
                case c53.BOTTOM_CENTER:
                    this.centerX = a.centerX + d, this.bottom = a.bottom + e;
                    break;
                case c53.BOTTOM_RIGHT:
                    this.right = a.right + d, this.bottom = a.bottom + e;
            }
            return this;
        },
        alignTo: function(a, b, d, e) {
            switch(void 0 === d && (d = 0), void 0 === e && (e = 0), b){
                default:
                case c53.TOP_LEFT:
                    this.left = a.left - d, this.bottom = a.top - e;
                    break;
                case c53.TOP_CENTER:
                    this.centerX = a.centerX + d, this.bottom = a.top - e;
                    break;
                case c53.TOP_RIGHT:
                    this.right = a.right + d, this.bottom = a.top - e;
                    break;
                case c53.LEFT_TOP:
                    this.right = a.left - d, this.top = a.top - e;
                    break;
                case c53.LEFT_CENTER:
                    this.right = a.left - d, this.centerY = a.centerY + e;
                    break;
                case c53.LEFT_BOTTOM:
                    this.right = a.left - d, this.bottom = a.bottom + e;
                    break;
                case c53.RIGHT_TOP:
                    this.left = a.right + d, this.top = a.top - e;
                    break;
                case c53.RIGHT_CENTER:
                    this.left = a.right + d, this.centerY = a.centerY + e;
                    break;
                case c53.RIGHT_BOTTOM:
                    this.left = a.right + d, this.bottom = a.bottom + e;
                    break;
                case c53.BOTTOM_LEFT:
                    this.left = a.left - d, this.top = a.bottom + e;
                    break;
                case c53.BOTTOM_CENTER:
                    this.centerX = a.centerX + d, this.top = a.bottom + e;
                    break;
                case c53.BOTTOM_RIGHT:
                    this.right = a.right + d, this.top = a.bottom + e;
            }
            return this;
        }
    }, c53.Group.prototype.alignIn = c53.Component.Bounds.prototype.alignIn, c53.Group.prototype.alignTo = c53.Component.Bounds.prototype.alignTo, c53.Component.BringToTop = function() {}, c53.Component.BringToTop.prototype.bringToTop = function() {
        return this.parent && this.parent.bringToTop(this), this;
    }, c53.Component.BringToTop.prototype.sendToBack = function() {
        return this.parent && this.parent.sendToBack(this), this;
    }, c53.Component.BringToTop.prototype.moveUp = function() {
        return this.parent && this.parent.moveUp(this), this;
    }, c53.Component.BringToTop.prototype.moveDown = function() {
        return this.parent && this.parent.moveDown(this), this;
    }, c53.Component.Core = function() {}, c53.Component.Core.skipTypeChecks = !1, c53.Component.Core.install = function(a) {
        c53.Utils.mixinPrototype(this, c53.Component.Core.prototype), this.components = {};
        for(var b = 0; b < a.length; b++){
            var d = a[b], e = !1;
            "Destroy" === d && (e = !0), c53.Utils.mixinPrototype(this, c53.Component[d].prototype, e), this.components[d] = !0;
        }
    }, c53.Component.Core.init = function(a, b, d, e, f) {
        if (!c53.Component.Core.skipTypeChecks) {
            if (!(a instanceof c53.Game)) throw new Error("The value passed as the `game` argument (" + a + ") is not an instance of Phaser.Game.");
            "number" != typeof b && (console.warn("The `x` argument value (%s) should be a number.", b), b = 0), "number" != typeof d && (console.warn("The `y` argument value (%s) should be a number.", d), d = 0);
        }
        this.game = a, this.key = e, this.data = {}, this.position.set(b, d), this.world = new c53.Point(b, d), this.previousPosition = new c53.Point(b, d), this.events = new c53.Events(this), this._bounds = new c53.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new c53.AnimationManager(this)), this.components.LoadTexture && null !== e && this.loadTexture(e, f), this.components.FixedToCamera && (this.cameraOffset = new c53.Point(b, d));
    }, c53.Component.Core.preUpdate = function() {
        if (this.pendingDestroy) return void this.destroy();
        if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
        for(var a = 0; a < this.children.length;){
            var b = this.children[a];
            b.preUpdate(), this === b.parent && a++;
        }
        return !0;
    }, c53.Component.Core.prototype = {
        game: null,
        name: "",
        data: {},
        components: {},
        z: 0,
        events: void 0,
        animations: void 0,
        key: "",
        world: null,
        debug: !1,
        previousPosition: null,
        previousRotation: 0,
        renderOrderID: 0,
        fresh: !0,
        pendingDestroy: !1,
        _bounds: null,
        _exists: !0,
        exists: {
            get: function() {
                return this._exists;
            },
            set: function(a) {
                a ? (this._exists = !0, this.body && this.body.type === c53.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === c53.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1);
            }
        },
        update: function() {},
        postUpdate: function() {
            this.customRender && this.key.render(), this.components.PhysicsBody && c53.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && c53.Component.FixedToCamera.postUpdate.call(this);
            for(var a = 0; a < this.children.length; a++)this.children[a].postUpdate();
        }
    }, c53.Component.Crop = function() {}, c53.Component.Crop.prototype = {
        cropRect: null,
        _crop: null,
        crop: function(a, b) {
            void 0 === b && (b = !1), a ? (b && null !== this.cropRect ? this.cropRect.setTo(a.x, a.y, a.width, a.height) : b && null === this.cropRect ? this.cropRect = new c53.Rectangle(a.x, a.y, a.width, a.height) : this.cropRect = a, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame());
        },
        updateCrop: function() {
            if (this.cropRect) {
                var a = this.texture.crop.x, b = this.texture.crop.y, d = this.texture.crop.width, e = this.texture.crop.height;
                this._crop = c53.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                var f = Math.max(this._frame.x, this._crop.x), g = Math.max(this._frame.y, this._crop.y), h = Math.min(this._frame.right, this._crop.right) - f, i = Math.min(this._frame.bottom, this._crop.bottom) - g;
                this.texture.crop.x = f, this.texture.crop.y = g, this.texture.crop.width = h, this.texture.crop.height = i, this.texture.frame.width = Math.min(h, this.cropRect.width), this.texture.frame.height = Math.min(i, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || a === f && b === g && d === h && e === i || (this.texture.requiresReTint = !0);
            }
        }
    }, c53.Component.Delta = function() {}, c53.Component.Delta.prototype = {
        deltaX: {
            get: function() {
                return this.world.x - this.previousPosition.x;
            }
        },
        deltaY: {
            get: function() {
                return this.world.y - this.previousPosition.y;
            }
        },
        deltaZ: {
            get: function() {
                return this.rotation - this.previousRotation;
            }
        }
    }, c53.Component.Destroy = function() {}, c53.Component.Destroy.prototype = {
        destroyPhase: !1,
        destroy: function(a, b) {
            if (null !== this.game && !this.destroyPhase) {
                void 0 === a && (a = !0), void 0 === b && (b = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof c53.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                var d = this.children.length;
                if (a) for(; d--;)this.children[d].destroy(a);
                else for(; d--;)this.removeChild(this.children[d]);
                this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), c53.Video && this.key instanceof c53.Video && this.key.onChangeSource.remove(this.resizeFrame, this), c53.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), b && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1;
            }
        }
    }, c53.Events = function(a) {
        this.parent = a;
    }, c53.Events.prototype = {
        destroy: function() {
            this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose();
        },
        onAddedToGroup: null,
        onRemovedFromGroup: null,
        onRemovedFromWorld: null,
        onDestroy: null,
        onKilled: null,
        onRevived: null,
        onOutOfBounds: null,
        onEnterBounds: null,
        onInputOver: null,
        onInputOut: null,
        onInputDown: null,
        onInputUp: null,
        onDragStart: null,
        onDragUpdate: null,
        onDragStop: null,
        onAnimationStart: null,
        onAnimationComplete: null,
        onAnimationLoop: null
    }, c53.Events.prototype.constructor = c53.Events;
    for(var f19 in c53.Events.prototype)c53.Events.prototype.hasOwnProperty(f19) && 0 === f19.indexOf("on") && null === c53.Events.prototype[f19] && function(a, b) {
        Object.defineProperty(c53.Events.prototype, a, {
            get: function() {
                return this[b] || (this[b] = new c53.Signal);
            }
        }), c53.Events.prototype[a + "$dispatch"] = function() {
            return this[b] ? this[b].dispatch.apply(this[b], arguments) : null;
        };
    }(f19, "_" + f19);
    c53.Component.FixedToCamera = function() {}, c53.Component.FixedToCamera.postUpdate = function() {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
    }, c53.Component.FixedToCamera.prototype = {
        _fixedToCamera: !1,
        fixedToCamera: {
            get: function() {
                return this._fixedToCamera;
            },
            set: function(a) {
                a ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1;
            }
        },
        cameraOffset: new c53.Point
    }, c53.Component.Health = function() {}, c53.Component.Health.prototype = {
        health: 1,
        maxHealth: 100,
        damage: function(a) {
            return this.alive && (this.health -= a, this.health <= 0 && this.kill()), this;
        },
        setHealth: function(a) {
            return this.health = a, this.health > this.maxHealth && (this.health = this.maxHealth), this;
        },
        heal: function(a) {
            return this.alive && (this.health += a, this.health > this.maxHealth && (this.health = this.maxHealth)), this;
        }
    }, c53.Component.InCamera = function() {}, c53.Component.InCamera.prototype = {
        inCamera: {
            get: function() {
                return this.game.world.camera.view.intersects(this._bounds);
            }
        }
    }, c53.Component.InputEnabled = function() {}, c53.Component.InputEnabled.prototype = {
        input: null,
        inputEnabled: {
            get: function() {
                return this.input && this.input.enabled;
            },
            set: function(a) {
                a ? null === this.input ? (this.input = new c53.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop();
            }
        }
    }, c53.Component.InWorld = function() {}, c53.Component.InWorld.preUpdate = function() {
        if (this.autoCull || this.checkWorldBounds) {
            if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull) {
                if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
            }
            if (this.checkWorldBounds) {
                if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1;
            }
        }
        return !0;
    }, c53.Component.InWorld.prototype = {
        checkWorldBounds: !1,
        outOfBoundsKill: !1,
        outOfCameraBoundsKill: !1,
        _outOfBoundsFired: !1,
        inWorld: {
            get: function() {
                return this.game.world.bounds.intersects(this.getBounds());
            }
        }
    }, c53.Component.LifeSpan = function() {}, c53.Component.LifeSpan.preUpdate = function() {
        return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1);
    }, c53.Component.LifeSpan.prototype = {
        alive: !0,
        lifespan: 0,
        revive: function(a) {
            return void 0 === a && (a = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(a), this.events && this.events.onRevived$dispatch(this), this;
        },
        kill: function() {
            return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this;
        }
    }, c53.Component.LoadTexture = function() {}, c53.Component.LoadTexture.prototype = {
        customRender: !1,
        _frame: null,
        loadTexture: function(a, b, d) {
            a === c53.PENDING_ATLAS ? (a = b, b = 0) : b = b || 0, (d || void 0 === d) && this.animations && this.animations.stop(), this.key = a, this.customRender = !1;
            var e = this.game.cache, f = !0, g = !this.texture.baseTexture.scaleMode;
            if (c53.RenderTexture && a instanceof c53.RenderTexture) this.key = a.key, this.setTexture(a);
            else if (c53.BitmapData && a instanceof c53.BitmapData) this.customRender = !0, this.setTexture(a.texture), f = e.hasFrameData(a.key, c53.Cache.BITMAPDATA) ? !this.animations.loadFrameData(e.getFrameData(a.key, c53.Cache.BITMAPDATA), b) : !this.animations.loadFrameData(a.frameData, 0);
            else if (c53.Video && a instanceof c53.Video) {
                this.customRender = !0;
                var h = a.texture.valid;
                this.setTexture(a.texture), this.setFrame(a.texture.frame.clone()), a.onChangeSource.add(this.resizeFrame, this), this.texture.valid = h;
            } else if (c53.Tilemap && a instanceof c53.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(a.canvas));
            else if (a instanceof PIXI.Texture) this.setTexture(a);
            else {
                var i = e.getImage(a, !0);
                this.key = i.key, this.setTexture(new PIXI.Texture(i.base)), this.texture.baseTexture.skipRender = "__default" === a, f = !this.animations.loadFrameData(i.frameData, b);
            }
            f && (this._frame = c53.Rectangle.clone(this.texture.frame)), g || (this.texture.baseTexture.scaleMode = 1);
        },
        setFrame: function(a) {
            this._frame = a, this.texture.frame.x = a.x, this.texture.frame.y = a.y, this.texture.frame.width = a.width, this.texture.frame.height = a.height, this.texture.crop.x = a.x, this.texture.crop.y = a.y, this.texture.crop.width = a.width, this.texture.crop.height = a.height, a.trimmed ? (this.texture.trim ? (this.texture.trim.x = a.spriteSourceSizeX, this.texture.trim.y = a.spriteSourceSizeY, this.texture.trim.width = a.sourceSizeW, this.texture.trim.height = a.sourceSizeH) : this.texture.trim = {
                x: a.spriteSourceSizeX,
                y: a.spriteSourceSizeY,
                width: a.sourceSizeW,
                height: a.sourceSizeH
            }, this.texture.width = a.sourceSizeW, this.texture.height = a.sourceSizeH, this.texture.frame.width = a.sourceSizeW, this.texture.frame.height = a.sourceSizeH) : !a.trimmed && this.texture.trim && (this.texture.trim = null), a.rotated && (this.texture.rotated = !0), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0);
        },
        resizeFrame: function(a, b, c) {
            this.texture.frame.resize(b, c), this.texture.setFrame(this.texture.frame);
        },
        resetFrame: function() {
            this._frame && this.setFrame(this._frame);
        },
        frame: {
            get: function() {
                return this.animations.frame;
            },
            set: function(a) {
                this.animations.frame = a;
            }
        },
        frameName: {
            get: function() {
                return this.animations.frameName;
            },
            set: function(a) {
                this.animations.frameName = a;
            }
        }
    }, c53.Component.Overlap = function() {}, c53.Component.Overlap.prototype = {
        overlap: function(a) {
            return c53.Rectangle.intersects(this.getBounds(), a.getBounds());
        }
    }, c53.Component.PhysicsBody = function() {}, c53.Component.PhysicsBody.preUpdate = function() {
        return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1));
    }, c53.Component.PhysicsBody.postUpdate = function() {
        this.exists && this.body && this.body.postUpdate();
    }, c53.Component.PhysicsBody.prototype = {
        body: null,
        x: {
            get: function() {
                return this.position.x;
            },
            set: function(a) {
                this.position.x = a, this.body && !this.body.dirty && (this.body._reset = !0);
            }
        },
        y: {
            get: function() {
                return this.position.y;
            },
            set: function(a) {
                this.position.y = a, this.body && !this.body.dirty && (this.body._reset = !0);
            }
        }
    }, c53.Component.Reset = function() {}, c53.Component.Reset.prototype.reset = function(a, b, c) {
        return void 0 === c && (c = 1), this.world.set(a, b), this.position.set(a, b), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = c), this.components.PhysicsBody && this.body && this.body.reset(a, b, !1, !1), this;
    }, c53.Component.ScaleMinMax = function() {}, c53.Component.ScaleMinMax.prototype = {
        transformCallback: null,
        transformCallbackContext: this,
        scaleMin: null,
        scaleMax: null,
        checkTransform: function(a) {
            this.scaleMin && (a.a < this.scaleMin.x && (a.a = this.scaleMin.x), a.d < this.scaleMin.y && (a.d = this.scaleMin.y)), this.scaleMax && (a.a > this.scaleMax.x && (a.a = this.scaleMax.x), a.d > this.scaleMax.y && (a.d = this.scaleMax.y));
        },
        setScaleMinMax: function(a, b, d, e) {
            void 0 === b ? b = d = e = a : void 0 === d && (d = e = b, b = a), null === a ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(a, b) : this.scaleMin = new c53.Point(a, b), null === d ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(d, e) : this.scaleMax = new c53.Point(d, e), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this);
        }
    }, c53.Component.Smoothed = function() {}, c53.Component.Smoothed.prototype = {
        smoothed: {
            get: function() {
                return !this.texture.baseTexture.scaleMode;
            },
            set: function(a) {
                a ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1);
            }
        }
    }, c53.GameObjectFactory = function(a) {
        this.game = a, this.world = this.game.world;
    }, c53.GameObjectFactory.prototype = {
        existing: function(a) {
            return this.world.add(a);
        },
        weapon: function(a, b, d, e, f) {
            var g = this.game.plugins.add(c53.Weapon);
            return f && (g.bulletClass = f), g.createBullets(a, b, d, e), g;
        },
        image: function(a, b, d, e, f) {
            return void 0 === f && (f = this.world), f.add(new c53.Image(this.game, a, b, d, e));
        },
        sprite: function(a, b, c, d, e) {
            return void 0 === e && (e = this.world), e.create(a, b, c, d);
        },
        creature: function(a, b, d, e, f) {
            void 0 === f && (f = this.world);
            var g = new c53.Creature(this.game, a, b, d, e);
            return f.add(g), g;
        },
        tween: function(a) {
            return this.game.tweens.create(a);
        },
        group: function(a, b, d, e, f) {
            return new c53.Group(this.game, a, b, d, e, f);
        },
        physicsGroup: function(a, b, d, e) {
            return new c53.Group(this.game, b, d, e, !0, a);
        },
        spriteBatch: function(a, b, d) {
            return void 0 === a && (a = null), void 0 === b && (b = "group"), void 0 === d && (d = !1), new c53.SpriteBatch(this.game, a, b, d);
        },
        audio: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d);
        },
        sound: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d);
        },
        audioSprite: function(a) {
            return this.game.sound.addSprite(a);
        },
        tileSprite: function(a, b, d, e, f, g, h) {
            return void 0 === h && (h = this.world), h.add(new c53.TileSprite(this.game, a, b, d, e, f, g));
        },
        rope: function(a, b, d, e, f, g) {
            return void 0 === g && (g = this.world), g.add(new c53.Rope(this.game, a, b, d, e, f));
        },
        text: function(a, b, d, e, f) {
            return void 0 === f && (f = this.world), f.add(new c53.Text(this.game, a, b, d, e));
        },
        button: function(a, b, d, e, f, g, h, i, j, k) {
            return void 0 === k && (k = this.world), k.add(new c53.Button(this.game, a, b, d, e, f, g, h, i, j));
        },
        graphics: function(a, b, d) {
            return void 0 === d && (d = this.world), d.add(new c53.Graphics(this.game, a, b));
        },
        emitter: function(a, b, d) {
            return this.game.particles.add(new c53.Particles.Arcade.Emitter(this.game, a, b, d));
        },
        retroFont: function(a, b, d, e, f, g, h, i, j) {
            return new c53.RetroFont(this.game, a, b, d, e, f, g, h, i, j);
        },
        bitmapText: function(a, b, d, e, f, g) {
            return void 0 === g && (g = this.world), g.add(new c53.BitmapText(this.game, a, b, d, e, f));
        },
        tilemap: function(a, b, d, e, f) {
            return new c53.Tilemap(this.game, a, b, d, e, f);
        },
        renderTexture: function(a, b, d, e) {
            void 0 !== d && "" !== d || (d = this.game.rnd.uuid()), void 0 === e && (e = !1);
            var f = new c53.RenderTexture(this.game, a, b, d);
            return e && this.game.cache.addRenderTexture(d, f), f;
        },
        video: function(a, b) {
            return new c53.Video(this.game, a, b);
        },
        bitmapData: function(a, b, d, e) {
            void 0 === e && (e = !1), void 0 !== d && "" !== d || (d = this.game.rnd.uuid());
            var f = new c53.BitmapData(this.game, d, a, b);
            return e && this.game.cache.addBitmapData(d, f), f;
        },
        filter: function(a) {
            var b = Array.prototype.slice.call(arguments, 1), a = new c53.Filter[a](this.game);
            return a.init.apply(a, b), a;
        },
        plugin: function(a) {
            return this.game.plugins.add(a);
        }
    }, c53.GameObjectFactory.prototype.constructor = c53.GameObjectFactory, c53.GameObjectCreator = function(a) {
        this.game = a, this.world = this.game.world;
    }, c53.GameObjectCreator.prototype = {
        image: function(a, b, d, e) {
            return new c53.Image(this.game, a, b, d, e);
        },
        sprite: function(a, b, d, e) {
            return new c53.Sprite(this.game, a, b, d, e);
        },
        tween: function(a) {
            return new c53.Tween(a, this.game, this.game.tweens);
        },
        group: function(a, b, d, e, f) {
            return new c53.Group(this.game, a, b, d, e, f);
        },
        spriteBatch: function(a, b, d) {
            return void 0 === b && (b = "group"), void 0 === d && (d = !1), new c53.SpriteBatch(this.game, a, b, d);
        },
        audio: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d);
        },
        audioSprite: function(a) {
            return this.game.sound.addSprite(a);
        },
        sound: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d);
        },
        tileSprite: function(a, b, d, e, f, g) {
            return new c53.TileSprite(this.game, a, b, d, e, f, g);
        },
        rope: function(a, b, d, e, f) {
            return new c53.Rope(this.game, a, b, d, e, f);
        },
        text: function(a, b, d, e) {
            return new c53.Text(this.game, a, b, d, e);
        },
        button: function(a, b, d, e, f, g, h, i, j) {
            return new c53.Button(this.game, a, b, d, e, f, g, h, i, j);
        },
        graphics: function(a, b) {
            return new c53.Graphics(this.game, a, b);
        },
        emitter: function(a, b, d) {
            return new c53.Particles.Arcade.Emitter(this.game, a, b, d);
        },
        retroFont: function(a, b, d, e, f, g, h, i, j) {
            return new c53.RetroFont(this.game, a, b, d, e, f, g, h, i, j);
        },
        bitmapText: function(a, b, d, e, f, g) {
            return new c53.BitmapText(this.game, a, b, d, e, f, g);
        },
        tilemap: function(a, b, d, e, f) {
            return new c53.Tilemap(this.game, a, b, d, e, f);
        },
        renderTexture: function(a, b, d, e) {
            void 0 !== d && "" !== d || (d = this.game.rnd.uuid()), void 0 === e && (e = !1);
            var f = new c53.RenderTexture(this.game, a, b, d);
            return e && this.game.cache.addRenderTexture(d, f), f;
        },
        bitmapData: function(a, b, d, e) {
            void 0 === e && (e = !1), void 0 !== d && "" !== d || (d = this.game.rnd.uuid());
            var f = new c53.BitmapData(this.game, d, a, b);
            return e && this.game.cache.addBitmapData(d, f), f;
        },
        filter: function(a) {
            var b = Array.prototype.slice.call(arguments, 1), a = new c53.Filter[a](this.game);
            return a.init.apply(a, b), a;
        }
    }, c53.GameObjectCreator.prototype.constructor = c53.GameObjectCreator, c53.Sprite = function(a, b, d, e, f) {
        b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c53.SPRITE, this.physicsType = c53.SPRITE, PIXI.Sprite.call(this, c53.Cache.DEFAULT), c53.Component.Core.init.call(this, a, b, d, e, f);
    }, c53.Sprite.prototype = Object.create(PIXI.Sprite.prototype), c53.Sprite.prototype.constructor = c53.Sprite, c53.Component.Core.install.call(c53.Sprite.prototype, [
        "Angle",
        "Animation",
        "AutoCull",
        "Bounds",
        "BringToTop",
        "Crop",
        "Delta",
        "Destroy",
        "FixedToCamera",
        "Health",
        "InCamera",
        "InputEnabled",
        "InWorld",
        "LifeSpan",
        "LoadTexture",
        "Overlap",
        "PhysicsBody",
        "Reset",
        "ScaleMinMax",
        "Smoothed"
    ]), c53.Sprite.prototype.preUpdatePhysics = c53.Component.PhysicsBody.preUpdate, c53.Sprite.prototype.preUpdateLifeSpan = c53.Component.LifeSpan.preUpdate, c53.Sprite.prototype.preUpdateInWorld = c53.Component.InWorld.preUpdate, c53.Sprite.prototype.preUpdateCore = c53.Component.Core.preUpdate, c53.Sprite.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    }, c53.Image = function(a, b, d, e, f) {
        b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c53.IMAGE, PIXI.Sprite.call(this, c53.Cache.DEFAULT), c53.Component.Core.init.call(this, a, b, d, e, f);
    }, c53.Image.prototype = Object.create(PIXI.Sprite.prototype), c53.Image.prototype.constructor = c53.Image, c53.Component.Core.install.call(c53.Image.prototype, [
        "Angle",
        "Animation",
        "AutoCull",
        "Bounds",
        "BringToTop",
        "Crop",
        "Destroy",
        "FixedToCamera",
        "InputEnabled",
        "LifeSpan",
        "LoadTexture",
        "Overlap",
        "Reset",
        "ScaleMinMax",
        "Smoothed"
    ]), c53.Image.prototype.preUpdateLifeSpan = c53.Component.LifeSpan.preUpdate, c53.Image.prototype.preUpdateInWorld = c53.Component.InWorld.preUpdate, c53.Image.prototype.preUpdateCore = c53.Component.Core.preUpdate, c53.Image.prototype.preUpdate = function() {
        return !(!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore();
    }, c53.Button = function(a, b, d, e, f, g, h, i, j, k) {
        b = b || 0, d = d || 0, e = e || null, f = f || null, g = g || this, c53.Image.call(this, a, b, d, e, i), this.type = c53.BUTTON, this.physicsType = c53.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new c53.Signal, this.onInputOut = new c53.Signal, this.onInputDown = new c53.Signal, this.onInputUp = new c53.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = c53.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(h, i, j, k), null !== f && this.onInputUp.add(f, g), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this);
    }, c53.Button.prototype = Object.create(c53.Image.prototype), c53.Button.prototype.constructor = c53.Button;
    var g19 = "Over", h15 = "Out", i13 = "Down", j10 = "Up";
    return c53.Button.prototype.clearFrames = function() {
        this.setFrames(null, null, null, null);
    }, c53.Button.prototype.removedFromWorld = function() {
        this.inputEnabled = !1;
    }, c53.Button.prototype.setStateFrame = function(a, b, c) {
        var d = "_on" + a + "Frame";
        null !== b ? (this[d] = b, c && this.changeStateFrame(a)) : this[d] = null;
    }, c53.Button.prototype.changeStateFrame = function(a) {
        if (this.freezeFrames) return !1;
        var b = "_on" + a + "Frame", c = this[b];
        return "string" == typeof c ? (this.frameName = c, !0) : "number" == typeof c && (this.frame = c, !0);
    }, c53.Button.prototype.setFrames = function(a, b, c, d) {
        this.setStateFrame(g19, a, this.input.pointerOver()), this.setStateFrame(h15, b, !this.input.pointerOver()), this.setStateFrame(i13, c, this.input.pointerDown()), this.setStateFrame(j10, d, this.input.pointerUp());
    }, c53.Button.prototype.setStateSound = function(a, b, d) {
        var e = "on" + a + "Sound", f = "on" + a + "SoundMarker";
        b instanceof c53.Sound || b instanceof c53.AudioSprite ? (this[e] = b, this[f] = "string" == typeof d ? d : "") : (this[e] = null, this[f] = "");
    }, c53.Button.prototype.playStateSound = function(a) {
        var b = "on" + a + "Sound", c = this[b];
        if (c) {
            var d = "on" + a + "SoundMarker", e = this[d];
            return c.play(e), !0;
        }
        return !1;
    }, c53.Button.prototype.setSounds = function(a, b, c, d, e, f, k, l) {
        this.setStateSound(g19, a, b), this.setStateSound(h15, e, f), this.setStateSound(i13, c, d), this.setStateSound(j10, k, l);
    }, c53.Button.prototype.setOverSound = function(a, b) {
        this.setStateSound(g19, a, b);
    }, c53.Button.prototype.setOutSound = function(a, b) {
        this.setStateSound(h15, a, b);
    }, c53.Button.prototype.setDownSound = function(a, b) {
        this.setStateSound(i13, a, b);
    }, c53.Button.prototype.setUpSound = function(a, b) {
        this.setStateSound(j10, a, b);
    }, c53.Button.prototype.onInputOverHandler = function(a, b) {
        b.justReleased() && (this.justReleasedPreventsOver & b.pointerMode) === b.pointerMode || (this.changeStateFrame(g19), this.onOverMouseOnly && !b.isMouse || (this.playStateSound(g19), this.onInputOver && this.onInputOver.dispatch(this, b)));
    }, c53.Button.prototype.onInputOutHandler = function(a, b) {
        this.changeStateFrame(h15), this.playStateSound(h15), this.onInputOut && this.onInputOut.dispatch(this, b);
    }, c53.Button.prototype.onInputDownHandler = function(a, b) {
        this.changeStateFrame(i13), this.playStateSound(i13), this.onInputDown && this.onInputDown.dispatch(this, b);
    }, c53.Button.prototype.onInputUpHandler = function(a, b, c) {
        if (this.playStateSound(j10), this.onInputUp && this.onInputUp.dispatch(this, b, c), !this.freezeFrames) {
            if (!0 === this.forceOut || (this.forceOut & b.pointerMode) === b.pointerMode) this.changeStateFrame(h15);
            else {
                var d = this.changeStateFrame(j10);
                d || (c ? this.changeStateFrame(g19) : this.changeStateFrame(h15));
            }
        }
    }, c53.SpriteBatch = function(a, b, d, e) {
        void 0 !== b && null !== b || (b = a.world), c53.Group.call(this, a, b, d, e), this.type = c53.SPRITEBATCH, this.fastSpriteBatch = null, this.ready = !1;
    }, c53.SpriteBatch.prototype = Object.create(c53.Group.prototype), c53.SpriteBatch.prototype.constructor = c53.SpriteBatch, c53.SpriteBatch.prototype._renderWebGL = function(a) {
        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || (this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(a.gl), this.ready = !0), this.fastSpriteBatch.gl !== a.gl && this.fastSpriteBatch.setContext(a.gl), a.spriteBatch.stop(), a.shaderManager.setShader(a.shaderManager.fastShader), this.fastSpriteBatch.begin(this, a), this.fastSpriteBatch.render(this), a.spriteBatch.start());
    }, c53.SpriteBatch.prototype._renderCanvas = function(a) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var b = a.context;
            b.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
            for(var c = this.worldTransform, d = !0, e = 0; e < this.children.length; e++){
                var f = this.children[e];
                if (f.visible) {
                    var g = f.texture, h = g.frame;
                    if (b.globalAlpha = this.worldAlpha * f.alpha, f.rotation % (2 * Math.PI) == 0) d && (b.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty), d = !1), b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * (-h.width * f.scale.x) + f.position.x + 0.5 + a.shakeX | 0, f.anchor.y * (-h.height * f.scale.y) + f.position.y + 0.5 + a.shakeY | 0, h.width * f.scale.x, h.height * f.scale.y);
                    else {
                        d || (d = !0), f.displayObjectUpdateTransform();
                        var i = f.worldTransform, j = i.tx * a.resolution + a.shakeX, k = i.ty * a.resolution + a.shakeY;
                        a.roundPixels ? b.setTransform(i.a, i.b, i.c, i.d, 0 | j, 0 | k) : b.setTransform(i.a, i.b, i.c, i.d, j, k), b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width + 0.5 | 0, f.anchor.y * -h.height + 0.5 | 0, h.width, h.height);
                    }
                }
            }
        }
    }, c53.BitmapData = function(a, b, d, e, f) {
        void 0 !== d && 0 !== d || (d = 256), void 0 !== e && 0 !== e || (e = 256), void 0 === f && (f = !1), this.game = a, this.key = b, this.width = d, this.height = e, this.canvas = c53.Canvas.create(this, d, e, null, f), this.context = this.canvas.getContext("2d", {
            alpha: !0
        }), this.ctx = this.context, this.smoothProperty = a.renderType === c53.CANVAS ? a.renderer.renderSession.smoothProperty : c53.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, d, e), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas, null, this.game.resolution), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new c53.FrameData, this.textureFrame = this.frameData.addFrame(new c53.Frame(0, 0, 0, d, e, "bitmapData")), this.texture.frame = this.textureFrame, this.type = c53.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new c53.Point, this._size = new c53.Point, this._scale = new c53.Point, this._rotate = 0, this._alpha = {
            prev: 1,
            current: 1
        }, this._anchor = new c53.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new c53.Circle, this._swapCanvas = void 0;
    }, c53.BitmapData.prototype = {
        move: function(a, b, c) {
            return 0 !== a && this.moveH(a, c), 0 !== b && this.moveV(b, c), this;
        },
        moveH: function(a, b) {
            void 0 === b && (b = !0), void 0 === this._swapCanvas && (this._swapCanvas = c53.CanvasPool.create(this, this.width, this.height));
            var d = this._swapCanvas, e = d.getContext("2d"), f = this.height, g = this.canvas;
            if (e.clearRect(0, 0, this.width, this.height), a < 0) {
                a = Math.abs(a);
                var h = this.width - a;
                b && e.drawImage(g, 0, 0, a, f, h, 0, a, f), e.drawImage(g, a, 0, h, f, 0, 0, h, f);
            } else {
                var h = this.width - a;
                b && e.drawImage(g, h, 0, a, f, 0, 0, a, f), e.drawImage(g, 0, 0, h, f, a, 0, h, f);
            }
            return this.clear(), this.copy(this._swapCanvas);
        },
        moveV: function(a, b) {
            void 0 === b && (b = !0), void 0 === this._swapCanvas && (this._swapCanvas = c53.CanvasPool.create(this, this.width, this.height));
            var d = this._swapCanvas, e = d.getContext("2d"), f = this.width, g = this.canvas;
            if (e.clearRect(0, 0, this.width, this.height), a < 0) {
                a = Math.abs(a);
                var h = this.height - a;
                b && e.drawImage(g, 0, 0, f, a, 0, h, f, a), e.drawImage(g, 0, a, f, h, 0, 0, f, h);
            } else {
                var h = this.height - a;
                b && e.drawImage(g, 0, h, f, a, 0, 0, f, a), e.drawImage(g, 0, 0, f, h, 0, a, f, h);
            }
            return this.clear(), this.copy(this._swapCanvas);
        },
        add: function(a) {
            if (Array.isArray(a)) for(var b = 0; b < a.length; b++)a[b].loadTexture && a[b].loadTexture(this);
            else a.loadTexture(this);
            return this;
        },
        load: function(a) {
            if ("string" == typeof a && (a = this.game.cache.getImage(a)), a) return this.resize(a.width, a.height), this.cls(), this.draw(a), this.update(), this;
        },
        clear: function(a, b, c, d) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.width), void 0 === d && (d = this.height), this.context.clearRect(a, b, c, d), this.dirty = !0, this;
        },
        fill: function(a, b, c, d) {
            return void 0 === d && (d = 1), this.context.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this;
        },
        generateTexture: function(a, b, c) {
            var d = this.game.cache, e = new Image;
            if (b && (e.onload = function() {
                var f = d.addImage(a, "", e), g = new PIXI.Texture(f.base);
                b.call(c || null, g), e.onload = null;
            }), e.src = this.canvas.toDataURL("image/png"), !b) {
                var f20 = d.addImage(a, "", e);
                return new PIXI.Texture(f20.base);
            }
            return null;
        },
        resize: function(a, b) {
            return a === this.width && b === this.height || (this.width = a, this.height = b, this.canvas.width = a, this.canvas.height = b, void 0 !== this._swapCanvas && (this._swapCanvas.width = a, this._swapCanvas.height = b), this.baseTexture.width = a, this.baseTexture.height = b, this.textureFrame.width = a, this.textureFrame.height = b, this.texture.width = a, this.texture.height = b, this.texture.crop.width = a, this.texture.crop.height = b, this.update(), this.dirty = !0), this;
        },
        update: function(a, b, c, d) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = Math.max(1, this.width)), void 0 === d && (d = Math.max(1, this.height)), this.imageData = this.context.getImageData(a, b, c, d), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this;
        },
        processPixelRGB: function(a, b, d, e, f, g) {
            void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = this.width), void 0 === g && (g = this.height);
            for(var h = d + f, i = e + g, j = c53.Color.createColor(), k = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }, l = !1, m = e; m < i; m++)for(var n = d; n < h; n++)c53.Color.unpackPixel(this.getPixel32(n, m), j), !1 !== (k = a.call(b, j, n, m)) && null !== k && void 0 !== k && (this.setPixel32(n, m, k.r, k.g, k.b, k.a, !1), l = !0);
            return l && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this;
        },
        processPixel: function(a, b, c, d, e, f) {
            void 0 === c && (c = 0), void 0 === d && (d = 0), void 0 === e && (e = this.width), void 0 === f && (f = this.height);
            for(var g = c + e, h = d + f, i = 0, j = 0, k = !1, l = d; l < h; l++)for(var m = c; m < g; m++)i = this.getPixel32(m, l), (j = a.call(b, i, m, l)) !== i && (this.pixels[l * this.width + m] = j, k = !0);
            return k && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this;
        },
        replaceRGB: function(a, b, d, e, f, g, h, i, j) {
            var k = 0, l = 0, m = this.width, n = this.height, o = c53.Color.packPixel(a, b, d, e);
            void 0 !== j && j instanceof c53.Rectangle && (k = j.x, l = j.y, m = j.width, n = j.height);
            for(var p = 0; p < n; p++)for(var q = 0; q < m; q++)this.getPixel32(k + q, l + p) === o && this.setPixel32(k + q, l + p, f, g, h, i, !1);
            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
        },
        setHSL: function(a, b, d, e) {
            var f = a || 0 === a, g = b || 0 === b, h = d || 0 === d;
            if (f || g || h) {
                void 0 === e && (e = new c53.Rectangle(0, 0, this.width, this.height));
                for(var i = c53.Color.createColor(), j = e.y; j < e.bottom; j++)for(var k = e.x; k < e.right; k++)c53.Color.unpackPixel(this.getPixel32(k, j), i, !0), f && (i.h = a), g && (i.s = b), h && (i.l = d), c53.Color.HSLtoRGB(i.h, i.s, i.l, i), this.setPixel32(k, j, i.r, i.g, i.b, i.a, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
            }
        },
        shiftHSL: function(a, b, d, e) {
            if (void 0 !== a && null !== a || (a = !1), void 0 !== b && null !== b || (b = !1), void 0 !== d && null !== d || (d = !1), a || b || d) {
                void 0 === e && (e = new c53.Rectangle(0, 0, this.width, this.height));
                for(var f = c53.Color.createColor(), g = e.y; g < e.bottom; g++)for(var h = e.x; h < e.right; h++)c53.Color.unpackPixel(this.getPixel32(h, g), f, !0), a && (f.h = this.game.math.wrap(f.h + a, 0, 1)), b && (f.s = this.game.math.clamp(f.s + b, 0, 1)), d && (f.l = this.game.math.clamp(f.l + d, 0, 1)), c53.Color.HSLtoRGB(f.h, f.s, f.l, f), this.setPixel32(h, g, f.r, f.g, f.b, f.a, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
            }
        },
        setPixel32: function(a, b, d, e, f, g, h) {
            return void 0 === h && (h = !0), a >= 0 && a <= this.width && b >= 0 && b <= this.height && (c53.Device.LITTLE_ENDIAN ? this.pixels[b * this.width + a] = g << 24 | f << 16 | e << 8 | d : this.pixels[b * this.width + a] = d << 24 | e << 16 | f << 8 | g, h && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this;
        },
        setPixel: function(a, b, c, d, e, f) {
            return this.setPixel32(a, b, c, d, e, 255, f);
        },
        getPixel: function(a, b, d) {
            d || (d = c53.Color.createColor());
            var e = ~~(a + b * this.width);
            return e *= 4, d.r = this.data[e], d.g = this.data[++e], d.b = this.data[++e], d.a = this.data[++e], d;
        },
        getPixel32: function(a, b) {
            if (a >= 0 && a <= this.width && b >= 0 && b <= this.height) return this.pixels[b * this.width + a];
        },
        getPixelRGB: function(a, b, d, e, f) {
            return c53.Color.unpackPixel(this.getPixel32(a, b), d, e, f);
        },
        getPixels: function(a) {
            return this.context.getImageData(a.x, a.y, a.width, a.height);
        },
        getFirstPixel: function(a) {
            void 0 === a && (a = 0);
            var b = c53.Color.createColor(), d = 0, e = 0, f = 1, g = !1;
            1 === a ? (f = -1, e = this.height) : 3 === a && (f = -1, d = this.width);
            do c53.Color.unpackPixel(this.getPixel32(d, e), b), 0 === a || 1 === a ? ++d === this.width && (d = 0, ((e += f) >= this.height || e <= 0) && (g = !0)) : 2 !== a && 3 !== a || ++e === this.height && (e = 0, ((d += f) >= this.width || d <= 0) && (g = !0));
            while (0 === b.a && !g)
            return b.x = d, b.y = e, b;
        },
        getBounds: function(a) {
            return void 0 === a && (a = new c53.Rectangle), a.x = this.getFirstPixel(2).x, a.x === this.width ? a.setTo(0, 0, 0, 0) : (a.y = this.getFirstPixel(0).y, a.width = this.getFirstPixel(3).x - a.x + 1, a.height = this.getFirstPixel(1).y - a.y + 1, a);
        },
        addToWorld: function(a, b, c, d, e, f) {
            e = e || 1, f = f || 1;
            var g = this.game.add.image(a, b, this);
            return g.anchor.set(c, d), g.scale.set(e, f), g;
        },
        copy: function(a, b, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
            if (void 0 !== a && null !== a || (a = this), a instanceof c53.RenderTexture && (a = a.getCanvas()), this._image = a, a instanceof c53.Sprite || a instanceof c53.Image || a instanceof c53.Text || a instanceof PIXI.Sprite) this._pos.set(a.texture.crop.x, a.texture.crop.y), this._size.set(a.texture.crop.width, a.texture.crop.height), this._scale.set(a.scale.x, a.scale.y), this._anchor.set(a.anchor.x, a.anchor.y), this._rotate = a.rotation, this._alpha.current = a.alpha, a.texture instanceof c53.RenderTexture ? this._image = a.texture.getCanvas() : this._image = a.texture.baseTexture.source, void 0 !== g && null !== g || (g = a.x), void 0 !== h && null !== h || (h = a.y), a.texture.trim && (g += a.texture.trim.x - a.anchor.x * a.texture.trim.width, h += a.texture.trim.y - a.anchor.y * a.texture.trim.height), 16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint, a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)), this._image = a.tintedTexture, this._pos.set(0));
            else {
                if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, a instanceof c53.BitmapData) this._image = a.canvas;
                else if ("string" == typeof a) {
                    if (null === (a = this.game.cache.getImage(a))) return;
                    this._image = a;
                }
                this._size.set(this._image.width, this._image.height);
            }
            if (void 0 !== b && null !== b || (b = 0), void 0 !== d && null !== d || (d = 0), e && (this._size.x = e), f && (this._size.y = f), void 0 !== g && null !== g || (g = b), void 0 !== h && null !== h || (h = d), void 0 !== i && null !== i || (i = this._size.x), void 0 !== j && null !== j || (j = this._size.y), "number" == typeof k && (this._rotate = k), "number" == typeof l && (this._anchor.x = l), "number" == typeof m && (this._anchor.y = m), "number" == typeof n && (this._scale.x = n), "number" == typeof o && (this._scale.y = o), "number" == typeof p && (this._alpha.current = p), void 0 === q && (q = null), void 0 === r && (r = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                var s = this.context;
                return this._alpha.prev = s.globalAlpha, s.save(), s.globalAlpha = this._alpha.current, q && (this.op = q), r && (g |= 0, h |= 0), s.translate(g, h), s.scale(this._scale.x, this._scale.y), s.rotate(this._rotate), s.drawImage(this._image, this._pos.x + b, this._pos.y + d, this._size.x, this._size.y, -i * this._anchor.x, -j * this._anchor.y, i, j), s.restore(), s.globalAlpha = this._alpha.prev, this.dirty = !0, this;
            }
        },
        copyTransform: function(a, b, d) {
            if (void 0 === b && (b = null), void 0 === d && (d = !1), !a.hasOwnProperty("worldTransform") || !a.worldVisible || 0 === a.worldAlpha) return this;
            var e = a.worldTransform;
            if (this._pos.set(a.texture.crop.x, a.texture.crop.y), this._size.set(a.texture.crop.width, a.texture.crop.height), 0 === e.a || 0 === e.d || 0 === this._size.x || 0 === this._size.y) return this;
            a.texture instanceof c53.RenderTexture ? this._image = a.texture.getCanvas() : this._image = a.texture.baseTexture.source;
            var f = e.tx, g = e.ty;
            a.texture.trim && (f += a.texture.trim.x - a.anchor.x * a.texture.trim.width, g += a.texture.trim.y - a.anchor.y * a.texture.trim.height), 16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint, a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)), this._image = a.tintedTexture, this._pos.set(0)), d && (f |= 0, g |= 0);
            var h = this.context;
            return this._alpha.prev = h.globalAlpha, h.save(), h.globalAlpha = this._alpha.current, b && (this.op = b), h[this.smoothProperty] = a.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, h.setTransform(e.a, e.b, e.c, e.d, f, g), h.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * a.anchor.x, -this._size.y * a.anchor.y, this._size.x, this._size.y), h.restore(), h.globalAlpha = this._alpha.prev, this.dirty = !0, this;
        },
        copyRect: function(a, b, c, d, e, f, g) {
            return this.copy(a, b.x, b.y, b.width, b.height, c, d, b.width, b.height, 0, 0, 0, 1, 1, e, f, g);
        },
        draw: function(a, b, c, d, e, f, g) {
            return this.copy(a, null, null, null, null, b, c, d, e, null, null, null, null, null, null, f, g);
        },
        drawGroup: function(a, b, c) {
            return a.total > 0 && a.forEachExists(this.drawGroupProxy, this, b, c), this;
        },
        drawGroupProxy: function(a, b, d) {
            if (a.hasOwnProperty("texture") && this.copyTransform(a, b, d), a.type === c53.GROUP && a.exists) this.drawGroup(a, b, d);
            else if (a.hasOwnProperty("children") && a.children.length > 0) for(var e = 0; e < a.children.length; e++)a.children[e].exists && this.copyTransform(a.children[e], b, d);
        },
        drawFull: function(a, b, d) {
            if (!1 === a.worldVisible || 0 === a.worldAlpha || a.hasOwnProperty("exists") && !1 === a.exists) return this;
            if (a.type !== c53.GROUP && a.type !== c53.EMITTER && a.type !== c53.BITMAPTEXT) {
                if (a.type === c53.GRAPHICS) {
                    var e = a.getBounds();
                    this.ctx.save(), this.ctx.translate(e.x, e.y), PIXI.CanvasGraphics.renderGraphics(a, this.ctx), this.ctx.restore();
                } else this.copy(a, null, null, null, null, a.worldPosition.x, a.worldPosition.y, null, null, a.worldRotation, null, null, a.worldScale.x, a.worldScale.y, a.worldAlpha, b, d);
            }
            if (a.children) for(var f = 0; f < a.children.length; f++)this.drawFull(a.children[f], b, d);
            return this;
        },
        shadow: function(a, b, c, d) {
            var e = this.context;
            return void 0 === a || null === a ? e.shadowColor = "rgba(0,0,0,0)" : (e.shadowColor = a, e.shadowBlur = b || 5, e.shadowOffsetX = c || 10, e.shadowOffsetY = d || 10), this;
        },
        alphaMask: function(a, b, c, d) {
            return void 0 === d || null === d ? this.draw(b).blendSourceAtop() : this.draw(b, d.x, d.y, d.width, d.height).blendSourceAtop(), void 0 === c || null === c ? this.draw(a).blendReset() : this.draw(a, c.x, c.y, c.width, c.height).blendReset(), this;
        },
        extract: function(a, b, c, d, e, f21, g, h, i) {
            return void 0 === e && (e = 255), void 0 === f21 && (f21 = !1), void 0 === g && (g = b), void 0 === h && (h = c), void 0 === i && (i = d), f21 && a.resize(this.width, this.height), this.processPixelRGB(function(f, j, k) {
                return f.r === b && f.g === c && f.b === d && a.setPixel32(j, k, g, h, i, e, !1), !1;
            }, this), a.context.putImageData(a.imageData, 0, 0), a.dirty = !0, a;
        },
        rect: function(a, b, c, d, e) {
            return void 0 !== e && (this.context.fillStyle = e), this.context.fillRect(a, b, c, d), this;
        },
        text: function(a, b, c, d, e, f) {
            void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = "14px Courier"), void 0 === e && (e = "rgb(255,255,255)"), void 0 === f && (f = !0);
            var g = this.context, h = g.font;
            return g.font = d, f && (g.fillStyle = "rgb(0,0,0)", g.fillText(a, b + 1, c + 1)), g.fillStyle = e, g.fillText(a, b, c), g.font = h, this;
        },
        circle: function(a, b, c, d) {
            var e = this.context;
            return void 0 !== d && (e.fillStyle = d), e.beginPath(), e.arc(a, b, c, 0, 2 * Math.PI, !1), e.closePath(), e.fill(), this;
        },
        line: function(a, b, c, d, e, f) {
            void 0 === e && (e = "#fff"), void 0 === f && (f = 1);
            var g = this.context;
            return g.beginPath(), g.moveTo(a, b), g.lineTo(c, d), g.lineWidth = f, g.strokeStyle = e, g.stroke(), g.closePath(), this;
        },
        textureLine: function(a, b, d) {
            if (void 0 === d && (d = "repeat-x"), "string" != typeof b || (b = this.game.cache.getImage(b))) {
                var e = a.length;
                "no-repeat" === d && e > b.width && (e = b.width);
                var f = this.context;
                return f.fillStyle = f.createPattern(b, d), this._circle = new c53.Circle(a.start.x, a.start.y, b.height), this._circle.circumferencePoint(a.angle - 1.5707963267948966, !1, this._pos), f.save(), f.translate(this._pos.x, this._pos.y), f.rotate(a.angle), f.fillRect(0, 0, e, b.height), f.restore(), this.dirty = !0, this;
            }
        },
        render: function() {
            return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this;
        },
        destroy: function() {
            this.frameData.destroy(), this.texture.destroy(!0), c53.CanvasPool.remove(this);
        },
        blendReset: function() {
            return this.op = "source-over", this;
        },
        blendSourceOver: function() {
            return this.op = "source-over", this;
        },
        blendSourceIn: function() {
            return this.op = "source-in", this;
        },
        blendSourceOut: function() {
            return this.op = "source-out", this;
        },
        blendSourceAtop: function() {
            return this.op = "source-atop", this;
        },
        blendDestinationOver: function() {
            return this.op = "destination-over", this;
        },
        blendDestinationIn: function() {
            return this.op = "destination-in", this;
        },
        blendDestinationOut: function() {
            return this.op = "destination-out", this;
        },
        blendDestinationAtop: function() {
            return this.op = "destination-atop", this;
        },
        blendXor: function() {
            return this.op = "xor", this;
        },
        blendAdd: function() {
            return this.op = "lighter", this;
        },
        blendMultiply: function() {
            return this.op = "multiply", this;
        },
        blendScreen: function() {
            return this.op = "screen", this;
        },
        blendOverlay: function() {
            return this.op = "overlay", this;
        },
        blendDarken: function() {
            return this.op = "darken", this;
        },
        blendLighten: function() {
            return this.op = "lighten", this;
        },
        blendColorDodge: function() {
            return this.op = "color-dodge", this;
        },
        blendColorBurn: function() {
            return this.op = "color-burn", this;
        },
        blendHardLight: function() {
            return this.op = "hard-light", this;
        },
        blendSoftLight: function() {
            return this.op = "soft-light", this;
        },
        blendDifference: function() {
            return this.op = "difference", this;
        },
        blendExclusion: function() {
            return this.op = "exclusion", this;
        },
        blendHue: function() {
            return this.op = "hue", this;
        },
        blendSaturation: function() {
            return this.op = "saturation", this;
        },
        blendColor: function() {
            return this.op = "color", this;
        },
        blendLuminosity: function() {
            return this.op = "luminosity", this;
        },
        copyBitmapData: function(a, b, c) {
            a.update();
            for(var d, e = 0; e < a.height; e++){
                d = (c + e) * this.width + b;
                for(var f = 0; f < a.width; f++)this.pixels[d + f] = a.pixels[e * a.width + f];
            }
            return this;
        }
    }, Object.defineProperty(c53.BitmapData.prototype, "smoothed", {
        get: function() {
            c53.Canvas.getSmoothingEnabled(this.context);
        },
        set: function(a) {
            c53.Canvas.setSmoothingEnabled(this.context, a);
        }
    }), Object.defineProperty(c53.BitmapData.prototype, "op", {
        get: function() {
            return this.context.globalCompositeOperation;
        },
        set: function(a) {
            this.context.globalCompositeOperation = a;
        }
    }), c53.BitmapData.getTransform = function(a, b, c, d, e, f) {
        return "number" != typeof a && (a = 0), "number" != typeof b && (b = 0), "number" != typeof c && (c = 1), "number" != typeof d && (d = 1), "number" != typeof e && (e = 0), "number" != typeof f && (f = 0), {
            sx: c,
            sy: d,
            scaleX: c,
            scaleY: d,
            skewX: e,
            skewY: f,
            translateX: a,
            translateY: b,
            tx: a,
            ty: b
        };
    }, c53.BitmapData.prototype.constructor = c53.BitmapData, c53.EarCut = {}, c53.EarCut.Triangulate = function(a, b, d) {
        d = d || 2;
        var e = b && b.length, f = e ? b[0] * d : a.length, g = c53.EarCut.linkedList(a, 0, f, d, !0), h = [];
        if (!g) return h;
        var i, j, k, l, m, n, o;
        if (e && (g = c53.EarCut.eliminateHoles(a, b, g, d)), a.length > 80 * d) {
            i = k = a[0], j = l = a[1];
            for(var p = d; p < f; p += d)m = a[p], n = a[p + 1], m < i && (i = m), n < j && (j = n), m > k && (k = m), n > l && (l = n);
            o = Math.max(k - i, l - j);
        }
        return c53.EarCut.earcutLinked(g, h, d, i, j, o), h;
    }, c53.EarCut.linkedList = function(a, b, d, e, f) {
        var g, h, i, j = 0;
        for(g = b, h = d - e; g < d; g += e)j += (a[h] - a[g]) * (a[g + 1] + a[h + 1]), h = g;
        if (f === j > 0) for(g = b; g < d; g += e)i = c53.EarCut.insertNode(g, a[g], a[g + 1], i);
        else for(g = d - e; g >= b; g -= e)i = c53.EarCut.insertNode(g, a[g], a[g + 1], i);
        return i;
    }, c53.EarCut.filterPoints = function(a, b) {
        if (!a) return a;
        b || (b = a);
        var d, e = a;
        do if (d = !1, e.steiner || !c53.EarCut.equals(e, e.next) && 0 !== c53.EarCut.area(e.prev, e, e.next)) e = e.next;
        else {
            if (c53.EarCut.removeNode(e), (e = b = e.prev) === e.next) return null;
            d = !0;
        }
        while (d || e !== b)
        return b;
    }, c53.EarCut.earcutLinked = function(a, b, d, e, f, g, h) {
        if (a) {
            !h && g && c53.EarCut.indexCurve(a, e, f, g);
            for(var i, j, k = a; a.prev !== a.next;)if (i = a.prev, j = a.next, g ? c53.EarCut.isEarHashed(a, e, f, g) : c53.EarCut.isEar(a)) b.push(i.i / d), b.push(a.i / d), b.push(j.i / d), c53.EarCut.removeNode(a), a = j.next, k = j.next;
            else if ((a = j) === k) {
                h ? 1 === h ? (a = c53.EarCut.cureLocalIntersections(a, b, d), c53.EarCut.earcutLinked(a, b, d, e, f, g, 2)) : 2 === h && c53.EarCut.splitEarcut(a, b, d, e, f, g) : c53.EarCut.earcutLinked(c53.EarCut.filterPoints(a), b, d, e, f, g, 1);
                break;
            }
        }
    }, c53.EarCut.isEar = function(a) {
        var b = a.prev, d = a, e = a.next;
        if (c53.EarCut.area(b, d, e) >= 0) return !1;
        for(var f = a.next.next; f !== a.prev;){
            if (c53.EarCut.pointInTriangle(b.x, b.y, d.x, d.y, e.x, e.y, f.x, f.y) && c53.EarCut.area(f.prev, f, f.next) >= 0) return !1;
            f = f.next;
        }
        return !0;
    }, c53.EarCut.isEarHashed = function(a, b, d, e) {
        var f = a.prev, g = a, h = a.next;
        if (c53.EarCut.area(f, g, h) >= 0) return !1;
        for(var i = f.x < g.x ? f.x < h.x ? f.x : h.x : g.x < h.x ? g.x : h.x, j = f.y < g.y ? f.y < h.y ? f.y : h.y : g.y < h.y ? g.y : h.y, k = f.x > g.x ? f.x > h.x ? f.x : h.x : g.x > h.x ? g.x : h.x, l = f.y > g.y ? f.y > h.y ? f.y : h.y : g.y > h.y ? g.y : h.y, m = c53.EarCut.zOrder(i, j, b, d, e), n = c53.EarCut.zOrder(k, l, b, d, e), o = a.nextZ; o && o.z <= n;){
            if (o !== a.prev && o !== a.next && c53.EarCut.pointInTriangle(f.x, f.y, g.x, g.y, h.x, h.y, o.x, o.y) && c53.EarCut.area(o.prev, o, o.next) >= 0) return !1;
            o = o.nextZ;
        }
        for(o = a.prevZ; o && o.z >= m;){
            if (o !== a.prev && o !== a.next && c53.EarCut.pointInTriangle(f.x, f.y, g.x, g.y, h.x, h.y, o.x, o.y) && c53.EarCut.area(o.prev, o, o.next) >= 0) return !1;
            o = o.prevZ;
        }
        return !0;
    }, c53.EarCut.cureLocalIntersections = function(a, b, d) {
        var e = a;
        do {
            var f = e.prev, g = e.next.next;
            c53.EarCut.intersects(f, e, e.next, g) && c53.EarCut.locallyInside(f, g) && c53.EarCut.locallyInside(g, f) && (b.push(f.i / d), b.push(e.i / d), b.push(g.i / d), c53.EarCut.removeNode(e), c53.EarCut.removeNode(e.next), e = a = g), e = e.next;
        }while (e !== a)
        return e;
    }, c53.EarCut.splitEarcut = function(a, b, d, e, f, g) {
        var h = a;
        do {
            for(var i = h.next.next; i !== h.prev;){
                if (h.i !== i.i && c53.EarCut.isValidDiagonal(h, i)) {
                    var j = c53.EarCut.splitPolygon(h, i);
                    return h = c53.EarCut.filterPoints(h, h.next), j = c53.EarCut.filterPoints(j, j.next), c53.EarCut.earcutLinked(h, b, d, e, f, g), void c53.EarCut.earcutLinked(j, b, d, e, f, g);
                }
                i = i.next;
            }
            h = h.next;
        }while (h !== a)
    }, c53.EarCut.eliminateHoles = function(a, b, d, e) {
        var f, g, h, i, j, k = [];
        for(f = 0, g = b.length; f < g; f++)h = b[f] * e, i = f < g - 1 ? b[f + 1] * e : a.length, j = c53.EarCut.linkedList(a, h, i, e, !1), j === j.next && (j.steiner = !0), k.push(c53.EarCut.getLeftmost(j));
        for(k.sort(compareX), f = 0; f < k.length; f++)c53.EarCut.eliminateHole(k[f], d), d = c53.EarCut.filterPoints(d, d.next);
        return d;
    }, c53.EarCut.compareX = function(a, b) {
        return a.x - b.x;
    }, c53.EarCut.eliminateHole = function(a, b) {
        if (b = c53.EarCut.findHoleBridge(a, b)) {
            var d = c53.EarCut.splitPolygon(b, a);
            c53.EarCut.filterPoints(d, d.next);
        }
    }, c53.EarCut.findHoleBridge = function(a, b) {
        var d, e = b, f = a.x, g = a.y, h = -1 / 0;
        do {
            if (g <= e.y && g >= e.next.y) {
                var i = e.x + (g - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
                i <= f && i > h && (h = i, d = e.x < e.next.x ? e : e.next);
            }
            e = e.next;
        }while (e !== b)
        if (!d) return null;
        if (a.x === d.x) return d.prev;
        var j, k = d, l = 1 / 0;
        for(e = d.next; e !== k;)f >= e.x && e.x >= d.x && c53.EarCut.pointInTriangle(g < d.y ? f : h, g, d.x, d.y, g < d.y ? h : f, g, e.x, e.y) && ((j = Math.abs(g - e.y) / (f - e.x)) < l || j === l && e.x > d.x) && c53.EarCut.locallyInside(e, a) && (d = e, l = j), e = e.next;
        return d;
    }, c53.EarCut.indexCurve = function(a, b, d, e) {
        var f = a;
        do null === f.z && (f.z = c53.EarCut.zOrder(f.x, f.y, b, d, e)), f.prevZ = f.prev, f.nextZ = f.next, f = f.next;
        while (f !== a)
        f.prevZ.nextZ = null, f.prevZ = null, c53.EarCut.sortLinked(f);
    }, c53.EarCut.sortLinked = function(a) {
        var b, c, d, e, f, g, h, i, j = 1;
        do {
            for(c = a, a = null, f = null, g = 0; c;){
                for(g++, d = c, h = 0, b = 0; b < j && (h++, d = d.nextZ); b++);
                for(i = j; h > 0 || i > 0 && d;)0 === h ? (e = d, d = d.nextZ, i--) : 0 !== i && d ? c.z <= d.z ? (e = c, c = c.nextZ, h--) : (e = d, d = d.nextZ, i--) : (e = c, c = c.nextZ, h--), f ? f.nextZ = e : a = e, e.prevZ = f, f = e;
                c = d;
            }
            f.nextZ = null, j *= 2;
        }while (g > 1)
        return a;
    }, c53.EarCut.zOrder = function(a, b, c, d, e) {
        return a = 32767 * (a - c) / e, b = 32767 * (b - d) / e, a = 16711935 & (a | a << 8), a = 252645135 & (a | a << 4), a = 858993459 & (a | a << 2), a = 1431655765 & (a | a << 1), b = 16711935 & (b | b << 8), b = 252645135 & (b | b << 4), b = 858993459 & (b | b << 2), b = 1431655765 & (b | b << 1), a | b << 1;
    }, c53.EarCut.getLeftmost = function(a) {
        var b = a, c = a;
        do b.x < c.x && (c = b), b = b.next;
        while (b !== a)
        return c;
    }, c53.EarCut.pointInTriangle = function(a, b, c, d, e, f, g, h) {
        return (e - g) * (b - h) - (a - g) * (f - h) >= 0 && (a - g) * (d - h) - (c - g) * (b - h) >= 0 && (c - g) * (f - h) - (e - g) * (d - h) >= 0;
    }, c53.EarCut.isValidDiagonal = function(a, b) {
        return c53.EarCut.equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !c53.EarCut.intersectsPolygon(a, b) && c53.EarCut.locallyInside(a, b) && c53.EarCut.locallyInside(b, a) && c53.EarCut.middleInside(a, b);
    }, c53.EarCut.area = function(a, b, c) {
        return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
    }, c53.EarCut.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    }, c53.EarCut.intersects = function(a, b, d, e) {
        return c53.EarCut.area(a, b, d) > 0 != c53.EarCut.area(a, b, e) > 0 && c53.EarCut.area(d, e, a) > 0 != c53.EarCut.area(d, e, b) > 0;
    }, c53.EarCut.intersectsPolygon = function(a, b) {
        var d = a;
        do {
            if (d.i !== a.i && d.next.i !== a.i && d.i !== b.i && d.next.i !== b.i && c53.EarCut.intersects(d, d.next, a, b)) return !0;
            d = d.next;
        }while (d !== a)
        return !1;
    }, c53.EarCut.locallyInside = function(a, b) {
        return c53.EarCut.area(a.prev, a, a.next) < 0 ? c53.EarCut.area(a, b, a.next) >= 0 && c53.EarCut.area(a, a.prev, b) >= 0 : c53.EarCut.area(a, b, a.prev) < 0 || c53.EarCut.area(a, a.next, b) < 0;
    }, c53.EarCut.middleInside = function(a, b) {
        var c = a, d = !1, e = (a.x + b.x) / 2, f = (a.y + b.y) / 2;
        do c.y > f != c.next.y > f && e < (c.next.x - c.x) * (f - c.y) / (c.next.y - c.y) + c.x && (d = !d), c = c.next;
        while (c !== a)
        return d;
    }, c53.EarCut.splitPolygon = function(a, b) {
        var d = new c53.EarCut.Node(a.i, a.x, a.y), e = new c53.EarCut.Node(b.i, b.x, b.y), f = a.next, g = b.prev;
        return a.next = b, b.prev = a, d.next = f, f.prev = d, e.next = d, d.prev = e, g.next = e, e.prev = g, e;
    }, c53.EarCut.insertNode = function(a, b, d, e) {
        var f = new c53.EarCut.Node(a, b, d);
        return e ? (f.next = e.next, f.prev = e, e.next.prev = f, e.next = f) : (f.prev = f, f.next = f), f;
    }, c53.EarCut.removeNode = function(a) {
        a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
    }, c53.EarCut.Node = function(a, b, c) {
        this.i = a, this.x = b, this.y = c, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
    }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(a, b) {
        var d, e = b.gl, f = b.projection, g = b.offset, h = b.shaderManager.primitiveShader;
        a.dirty && PIXI.WebGLGraphics.updateGraphics(a, e);
        var i = a._webGL[e.id];
        if (i) for(var j = 0; j < i.data.length; j++)1 === i.data[j].mode ? (d = i.data[j], b.stencilManager.pushStencil(a, d, b), e.drawElements(e.TRIANGLE_FAN, 4, e.UNSIGNED_SHORT, 2 * (d.indices.length - 4)), b.stencilManager.popStencil(a, d, b)) : (d = i.data[j], b.shaderManager.setShader(h), h = b.shaderManager.primitiveShader, e.uniformMatrix3fv(h.translationMatrix, !1, a.worldTransform.toArray(!0)), e.uniform1f(h.flipY, 1), e.uniform2f(h.projectionVector, f.x, -f.y), e.uniform2f(h.offsetVector, -g.x, -g.y), e.uniform3fv(h.tintColor, c53.Color.hexToRGBArray(a.tint)), e.uniform1f(h.alpha, a.worldAlpha), e.bindBuffer(e.ARRAY_BUFFER, d.buffer), e.vertexAttribPointer(h.aVertexPosition, 2, e.FLOAT, !1, 24, 0), e.vertexAttribPointer(h.colorAttribute, 4, e.FLOAT, !1, 24, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, d.indexBuffer), e.drawElements(e.TRIANGLE_STRIP, d.indices.length, e.UNSIGNED_SHORT, 0));
    }, PIXI.WebGLGraphics.updateGraphics = function(a, b) {
        var d = a._webGL[b.id];
        d || (d = a._webGL[b.id] = {
            lastIndex: 0,
            data: [],
            gl: b
        }), a.dirty = !1;
        var e;
        if (a.clearDirty) {
            for(a.clearDirty = !1, e = 0; e < d.data.length; e++){
                var f = d.data[e];
                f.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(f);
            }
            d.data = [], d.lastIndex = 0;
        }
        var g;
        for(e = d.lastIndex; e < a.graphicsData.length; e++){
            var h = a.graphicsData[e];
            if (h.type === c53.POLYGON) {
                if (h.points = h.shape.points.slice(), h.shape.closed && (h.points[0] === h.points[h.points.length - 2] && h.points[1] === h.points[h.points.length - 1] || h.points.push(h.points[0], h.points[1])), h.fill && h.points.length >= PIXI.WebGLGraphics.stencilBufferLimit) {
                    if (h.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
                        g = PIXI.WebGLGraphics.switchMode(d, 0);
                        var i = PIXI.WebGLGraphics.buildPoly(h, g);
                        i || (g = PIXI.WebGLGraphics.switchMode(d, 1), PIXI.WebGLGraphics.buildComplexPoly(h, g));
                    } else g = PIXI.WebGLGraphics.switchMode(d, 1), PIXI.WebGLGraphics.buildComplexPoly(h, g);
                }
                h.lineWidth > 0 && (g = PIXI.WebGLGraphics.switchMode(d, 0), PIXI.WebGLGraphics.buildLine(h, g));
            } else g = PIXI.WebGLGraphics.switchMode(d, 0), h.type === c53.RECTANGLE ? PIXI.WebGLGraphics.buildRectangle(h, g) : h.type === c53.CIRCLE || h.type === c53.ELLIPSE ? PIXI.WebGLGraphics.buildCircle(h, g) : h.type === c53.ROUNDEDRECTANGLE && PIXI.WebGLGraphics.buildRoundedRectangle(h, g);
            d.lastIndex++;
        }
        for(e = 0; e < d.data.length; e++)g = d.data[e], g.dirty && g.upload();
    }, PIXI.WebGLGraphics.switchMode = function(a, b) {
        var c;
        return a.data.length ? (c = a.data[a.data.length - 1], c.mode === b && 1 !== b || (c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl), c.mode = b, a.data.push(c))) : (c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl), c.mode = b, a.data.push(c)), c.dirty = !0, c;
    }, PIXI.WebGLGraphics.buildRectangle = function(a, b) {
        var d = a.shape, e = d.x, f = d.y, g = d.width, h = d.height;
        if (a.fill) {
            var i = c53.Color.hexToRGBArray(a.fillColor), j = a.fillAlpha, k = i[0] * j, l = i[1] * j, m = i[2] * j, n = b.points, o = b.indices, p = n.length / 6;
            n.push(e, f), n.push(k, l, m, j), n.push(e + g, f), n.push(k, l, m, j), n.push(e, f + h), n.push(k, l, m, j), n.push(e + g, f + h), n.push(k, l, m, j), o.push(p, p, p + 1, p + 2, p + 3, p + 3);
        }
        if (a.lineWidth) {
            var q = a.points;
            a.points = [
                e,
                f,
                e + g,
                f,
                e + g,
                f + h,
                e,
                f + h,
                e,
                f
            ], PIXI.WebGLGraphics.buildLine(a, b), a.points = q;
        }
    }, PIXI.WebGLGraphics.buildRoundedRectangle = function(a, b) {
        var d = a.shape, e = d.x, f = d.y, g = d.width, h = d.height, i = d.radius, j = [];
        if (j.push(e, f + i), j = j.concat(PIXI.WebGLGraphics.quadraticBezierCurve(e, f + h - i, e, f + h, e + i, f + h)), j = j.concat(PIXI.WebGLGraphics.quadraticBezierCurve(e + g - i, f + h, e + g, f + h, e + g, f + h - i)), j = j.concat(PIXI.WebGLGraphics.quadraticBezierCurve(e + g, f + i, e + g, f, e + g - i, f)), j = j.concat(PIXI.WebGLGraphics.quadraticBezierCurve(e + i, f, e, f, e, f + i)), a.fill) {
            var k = c53.Color.hexToRGBArray(a.fillColor), l = a.fillAlpha, m = k[0] * l, n = k[1] * l, o = k[2] * l, p = b.points, q = b.indices, r = p.length / 6, s = c53.EarCut.Triangulate(j, null, 2), t = 0;
            for(t = 0; t < s.length; t += 3)q.push(s[t] + r), q.push(s[t] + r), q.push(s[t + 1] + r), q.push(s[t + 2] + r), q.push(s[t + 2] + r);
            for(t = 0; t < j.length; t++)p.push(j[t], j[++t], m, n, o, l);
        }
        if (a.lineWidth) {
            var u = a.points;
            a.points = j, PIXI.WebGLGraphics.buildLine(a, b), a.points = u;
        }
    }, PIXI.WebGLGraphics.quadraticBezierCurve = function(a72, b63, c55, d, e, f) {
        function g(a, b, c) {
            return a + (b - a) * c;
        }
        for(var h, i, j, k, l, m, n = 20, o = [], p = 0, q = 0; q <= n; q++)p = q / n, h = g(a72, c55, p), i = g(b63, d, p), j = g(c55, e, p), k = g(d, f, p), l = g(h, j, p), m = g(i, k, p), o.push(l, m);
        return o;
    }, PIXI.WebGLGraphics.buildCircle = function(a, b) {
        var d, e, f = a.shape, g = f.x, h = f.y;
        a.type === c53.CIRCLE ? (d = f.radius, e = f.radius) : (d = f.width, e = f.height);
        var i = 40, j = 2 * Math.PI / i, k = 0;
        if (a.fill) {
            var l = c53.Color.hexToRGBArray(a.fillColor), m = a.fillAlpha, n = l[0] * m, o = l[1] * m, p = l[2] * m, q = b.points, r = b.indices, s = q.length / 6;
            for(r.push(s), k = 0; k < i + 1; k++)q.push(g, h, n, o, p, m), q.push(g + Math.sin(j * k) * d, h + Math.cos(j * k) * e, n, o, p, m), r.push(s++, s++);
            r.push(s - 1);
        }
        if (a.lineWidth) {
            var t = a.points;
            for(a.points = [], k = 0; k < i + 1; k++)a.points.push(g + Math.sin(j * k) * d, h + Math.cos(j * k) * e);
            PIXI.WebGLGraphics.buildLine(a, b), a.points = t;
        }
    }, PIXI.WebGLGraphics.buildLine = function(a, b) {
        var d = 0, e = a.points;
        if (0 !== e.length) {
            if (a.lineWidth % 2) for(d = 0; d < e.length; d++)e[d] += 0.5;
            var f = new PIXI.Point(e[0], e[1]), g = new PIXI.Point(e[e.length - 2], e[e.length - 1]);
            if (f.x === g.x && f.y === g.y) {
                e = e.slice(), e.pop(), e.pop(), g = new PIXI.Point(e[e.length - 2], e[e.length - 1]);
                var h = g.x + 0.5 * (f.x - g.x), i = g.y + 0.5 * (f.y - g.y);
                e.unshift(h, i), e.push(h, i);
            }
            var j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G = b.points, H = b.indices, I = e.length / 2, J = e.length, K = G.length / 6, L = a.lineWidth / 2, M = c53.Color.hexToRGBArray(a.lineColor), N = a.lineAlpha, O = M[0] * N, P = M[1] * N, Q = M[2] * N;
            for(l = e[0], m = e[1], n = e[2], o = e[3], r = -(m - o), s = l - n, F = Math.sqrt(r * r + s * s), r /= F, s /= F, r *= L, s *= L, G.push(l - r, m - s, O, P, Q, N), G.push(l + r, m + s, O, P, Q, N), d = 1; d < I - 1; d++)l = e[2 * (d - 1)], m = e[2 * (d - 1) + 1], n = e[2 * d], o = e[2 * d + 1], p = e[2 * (d + 1)], q = e[2 * (d + 1) + 1], r = -(m - o), s = l - n, F = Math.sqrt(r * r + s * s), r /= F, s /= F, r *= L, s *= L, t = -(o - q), u = n - p, F = Math.sqrt(t * t + u * u), t /= F, u /= F, t *= L, u *= L, x = -s + m - (-s + o), y = -r + n - (-r + l), z = (-r + l) * (-s + o) - (-r + n) * (-s + m), A = -u + q - (-u + o), B = -t + n - (-t + p), C = (-t + p) * (-u + o) - (-t + n) * (-u + q), D = x * B - A * y, Math.abs(D) < 0.1 ? (D += 10.1, G.push(n - r, o - s, O, P, Q, N), G.push(n + r, o + s, O, P, Q, N)) : (j = (y * C - B * z) / D, k = (A * z - x * C) / D, E = (j - n) * (j - n) + (k - o) + (k - o), E > 19600 ? (v = r - t, w = s - u, F = Math.sqrt(v * v + w * w), v /= F, w /= F, v *= L, w *= L, G.push(n - v, o - w), G.push(O, P, Q, N), G.push(n + v, o + w), G.push(O, P, Q, N), G.push(n - v, o - w), G.push(O, P, Q, N), J++) : (G.push(j, k), G.push(O, P, Q, N), G.push(n - (j - n), o - (k - o)), G.push(O, P, Q, N)));
            for(l = e[2 * (I - 2)], m = e[2 * (I - 2) + 1], n = e[2 * (I - 1)], o = e[2 * (I - 1) + 1], r = -(m - o), s = l - n, F = Math.sqrt(r * r + s * s), r /= F, s /= F, r *= L, s *= L, G.push(n - r, o - s), G.push(O, P, Q, N), G.push(n + r, o + s), G.push(O, P, Q, N), H.push(K), d = 0; d < J; d++)H.push(K++);
            H.push(K - 1);
        }
    }, PIXI.WebGLGraphics.buildComplexPoly = function(a, b) {
        var d = a.points.slice();
        if (!(d.length < 6)) {
            var e = b.indices;
            b.points = d, b.alpha = a.fillAlpha, b.color = c53.Color.hexToRGBArray(a.fillColor);
            for(var f, g, h = 1 / 0, i = -1 / 0, j = 1 / 0, k = -1 / 0, l = 0; l < d.length; l += 2)f = d[l], g = d[l + 1], h = f < h ? f : h, i = f > i ? f : i, j = g < j ? g : j, k = g > k ? g : k;
            d.push(h, j, i, j, i, k, h, k);
            var m = d.length / 2;
            for(l = 0; l < m; l++)e.push(l);
        }
    }, PIXI.WebGLGraphics.buildPoly = function(a, b) {
        var d = a.points;
        if (!(d.length < 6)) {
            var e = b.points, f = b.indices, g = d.length / 2, h = c53.Color.hexToRGBArray(a.fillColor), i = a.fillAlpha, j = h[0] * i, k = h[1] * i, l = h[2] * i, m = c53.EarCut.Triangulate(d, null, 2);
            if (!m) return !1;
            var n = e.length / 6, o = 0;
            for(o = 0; o < m.length; o += 3)f.push(m[o] + n), f.push(m[o] + n), f.push(m[o + 1] + n), f.push(m[o + 2] + n), f.push(m[o + 2] + n);
            for(o = 0; o < g; o++)e.push(d[2 * o], d[2 * o + 1], j, k, l, i);
            return !0;
        }
    }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(a) {
        this.gl = a, this.color = [
            0,
            0,
            0
        ], this.points = [], this.indices = [], this.buffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0;
    }, PIXI.WebGLGraphicsData.prototype.reset = function() {
        this.points = [], this.indices = [];
    }, PIXI.WebGLGraphicsData.prototype.upload = function() {
        var a = this.gl;
        this.glPoints = new Float32Array(this.points), a.bindBuffer(a.ARRAY_BUFFER, this.buffer), a.bufferData(a.ARRAY_BUFFER, this.glPoints, a.STATIC_DRAW), this.glIndicies = new Uint16Array(this.indices), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.glIndicies, a.STATIC_DRAW), this.dirty = !1;
    }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(a, b) {
        var d = a.worldAlpha;
        a.dirty && (this.updateGraphicsTint(a), a.dirty = !1);
        for(var e = 0; e < a.graphicsData.length; e++){
            var f = a.graphicsData[e], g = f.shape, h = f._fillTint, i = f._lineTint;
            if (b.lineWidth = f.lineWidth, f.type === c53.POLYGON) {
                b.beginPath();
                var j = g.points;
                b.moveTo(j[0], j[1]);
                for(var k = 1; k < j.length / 2; k++)b.lineTo(j[2 * k], j[2 * k + 1]);
                g.closed && b.lineTo(j[0], j[1]), j[0] === j[j.length - 2] && j[1] === j[j.length - 1] && b.closePath(), f.fill && (b.globalAlpha = f.fillAlpha * d, b.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.fill()), f.lineWidth && (b.globalAlpha = f.lineAlpha * d, b.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), b.stroke());
            } else if (f.type === c53.RECTANGLE) (f.fillColor || 0 === f.fillColor) && (b.globalAlpha = f.fillAlpha * d, b.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.fillRect(g.x, g.y, g.width, g.height)), f.lineWidth && (b.globalAlpha = f.lineAlpha * d, b.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), b.strokeRect(g.x, g.y, g.width, g.height));
            else if (f.type === c53.CIRCLE) b.beginPath(), b.arc(g.x, g.y, g.radius, 0, 2 * Math.PI), b.closePath(), f.fill && (b.globalAlpha = f.fillAlpha * d, b.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.fill()), f.lineWidth && (b.globalAlpha = f.lineAlpha * d, b.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), b.stroke());
            else if (f.type === c53.ELLIPSE) {
                var l = 2 * g.width, m = 2 * g.height, n = g.x - l / 2, o = g.y - m / 2;
                b.beginPath();
                var p = 0.5522848, q = l / 2 * p, r = m / 2 * p, s = n + l, t = o + m, u = n + l / 2, v = o + m / 2;
                b.moveTo(n, v), b.bezierCurveTo(n, v - r, u - q, o, u, o), b.bezierCurveTo(u + q, o, s, v - r, s, v), b.bezierCurveTo(s, v + r, u + q, t, u, t), b.bezierCurveTo(u - q, t, n, v + r, n, v), b.closePath(), f.fill && (b.globalAlpha = f.fillAlpha * d, b.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.fill()), f.lineWidth && (b.globalAlpha = f.lineAlpha * d, b.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), b.stroke());
            } else if (f.type === c53.ROUNDEDRECTANGLE) {
                var w = g.x, x = g.y, y = g.width, z = g.height, A = g.radius, B = Math.min(y, z) / 2 | 0;
                A = A > B ? B : A, b.beginPath(), b.moveTo(w, x + A), b.lineTo(w, x + z - A), b.quadraticCurveTo(w, x + z, w + A, x + z), b.lineTo(w + y - A, x + z), b.quadraticCurveTo(w + y, x + z, w + y, x + z - A), b.lineTo(w + y, x + A), b.quadraticCurveTo(w + y, x, w + y - A, x), b.lineTo(w + A, x), b.quadraticCurveTo(w, x, w, x + A), b.closePath(), (f.fillColor || 0 === f.fillColor) && (b.globalAlpha = f.fillAlpha * d, b.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.fill()), f.lineWidth && (b.globalAlpha = f.lineAlpha * d, b.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), b.stroke());
            }
        }
    }, PIXI.CanvasGraphics.renderGraphicsMask = function(a, b) {
        var d = a.graphicsData.length;
        if (0 !== d) {
            b.beginPath();
            for(var e = 0; e < d; e++){
                var f = a.graphicsData[e], g = f.shape;
                if (f.type === c53.POLYGON) {
                    var h = g.points;
                    b.moveTo(h[0], h[1]);
                    for(var i = 1; i < h.length / 2; i++)b.lineTo(h[2 * i], h[2 * i + 1]);
                    h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && b.closePath();
                } else if (f.type === c53.RECTANGLE) b.rect(g.x, g.y, g.width, g.height), b.closePath();
                else if (f.type === c53.CIRCLE) b.arc(g.x, g.y, g.radius, 0, 2 * Math.PI), b.closePath();
                else if (f.type === c53.ELLIPSE) {
                    var j = 2 * g.width, k = 2 * g.height, l = g.x - j / 2, m = g.y - k / 2, n = 0.5522848, o = j / 2 * n, p = k / 2 * n, q = l + j, r = m + k, s = l + j / 2, t = m + k / 2;
                    b.moveTo(l, t), b.bezierCurveTo(l, t - p, s - o, m, s, m), b.bezierCurveTo(s + o, m, q, t - p, q, t), b.bezierCurveTo(q, t + p, s + o, r, s, r), b.bezierCurveTo(s - o, r, l, t + p, l, t), b.closePath();
                } else if (f.type === c53.ROUNDEDRECTANGLE) {
                    var u = g.x, v = g.y, w = g.width, x = g.height, y = g.radius, z = Math.min(w, x) / 2 | 0;
                    y = y > z ? z : y, b.moveTo(u, v + y), b.lineTo(u, v + x - y), b.quadraticCurveTo(u, v + x, u + y, v + x), b.lineTo(u + w - y, v + x), b.quadraticCurveTo(u + w, v + x, u + w, v + x - y), b.lineTo(u + w, v + y), b.quadraticCurveTo(u + w, v, u + w - y, v), b.lineTo(u + y, v), b.quadraticCurveTo(u, v, u, v + y), b.closePath();
                }
            }
        }
    }, PIXI.CanvasGraphics.updateGraphicsTint = function(a) {
        if (16777215 !== a.tint) for(var b = (a.tint >> 16 & 255) / 255, c = (a.tint >> 8 & 255) / 255, d = (255 & a.tint) / 255, e = 0; e < a.graphicsData.length; e++){
            var f = a.graphicsData[e], g = 0 | f.fillColor, h = 0 | f.lineColor;
            f._fillTint = ((g >> 16 & 255) / 255 * b * 255 << 16) + ((g >> 8 & 255) / 255 * c * 255 << 8) + (255 & g) / 255 * d * 255, f._lineTint = ((h >> 16 & 255) / 255 * b * 255 << 16) + ((h >> 8 & 255) / 255 * c * 255 << 8) + (255 & h) / 255 * d * 255;
        }
    }, c53.GraphicsData = function(a, b, c, d, e, f, g) {
        this.lineWidth = a, this.lineColor = b, this.lineAlpha = c, this._lineTint = b, this.fillColor = d, this.fillAlpha = e, this._fillTint = d, this.fill = f, this.shape = g, this.type = g.type;
    }, c53.GraphicsData.prototype.constructor = c53.GraphicsData, c53.GraphicsData.prototype.clone = function() {
        return new c53.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
    }, c53.Graphics = function(a, b, d) {
        void 0 === b && (b = 0), void 0 === d && (d = 0), this.type = c53.GRAPHICS, this.physicsType = c53.SPRITE, this.anchor = new c53.Point, PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new c53.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1, c53.Component.Core.init.call(this, a, b, d, "", null);
    }, c53.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c53.Graphics.prototype.constructor = c53.Graphics, c53.Component.Core.install.call(c53.Graphics.prototype, [
        "Angle",
        "AutoCull",
        "Bounds",
        "Destroy",
        "FixedToCamera",
        "InputEnabled",
        "InWorld",
        "LifeSpan",
        "PhysicsBody",
        "Reset"
    ]), c53.Graphics.prototype.preUpdatePhysics = c53.Component.PhysicsBody.preUpdate, c53.Graphics.prototype.preUpdateLifeSpan = c53.Component.LifeSpan.preUpdate, c53.Graphics.prototype.preUpdateInWorld = c53.Component.InWorld.preUpdate, c53.Graphics.prototype.preUpdateCore = c53.Component.Core.preUpdate, c53.Graphics.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    }, c53.Graphics.prototype.postUpdate = function() {
        c53.Component.PhysicsBody.postUpdate.call(this), c53.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
        for(var a = 0; a < this.children.length; a++)this.children[a].postUpdate();
    }, c53.Graphics.prototype.destroy = function(a) {
        this.clear(), c53.Component.Destroy.prototype.destroy.call(this, a);
    }, c53.Graphics.prototype.drawTriangle = function(a, b) {
        void 0 === b && (b = !1);
        var d = new c53.Polygon(a);
        if (b) {
            var e = new c53.Point(this.game.camera.x - a[0].x, this.game.camera.y - a[0].y), f = new c53.Point(a[1].x - a[0].x, a[1].y - a[0].y), g = new c53.Point(a[1].x - a[2].x, a[1].y - a[2].y), h = g.cross(f);
            e.dot(h) > 0 && this.drawPolygon(d);
        } else this.drawPolygon(d);
    }, c53.Graphics.prototype.drawTriangles = function(a, b, d) {
        void 0 === d && (d = !1);
        var e, f = new c53.Point, g = new c53.Point, h = new c53.Point, i = [];
        if (b) {
            if (a[0] instanceof c53.Point) for(e = 0; e < b.length / 3; e++)i.push(a[b[3 * e]]), i.push(a[b[3 * e + 1]]), i.push(a[b[3 * e + 2]]), 3 === i.length && (this.drawTriangle(i, d), i = []);
            else for(e = 0; e < b.length; e++)f.x = a[2 * b[e]], f.y = a[2 * b[e] + 1], i.push(f.copyTo({})), 3 === i.length && (this.drawTriangle(i, d), i = []);
        } else if (a[0] instanceof c53.Point) for(e = 0; e < a.length / 3; e++)this.drawTriangle([
            a[3 * e],
            a[3 * e + 1],
            a[3 * e + 2]
        ], d);
        else for(e = 0; e < a.length / 6; e++)f.x = a[6 * e + 0], f.y = a[6 * e + 1], g.x = a[6 * e + 2], g.y = a[6 * e + 3], h.x = a[6 * e + 4], h.y = a[6 * e + 5], this.drawTriangle([
            f,
            g,
            h
        ], d);
    }, c53.Graphics.prototype.lineStyle = function(a, b, d) {
        return this.lineWidth = a || 0, this.lineColor = b || 0, this.lineAlpha = void 0 === d ? 1 : d, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new c53.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this;
    }, c53.Graphics.prototype.moveTo = function(a, b) {
        return this.drawShape(new c53.Polygon([
            a,
            b
        ])), this;
    }, c53.Graphics.prototype.lineTo = function(a, b) {
        return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(a, b), this.dirty = !0, this._boundsDirty = !0, this;
    }, c53.Graphics.prototype.quadraticCurveTo = function(a, b, c, d) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [
            0,
            0
        ]) : this.moveTo(0, 0);
        var e, f, g = 20, h = this.currentPath.shape.points;
        0 === h.length && this.moveTo(0, 0);
        for(var i = h[h.length - 2], j = h[h.length - 1], k = 0, l = 1; l <= g; ++l)k = l / g, e = i + (a - i) * k, f = j + (b - j) * k, h.push(e + (a + (c - a) * k - e) * k, f + (b + (d - b) * k - f) * k);
        return this.dirty = !0, this._boundsDirty = !0, this;
    }, c53.Graphics.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [
            0,
            0
        ]) : this.moveTo(0, 0);
        for(var g, h, i, j, k, l = 20, m = this.currentPath.shape.points, n = m[m.length - 2], o = m[m.length - 1], p = 0, q = 1; q <= l; ++q)p = q / l, g = 1 - p, h = g * g, i = h * g, j = p * p, k = j * p, m.push(i * n + 3 * h * p * a + 3 * g * j * c + k * e, i * o + 3 * h * p * b + 3 * g * j * d + k * f);
        return this.dirty = !0, this._boundsDirty = !0, this;
    }, c53.Graphics.prototype.arcTo = function(a, b, c, d, e) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(a, b) : this.moveTo(a, b);
        var f = this.currentPath.shape.points, g = f[f.length - 2], h = f[f.length - 1], i = h - b, j = g - a, k = d - b, l = c - a, m = Math.abs(i * l - j * k);
        if (m < 0.00000001 || 0 === e) f[f.length - 2] === a && f[f.length - 1] === b || f.push(a, b);
        else {
            var n = i * i + j * j, o = k * k + l * l, p = i * k + j * l, q = e * Math.sqrt(n) / m, r = e * Math.sqrt(o) / m, s = q * p / n, t = r * p / o, u = q * l + r * j, v = q * k + r * i, w = j * (r + s), x = i * (r + s), y = l * (q + t), z = k * (q + t), A = Math.atan2(x - v, w - u), B = Math.atan2(z - v, y - u);
            this.arc(u + a, v + b, e, A, B, j * k > l * i);
        }
        return this.dirty = !0, this._boundsDirty = !0, this;
    }, c53.Graphics.prototype.arc = function(a, b, c, d, e, f, g) {
        if (d === e) return this;
        void 0 === f && (f = !1), void 0 === g && (g = 40), !f && e <= d ? e += 2 * Math.PI : f && d <= e && (d += 2 * Math.PI);
        var h = f ? -1 * (d - e) : e - d, i = Math.ceil(Math.abs(h) / (2 * Math.PI)) * g;
        if (0 === h) return this;
        var j = a + Math.cos(d) * c, k = b + Math.sin(d) * c;
        f && this.filling ? this.moveTo(a, b) : this.moveTo(j, k);
        for(var l = this.currentPath.shape.points, m = h / (2 * i), n = 2 * m, o = Math.cos(m), p = Math.sin(m), q = i - 1, r = q % 1 / q, s = 0; s <= q; s++){
            var t = s + r * s, u = m + d + n * t, v = Math.cos(u), w = -Math.sin(u);
            l.push((o * v + p * w) * c + a, (o * -w + p * v) * c + b);
        }
        return this.dirty = !0, this._boundsDirty = !0, this;
    }, c53.Graphics.prototype.beginFill = function(a, b) {
        return this.filling = !0, this.fillColor = a || 0, this.fillAlpha = void 0 === b ? 1 : b, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this;
    }, c53.Graphics.prototype.endFill = function() {
        return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this;
    }, c53.Graphics.prototype.drawRect = function(a, b, d, e) {
        return this.drawShape(new c53.Rectangle(a, b, d, e)), this;
    }, c53.Graphics.prototype.drawRoundedRect = function(a, b, d, e, f) {
        return this.drawShape(new c53.RoundedRectangle(a, b, d, e, f)), this;
    }, c53.Graphics.prototype.drawCircle = function(a, b, d) {
        return this.drawShape(new c53.Circle(a, b, d)), this;
    }, c53.Graphics.prototype.drawEllipse = function(a, b, d, e) {
        return this.drawShape(new c53.Ellipse(a, b, d, e)), this;
    }, c53.Graphics.prototype.drawPolygon = function(a) {
        a instanceof c53.Polygon && (a = a.points);
        var b = a;
        if (!Array.isArray(b)) {
            b = new Array(arguments.length);
            for(var d = 0; d < b.length; ++d)b[d] = arguments[d];
        }
        return this.drawShape(new c53.Polygon(b)), this;
    }, c53.Graphics.prototype.clear = function() {
        return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this;
    }, c53.Graphics.prototype.generateTexture = function(a, b, c) {
        void 0 === a && (a = 1), void 0 === b && (b = PIXI.scaleModes.DEFAULT), void 0 === c && (c = 0);
        var d = this.getBounds();
        d.width += c, d.height += c;
        var e = new PIXI.CanvasBuffer(d.width * a, d.height * a), f = PIXI.Texture.fromCanvas(e.canvas, b);
        return f.baseTexture.resolution = a, e.context.scale(a, a), e.context.translate(-d.x, -d.y), PIXI.CanvasGraphics.renderGraphics(this, e.context), f;
    }, c53.Graphics.prototype._renderWebGL = function(a) {
        if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
            if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
            if (a.spriteBatch.stop(), a.blendModeManager.setBlendMode(this.blendMode), this._mask && a.maskManager.pushMask(this._mask, a), this._filters && a.filterManager.pushFilter(this._filterBlock), this.blendMode !== a.spriteBatch.currentBlendMode) {
                a.spriteBatch.currentBlendMode = this.blendMode;
                var b = PIXI.blendModesWebGL[a.spriteBatch.currentBlendMode];
                a.spriteBatch.gl.blendFunc(b[0], b[1]);
            }
            if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, a), this.children.length) {
                a.spriteBatch.start();
                for(var c = 0; c < this.children.length; c++)this.children[c]._renderWebGL(a);
                a.spriteBatch.stop();
            }
            this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this.mask, a), a.drawCount++, a.spriteBatch.start();
        }
    }, c53.Graphics.prototype._renderCanvas = function(a) {
        if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
            if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
            var b = a.context, c = this.worldTransform;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, b.globalCompositeOperation = PIXI.blendModesCanvas[a.currentBlendMode]), this._mask && a.maskManager.pushMask(this._mask, a);
            var d = a.resolution, e = c.tx * a.resolution + a.shakeX, f = c.ty * a.resolution + a.shakeY;
            b.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, e, f), PIXI.CanvasGraphics.renderGraphics(this, b);
            for(var g = 0; g < this.children.length; g++)this.children[g]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a);
        }
    }, c53.Graphics.prototype.getBounds = function(a) {
        if (this._currentBounds) return this._currentBounds;
        if (!this.renderable) return c53.EmptyRectangle;
        this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
        var b = this._localBounds, d = b.x, e = b.width + b.x, f = b.y, g = b.height + b.y, h = a || this.worldTransform, i = h.a, j = h.b, k = h.c, l = h.d, m = h.tx, n = h.ty, o = i * e + k * g + m, p = l * g + j * e + n, q = i * d + k * g + m, r = l * g + j * d + n, s = i * d + k * f + m, t = l * f + j * d + n, u = i * e + k * f + m, v = l * f + j * e + n, w = o, x = p, y = o, z = p;
        return y = q < y ? q : y, y = s < y ? s : y, y = u < y ? u : y, z = r < z ? r : z, z = t < z ? t : z, z = v < z ? v : z, w = q > w ? q : w, w = s > w ? s : w, w = u > w ? u : w, x = r > x ? r : x, x = t > x ? t : x, x = v > x ? v : x, this._bounds.x = y, this._bounds.width = w - y, this._bounds.y = z, this._bounds.height = x - z, this._currentBounds = this._bounds, this._currentBounds;
    }, c53.Graphics.prototype.getLocalBounds = function() {
        var a = this.worldTransform;
        this.worldTransform = c53.identityMatrix;
        for(var b = 0; b < this.children.length; b++)this.children[b].updateTransform();
        var d = this.getBounds();
        for(this.worldTransform = a, b = 0; b < this.children.length; b++)this.children[b].updateTransform();
        return d;
    }, c53.Graphics.prototype.containsPoint = function(a, b) {
        void 0 === b && (b = new c53.Point), this.worldTransform.applyInverse(a, b);
        for(var d = this.graphicsData, e = 0; e < d.length; e++){
            var f = d[e];
            if (f.fill && f.shape && f.shape.contains(b.x, b.y)) return !0;
        }
        return !1;
    }, c53.Graphics.prototype.updateLocalBounds = function() {
        var a = 1 / 0, b = -1 / 0, d = 1 / 0, e = -1 / 0;
        if (this.graphicsData.length) for(var f, g, h, i, j, k, l = 0; l < this.graphicsData.length; l++){
            var m = this.graphicsData[l], n = m.type, o = m.lineWidth;
            if (f = m.shape, n === c53.RECTANGLE || n === c53.ROUNDEDRECTANGLE) h = f.x - o / 2, i = f.y - o / 2, j = f.width + o, k = f.height + o, a = h < a ? h : a, b = h + j > b ? h + j : b, d = i < d ? i : d, e = i + k > e ? i + k : e;
            else if (n === c53.CIRCLE) h = f.x, i = f.y, j = f.radius + o / 2, k = f.radius + o / 2, a = h - j < a ? h - j : a, b = h + j > b ? h + j : b, d = i - k < d ? i - k : d, e = i + k > e ? i + k : e;
            else if (n === c53.ELLIPSE) h = f.x, i = f.y, j = f.width + o / 2, k = f.height + o / 2, a = h - j < a ? h - j : a, b = h + j > b ? h + j : b, d = i - k < d ? i - k : d, e = i + k > e ? i + k : e;
            else {
                g = f.points;
                for(var p = 0; p < g.length; p++)g[p] instanceof c53.Point ? (h = g[p].x, i = g[p].y) : (h = g[p], i = g[p + 1], p < g.length - 1 && p++), a = h - o < a ? h - o : a, b = h + o > b ? h + o : b, d = i - o < d ? i - o : d, e = i + o > e ? i + o : e;
            }
        }
        else a = 0, b = 0, d = 0, e = 0;
        var q = this.boundsPadding;
        this._localBounds.x = a - q, this._localBounds.width = b - a + 2 * q, this._localBounds.y = d - q, this._localBounds.height = e - d + 2 * q;
    }, c53.Graphics.prototype._generateCachedSprite = function() {
        var a = this.getLocalBounds();
        if (this._cachedSprite) this._cachedSprite.buffer.resize(a.width, a.height);
        else {
            var b = new PIXI.CanvasBuffer(a.width, a.height), c = PIXI.Texture.fromCanvas(b.canvas);
            this._cachedSprite = new PIXI.Sprite(c), this._cachedSprite.buffer = b, this._cachedSprite.worldTransform = this.worldTransform;
        }
        this._cachedSprite.anchor.x = -a.x / a.width, this._cachedSprite.anchor.y = -a.y / a.height, this._cachedSprite.buffer.context.translate(-a.x, -a.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha;
    }, c53.Graphics.prototype.updateCachedSpriteTexture = function() {
        var a = this._cachedSprite, b = a.texture, c = a.buffer.canvas;
        b.baseTexture.width = c.width, b.baseTexture.height = c.height, b.crop.width = b.frame.width = c.width, b.crop.height = b.frame.height = c.height, a._width = c.width, a._height = c.height, b.baseTexture.dirty();
    }, c53.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(!0), this._cachedSprite = null;
    }, c53.Graphics.prototype.drawShape = function(a) {
        this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, a instanceof c53.Polygon && (a = a.clone(), a.flatten());
        var b = new c53.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, a);
        return this.graphicsData.push(b), b.type === c53.POLYGON && (b.shape.closed = this.filling, this.currentPath = b), this.dirty = !0, this._boundsDirty = !0, b;
    }, Object.defineProperty(c53.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(a) {
            this._cacheAsBitmap = a, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0;
        }
    }), c53.RenderTexture = function(a, b, d, e, f, g, h, i) {
        if (void 0 === b && (b = 100), void 0 === d && (d = 100), void 0 === e && (e = ""), void 0 === f && (f = c53.scaleModes.DEFAULT), void 0 === g && (g = 1), void 0 === h && (h = PIXI.defaultRenderer), void 0 === i && (i = 0), this.game = a, this.key = e, this.type = c53.RENDERTEXTURE, this._tempMatrix = new c53.Matrix, this.width = b, this.height = d, this.resolution = g, this.frame = new c53.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = this.frame.clone(), this.baseTexture = new PIXI.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = f, this.baseTexture.hasLoaded = !0, PIXI.Texture.call(this, this.baseTexture, this.frame.clone()), this.renderer = h, this.renderer.type === c53.WEBGL) {
            var j = this.renderer.gl;
            this.baseTexture.textureIndex = i, this.baseTexture._dirty[j.id] = !1, this.textureBuffer = new PIXI.FilterTexture(j, this.width, this.height, this.baseTexture.scaleMode, i), this.baseTexture._glTextures[j.id] = this.textureBuffer.texture, this.projection = new c53.Point(0.5 * this.width, 0.5 * -this.height);
        } else this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this.tempMatrix = new c53.Matrix, this._updateUvs();
    }, c53.RenderTexture.prototype = Object.create(PIXI.Texture.prototype), c53.RenderTexture.prototype.constructor = c53.RenderTexture, c53.RenderTexture.prototype.renderXY = function(a, b, d, e) {
        a.updateTransform(), this._tempMatrix.copyFrom(a.worldTransform), this._tempMatrix.tx = b, this._tempMatrix.ty = d, this.renderer.type === c53.WEBGL ? this._renderWebGL(a, this._tempMatrix, e) : this._renderCanvas(a, this._tempMatrix, e);
    }, c53.RenderTexture.prototype.renderRawXY = function(a, b, d, e) {
        this._tempMatrix.identity().translate(b, d), this.renderer.type === c53.WEBGL ? this._renderWebGL(a, this._tempMatrix, e) : this._renderCanvas(a, this._tempMatrix, e);
    }, c53.RenderTexture.prototype.render = function(a, b, d) {
        void 0 === b || null === b ? this._tempMatrix.copyFrom(a.worldTransform) : this._tempMatrix.copyFrom(b), this.renderer.type === c53.WEBGL ? this._renderWebGL(a, this._tempMatrix, d) : this._renderCanvas(a, this._tempMatrix, d);
    }, c53.RenderTexture.prototype.resize = function(a, b, d) {
        a === this.width && b === this.height || (this.valid = a > 0 && b > 0, this.width = a, this.height = b, this.frame.width = this.crop.width = a * this.resolution, this.frame.height = this.crop.height = b * this.resolution, d && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === c53.WEBGL && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height));
    }, c53.RenderTexture.prototype.clear = function() {
        this.valid && (this.renderer.type === c53.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear());
    }, c53.RenderTexture.prototype._renderWebGL = function(a, b, c) {
        if (this.valid && 0 !== a.alpha) {
            var d = a.worldTransform;
            d.identity(), d.translate(0, 2 * this.projection.y), b && d.append(b), d.scale(1, -1);
            for(var e = 0; e < a.children.length; e++)a.children[e].updateTransform();
            var f = this.renderer.gl;
            f.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), f.bindFramebuffer(f.FRAMEBUFFER, this.textureBuffer.frameBuffer), c && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer, b), this.renderer.spriteBatch.dirty = !0, f.bindFramebuffer(f.FRAMEBUFFER, null);
        }
    }, c53.RenderTexture.prototype._renderCanvas = function(a, b, c) {
        if (this.valid && 0 !== a.alpha) {
            var d = a.worldTransform;
            d.identity(), b && d.append(b);
            for(var e = 0; e < a.children.length; e++)a.children[e].updateTransform();
            c && this.textureBuffer.clear();
            var f = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(a, this.textureBuffer.context, b), this.renderer.resolution = f;
        }
    }, c53.RenderTexture.prototype.getImage = function() {
        var a = new Image;
        return a.src = this.getBase64(), a;
    }, c53.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL();
    }, c53.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === c53.WEBGL) {
            var a = this.renderer.gl, b = this.textureBuffer.width, d = this.textureBuffer.height, e = new Uint8Array(4 * b * d);
            a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer), a.readPixels(0, 0, b, d, a.RGBA, a.UNSIGNED_BYTE, e), a.bindFramebuffer(a.FRAMEBUFFER, null);
            var f = new PIXI.CanvasBuffer(b, d), g = f.context.getImageData(0, 0, b, d);
            return g.data.set(e), f.context.putImageData(g, 0, 0), f.canvas;
        }
        return this.textureBuffer.canvas;
    }, c53.Text = function(a, b, d, e, f) {
        b = b || 0, d = d || 0, e = void 0 === e || null === e ? "" : e.toString(), f = c53.Utils.extend({}, f), this.type = c53.TEXT, this.physicsType = c53.SPRITE, this.padding = new c53.Point, this.textBounds = null, this.canvas = c53.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this.splitRegExp = /(?:\r\n|\r|\n)/, this.characterLimitSize = -1, this.characterLimitSuffix = "", this._res = a.renderer.resolution, this._text = e, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, c53.Sprite.call(this, a, b, d, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(f), "" !== e && this.updateText();
    }, c53.Text.prototype = Object.create(c53.Sprite.prototype), c53.Text.prototype.constructor = c53.Text, c53.Text.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    }, c53.Text.prototype.update = function() {}, c53.Text.prototype.destroy = function(a) {
        this.texture.destroy(!0), c53.Component.Destroy.prototype.destroy.call(this, a);
    }, c53.Text.prototype.setShadow = function(a, b, c, d, e, f) {
        return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = "rgba(0, 0, 0, 1)"), void 0 === d && (d = 0), void 0 === e && (e = !0), void 0 === f && (f = !0), this.style.shadowOffsetX = a, this.style.shadowOffsetY = b, this.style.shadowColor = c, this.style.shadowBlur = d, this.style.shadowStroke = e, this.style.shadowFill = f, this.dirty = !0, this;
    }, c53.Text.prototype.setStyle = function(a, b) {
        void 0 === b && (b = !1);
        var c = Object.assign({}, a);
        c.font = a.font || "bold 20pt Arial", c.backgroundColor = a.backgroundColor || null, c.fill = a.fill || "black", c.align = (a.align || "left").toLowerCase(), c.boundsAlignH = (a.boundsAlignH || "left").toLowerCase(), c.boundsAlignV = (a.boundsAlignV || "top").toLowerCase(), c.stroke = a.stroke || "black", c.strokeThickness = Number(a.strokeThickness) || 0, c.wordWrap = a.wordWrap || !1, c.wordWrapWidth = a.wordWrapWidth || 100, c.maxLines = a.maxLines || 0, c.shadowOffsetX = a.shadowOffsetX || 0, c.shadowOffsetY = a.shadowOffsetY || 0, c.shadowColor = a.shadowColor || "rgba(0,0,0,0)", c.shadowBlur = a.shadowBlur || 0, c.tabs = a.tabs || 0;
        var d = this.fontToComponents(c.font);
        return c.fontStyle && (d.fontStyle = c.fontStyle), c.fontVariant && (d.fontVariant = c.fontVariant), c.fontWeight && (d.fontWeight = c.fontWeight), c.fontSize && ("number" == typeof c.fontSize && (c.fontSize = c.fontSize + "px"), d.fontSize = c.fontSize), this._fontComponents = d, c.font = this.componentsToFont(this._fontComponents), this.style = c, this.dirty = !0, b && this.updateText(), this;
    }, c53.Text.prototype.updateText = function() {
        this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
        var a = this.text;
        this.characterLimitSize > -1 && this.characterLimitSize < a.length && (a = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix), this.style.wordWrap && (a = this.runWordWrap(this.text));
        var b = a.split(this.splitRegExp), c = this.style.tabs, d = [], e = 0, f = this.determineFontProperties(this.style.font), g = b.length;
        this.style.maxLines > 0 && this.style.maxLines < b.length && (g = this.style.maxLines), this._charCount = 0;
        for(var h = 0; h < g; h++){
            if (0 === c) {
                var i = this.style.strokeThickness + this.padding.x;
                this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? i += this.measureLine(b[h]) : i += this.context.measureText(b[h]).width, this.style.wordWrap && (i -= this.context.measureText(" ").width);
            } else {
                var j = b[h].split(/(?:\t)/), i = this.padding.x + this.style.strokeThickness;
                if (Array.isArray(c)) for(var k = 0, l = 0; l < j.length; l++){
                    var m = 0;
                    m = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width), l > 0 && (k += c[l - 1]), i = k + m;
                }
                else for(var l = 0; l < j.length; l++){
                    this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? i += this.measureLine(j[l]) : i += Math.ceil(this.context.measureText(j[l]).width);
                    var n = this.game.math.snapToCeil(i, c) - i;
                    i += n;
                }
            }
            d[h] = Math.ceil(i), e = Math.max(e, d[h]);
        }
        this.canvas.width = e * this._res;
        var o = f.fontSize + this.style.strokeThickness + this.padding.y, p = o * g, q = this._lineSpacing;
        q < 0 && Math.abs(q) > o && (q = -o), 0 !== q && (p += q > 0 ? q * b.length : q * (b.length - 1)), this.canvas.height = p * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
        var r, s;
        for(this._charCount = 0, h = 0; h < g; h++)r = this.style.strokeThickness / 2, s = this.style.strokeThickness / 2 + h * o + f.ascent, h > 0 && (s += q * h), "right" === this.style.align ? r += e - d[h] : "center" === this.style.align && (r += (e - d[h]) / 2), this.autoRound && (r = Math.round(r), s = Math.round(s)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(b[h], r, s) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === c ? this.context.strokeText(b[h], r, s) : this.renderTabLine(b[h], r, s, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === c ? this.context.fillText(b[h], r, s) : this.renderTabLine(b[h], r, s, !0)));
        this.updateTexture(), this.dirty = !1;
    }, c53.Text.prototype.renderTabLine = function(a, b, c, d) {
        var e = a.split(/(?:\t)/), f = this.style.tabs, g = 0;
        if (Array.isArray(f)) for(var h = 0, i = 0; i < e.length; i++)i > 0 && (h += f[i - 1]), g = b + h, d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c);
        else for(var i = 0; i < e.length; i++){
            var j = Math.ceil(this.context.measureText(e[i]).width);
            g = this.game.math.snapToCeil(b, f), d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c), b = g + j;
        }
    }, c53.Text.prototype.updateShadow = function(a) {
        a ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0);
    }, c53.Text.prototype.measureLine = function(a) {
        for(var b = 0, c = 0; c < a.length; c++){
            var d = a[c];
            if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                var e = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (e.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (e.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(e);
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), b += this.context.measureText(d).width, this._charCount++;
        }
        return Math.ceil(b);
    }, c53.Text.prototype.updateLine = function(a, b, c) {
        for(var d = 0; d < a.length; d++){
            var e = a[d];
            if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                var f = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (f.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (f.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(f);
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(e, b, c)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(e, b, c)), b += this.context.measureText(e).width, this._charCount++;
        }
    }, c53.Text.prototype.clearColors = function() {
        return this.colors = [], this.strokeColors = [], this.dirty = !0, this;
    }, c53.Text.prototype.clearFontValues = function() {
        return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this;
    }, c53.Text.prototype.addColor = function(a, b) {
        return this.colors[b] = a, this.dirty = !0, this;
    }, c53.Text.prototype.addStrokeColor = function(a, b) {
        return this.strokeColors[b] = a, this.dirty = !0, this;
    }, c53.Text.prototype.addFontStyle = function(a, b) {
        return this.fontStyles[b] = a, this.dirty = !0, this;
    }, c53.Text.prototype.addFontWeight = function(a, b) {
        return this.fontWeights[b] = a, this.dirty = !0, this;
    }, c53.Text.prototype.precalculateWordWrap = function(a) {
        return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(a).split(/(?:\r\n|\r|\n)/);
    }, c53.Text.prototype.runWordWrap = function(a) {
        return this.useAdvancedWrap ? this.advancedWordWrap(a) : this.basicWordWrap(a);
    }, c53.Text.prototype.advancedWordWrap = function(a) {
        for(var b = this.context, c = this.style.wordWrapWidth, d = "", e = a.replace(/ +/gi, " ").split(/\r?\n/gi), f = e.length, g = 0; g < f; g++){
            var h = e[g], i = "";
            h = h.replace(/^ *|\s*$/gi, "");
            if (b.measureText(h).width < c) d += h + "\n";
            else {
                for(var j = c, k = h.split(" "), l = 0; l < k.length; l++){
                    var m = k[l], n = m + " ", o = b.measureText(n).width;
                    if (o > j) {
                        if (0 === l) {
                            for(var p = n; p.length && (p = p.slice(0, -1), !((o = b.measureText(p).width) <= j)););
                            if (!p.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                            var q = m.substr(p.length);
                            k[l] = q, i += p;
                        }
                        var r = k[l].length ? l : l + 1, s = k.slice(r).join(" ").replace(/[ \n]*$/gi, "");
                        e[g + 1] = s + " " + (e[g + 1] || ""), f = e.length;
                        break;
                    }
                    i += n, j -= o;
                }
                d += i.replace(/[ \n]*$/gi, "") + "\n";
            }
        }
        return d = d.replace(/[\s|\n]*$/gi, "");
    }, c53.Text.prototype.basicWordWrap = function(a) {
        for(var b = "", c = a.split("\n"), d = 0; d < c.length; d++){
            for(var e = this.style.wordWrapWidth, f = c[d].split(" "), g = 0; g < f.length; g++){
                var h = this.context.measureText(f[g]).width, i = h + this.context.measureText(" ").width;
                i > e ? (g > 0 && (b += "\n"), b += f[g] + " ", e = this.style.wordWrapWidth - h) : (e -= i, b += f[g] + " ");
            }
            d < c.length - 1 && (b += "\n");
        }
        return b;
    }, c53.Text.prototype.updateFont = function(a) {
        var b = this.componentsToFont(a);
        this.style.font !== b && (this.style.font = b, this.dirty = !0, this.parent && this.updateTransform());
    }, c53.Text.prototype.fontToComponents = function(a) {
        var b = a.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
        if (b) {
            var c = b[5].trim();
            return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(c) || /['",]/.exec(c) || (c = "'" + c + "'"), {
                font: a,
                fontStyle: b[1] || "normal",
                fontVariant: b[2] || "normal",
                fontWeight: b[3] || "normal",
                fontSize: b[4] || "medium",
                fontFamily: c
            };
        }
        return console.warn("Phaser.Text - unparsable CSS font: " + a), {
            font: a
        };
    }, c53.Text.prototype.componentsToFont = function(a) {
        var b, c = [];
        return b = a.fontStyle, b && "normal" !== b && c.push(b), b = a.fontVariant, b && "normal" !== b && c.push(b), b = a.fontWeight, b && "normal" !== b && c.push(b), b = a.fontSize, b && "medium" !== b && c.push(b), b = a.fontFamily, b && c.push(b), c.length || c.push(a.font), c.join(" ");
    }, c53.Text.prototype.setText = function(a, b) {
        return void 0 === b && (b = !1), this.text = a.toString() || "", b ? this.updateText() : this.dirty = !0, this;
    }, c53.Text.prototype.parseList = function(a) {
        if (!Array.isArray(a)) return this;
        for(var b = "", c = 0; c < a.length; c++)Array.isArray(a[c]) ? (b += a[c].join("\t"), c < a.length - 1 && (b += "\n")) : (b += a[c], c < a.length - 1 && (b += "\t"));
        return this.text = b, this.dirty = !0, this;
    }, c53.Text.prototype.setTextBounds = function(a, b, d, e) {
        return void 0 === a ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(a, b, d, e) : this.textBounds = new c53.Rectangle(a, b, d, e), this.style.wordWrapWidth > d && (this.style.wordWrapWidth = d)), this.updateTexture(), this;
    }, c53.Text.prototype.updateTexture = function() {
        var a = this.texture.baseTexture, b = this.texture.crop, c = this.texture.frame, d = this.canvas.width, e = this.canvas.height;
        if (a.width = d, a.height = e, b.width = d, b.height = e, c.width = d, c.height = e, this.texture.width = d, this.texture.height = e, this._width = d, this._height = e, this.textBounds) {
            var f = this.textBounds.x, g = this.textBounds.y;
            "right" === this.style.boundsAlignH ? f += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (f += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? g += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (g += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -f, this.pivot.y = -g;
        }
        this.renderable = 0 !== d && 0 !== e, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty();
    }, c53.Text.prototype._renderWebGL = function(a) {
        this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, a);
    }, c53.Text.prototype._renderCanvas = function(a) {
        this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, a);
    }, c53.Text.prototype.determineFontProperties = function(a) {
        var b = c53.Text.fontPropertiesCache[a];
        if (!b) {
            b = {};
            var d = c53.Text.fontPropertiesCanvas, e = c53.Text.fontPropertiesContext;
            e.font = a;
            var f = Math.ceil(e.measureText("|Mq").width), g = Math.ceil(e.measureText("|Mq").width), h = 2 * g;
            if (g = 1.4 * g | 0, d.width = f, d.height = h, e.fillStyle = "#f00", e.fillRect(0, 0, f, h), e.font = a, e.textBaseline = "alphabetic", e.fillStyle = "#000", e.fillText("|Mq", 0, g), !e.getImageData(0, 0, f, h)) return b.ascent = g, b.descent = g + 6, b.fontSize = b.ascent + b.descent, c53.Text.fontPropertiesCache[a] = b, b;
            var i, j, k = e.getImageData(0, 0, f, h).data, l = k.length, m = 4 * f, n = 0, o = !1;
            for(i = 0; i < g; i++){
                for(j = 0; j < m; j += 4)if (255 !== k[n + j]) {
                    o = !0;
                    break;
                }
                if (o) break;
                n += m;
            }
            for(b.ascent = g - i, n = l - m, o = !1, i = h; i > g; i--){
                for(j = 0; j < m; j += 4)if (255 !== k[n + j]) {
                    o = !0;
                    break;
                }
                if (o) break;
                n -= m;
            }
            b.descent = i - g, b.descent += 6, b.fontSize = b.ascent + b.descent, c53.Text.fontPropertiesCache[a] = b;
        }
        return b;
    }, c53.Text.prototype.getBounds = function(a) {
        return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, a);
    }, c53.Text.prototype.setCharacterLimit = function(a, b) {
        this.characterLimitSuffix = void 0 === b ? "" : b, this.characterLimitSize = a, this.updateText();
    }, Object.defineProperty(c53.Text.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(a) {
            a !== this._text && (this._text = a.toString() || "", this.dirty = !0, this.parent && this.updateTransform());
        }
    }), Object.defineProperty(c53.Text.prototype, "cssFont", {
        get: function() {
            return this.componentsToFont(this._fontComponents);
        },
        set: function(a) {
            a = a || "bold 20pt Arial", this._fontComponents = this.fontToComponents(a), this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c53.Text.prototype, "font", {
        get: function() {
            return this._fontComponents.fontFamily;
        },
        set: function(a) {
            a = a || "Arial", a = a.trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(a) || /['",]/.exec(a) || (a = "'" + a + "'"), this._fontComponents.fontFamily = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c53.Text.prototype, "fontSize", {
        get: function() {
            var a = this._fontComponents.fontSize;
            return a && /(?:^0$|px$)/.exec(a) ? parseInt(a, 10) : a;
        },
        set: function(a) {
            a = a || "0", "number" == typeof a && (a += "px"), this._fontComponents.fontSize = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c53.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontComponents.fontWeight || "normal";
        },
        set: function(a) {
            a = a || "normal", this._fontComponents.fontWeight = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c53.Text.prototype, "fontStyle", {
        get: function() {
            return this._fontComponents.fontStyle || "normal";
        },
        set: function(a) {
            a = a || "normal", this._fontComponents.fontStyle = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c53.Text.prototype, "fontVariant", {
        get: function() {
            return this._fontComponents.fontVariant || "normal";
        },
        set: function(a) {
            a = a || "normal", this._fontComponents.fontVariant = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c53.Text.prototype, "fill", {
        get: function() {
            return this.style.fill;
        },
        set: function(a) {
            a !== this.style.fill && (this.style.fill = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "align", {
        get: function() {
            return this.style.align;
        },
        set: function(a) {
            (a = a.toLowerCase()) !== this.style.align && (this.style.align = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "resolution", {
        get: function() {
            return this._res;
        },
        set: function(a) {
            a !== this._res && (this._res = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "tabs", {
        get: function() {
            return this.style.tabs;
        },
        set: function(a) {
            a !== this.style.tabs && (this.style.tabs = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "boundsAlignH", {
        get: function() {
            return this.style.boundsAlignH;
        },
        set: function(a) {
            (a = a.toLowerCase()) !== this.style.boundsAlignH && (this.style.boundsAlignH = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "boundsAlignV", {
        get: function() {
            return this.style.boundsAlignV;
        },
        set: function(a) {
            (a = a.toLowerCase()) !== this.style.boundsAlignV && (this.style.boundsAlignV = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke;
        },
        set: function(a) {
            a !== this.style.stroke && (this.style.stroke = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness;
        },
        set: function(a) {
            a !== this.style.strokeThickness && (this.style.strokeThickness = Number(a), this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap;
        },
        set: function(a) {
            a !== this.style.wordWrap && (this.style.wordWrap = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth;
        },
        set: function(a) {
            a !== this.style.wordWrapWidth && (this.style.wordWrapWidth = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing;
        },
        set: function(a) {
            a !== this._lineSpacing && (this._lineSpacing = parseFloat(a), this.dirty = !0, this.parent && this.updateTransform());
        }
    }), Object.defineProperty(c53.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX;
        },
        set: function(a) {
            a !== this.style.shadowOffsetX && (this.style.shadowOffsetX = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY;
        },
        set: function(a) {
            a !== this.style.shadowOffsetY && (this.style.shadowOffsetY = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor;
        },
        set: function(a) {
            a !== this.style.shadowColor && (this.style.shadowColor = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur;
        },
        set: function(a) {
            a !== this.style.shadowBlur && (this.style.shadowBlur = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "shadowStroke", {
        get: function() {
            return this.style.shadowStroke;
        },
        set: function(a) {
            a !== this.style.shadowStroke && (this.style.shadowStroke = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "shadowFill", {
        get: function() {
            return this.style.shadowFill;
        },
        set: function(a) {
            a !== this.style.shadowFill && (this.style.shadowFill = a, this.dirty = !0);
        }
    }), Object.defineProperty(c53.Text.prototype, "width", {
        get: function() {
            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * (this.texture.frame.width / this.resolution);
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width, this._width = a;
        }
    }), Object.defineProperty(c53.Text.prototype, "height", {
        get: function() {
            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * (this.texture.frame.height / this.resolution);
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height, this._height = a;
        }
    }), c53.Text.fontPropertiesCache = {}, c53.Text.fontPropertiesCanvas = document.createElement("canvas"), c53.Text.fontPropertiesContext = c53.Text.fontPropertiesCanvas.getContext("2d"), c53.BitmapText = function(a, b, d, e, f, g, h) {
        b = b || 0, d = d || 0, e = e || "", f = f || "", g = g || 32, h = h || "left", PIXI.DisplayObjectContainer.call(this), this.type = c53.BITMAPTEXT, this.physicsType = c53.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new c53.Point, this._prevAnchor = new c53.Point, this._glyphs = [], this._maxWidth = 0, this._text = f.toString() || "", this._data = a.cache.getBitmapFont(e), this._font = e, this._fontSize = g, this._align = h, this._tint = 16777215, this.updateText(), this.dirty = !1, c53.Component.Core.init.call(this, a, b, d, "", null);
    }, c53.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c53.BitmapText.prototype.constructor = c53.BitmapText, c53.Component.Core.install.call(c53.BitmapText.prototype, [
        "Angle",
        "AutoCull",
        "Bounds",
        "Destroy",
        "FixedToCamera",
        "InputEnabled",
        "InWorld",
        "LifeSpan",
        "PhysicsBody",
        "Reset"
    ]), c53.BitmapText.prototype.preUpdatePhysics = c53.Component.PhysicsBody.preUpdate, c53.BitmapText.prototype.preUpdateLifeSpan = c53.Component.LifeSpan.preUpdate, c53.BitmapText.prototype.preUpdateInWorld = c53.Component.InWorld.preUpdate, c53.BitmapText.prototype.preUpdateCore = c53.Component.Core.preUpdate, c53.BitmapText.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    }, c53.BitmapText.prototype.postUpdate = function() {
        c53.Component.PhysicsBody.postUpdate.call(this), c53.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === c53.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight));
    }, c53.BitmapText.prototype.setText = function(a) {
        this.text = a;
    }, c53.BitmapText.prototype.scanLine = function(a, b, c) {
        for(var d = 0, e = 0, f = -1, g = 0, h = null, i = this._maxWidth > 0 ? this._maxWidth : null, j = [], k = 0; k < c.length; k++){
            var l = k === c.length - 1;
            if (/(?:\r\n|\r|\n)/.test(c.charAt(k))) return {
                width: e,
                text: c.substr(0, k),
                end: l,
                chars: j
            };
            var m = c.charCodeAt(k), n = a.chars[m], o = 0;
            void 0 === n && (m = 32, n = a.chars[m]);
            var p = h && n.kerning[h] ? n.kerning[h] : 0;
            if (/(\s)/.test(c.charAt(k)) && (f = k, g = e), o = (p + n.texture.width + n.xOffset) * b, i && e + o >= i && f > -1) return {
                width: g || e,
                text: c.substr(0, k - (k - f)),
                end: l,
                chars: j
            };
            e += (n.xAdvance + p) * b, j.push(d + (n.xOffset + p) * b), d += (n.xAdvance + p) * b, h = m;
        }
        return {
            width: e,
            text: c,
            end: l,
            chars: j
        };
    }, c53.BitmapText.prototype.cleanText = function(a, b) {
        void 0 === b && (b = "");
        var c = this._data.font;
        if (!c) return "";
        for(var d = /\r\n|\n\r|\n|\r/g, e = a.replace(d, "\n").split("\n"), f = 0; f < e.length; f++){
            for(var g = "", h = e[f], i = 0; i < h.length; i++)g = c.chars[h.charCodeAt(i)] ? g.concat(h[i]) : g.concat(b);
            e[f] = g;
        }
        return e.join("\n");
    }, c53.BitmapText.prototype.updateText = function() {
        var a = this._data.font;
        if (a) {
            var b = this.text, c = this._fontSize / a.size, d = [], e = 0;
            this.textWidth = 0;
            do {
                var f = this.scanLine(a, c, b);
                f.y = e, d.push(f), f.width > this.textWidth && (this.textWidth = f.width), e += a.lineHeight * c, b = b.substr(f.text.length + 1);
            }while (!1 === f.end)
            this.textHeight = e;
            for(var g = 0, h = 0, i = this.textWidth * this.anchor.x, j = this.textHeight * this.anchor.y, k = 0; k < d.length; k++){
                var f = d[k];
                "right" === this._align ? h = this.textWidth - f.width : "center" === this._align && (h = (this.textWidth - f.width) / 2);
                for(var l = 0; l < f.text.length; l++){
                    var m = f.text.charCodeAt(l), n = a.chars[m];
                    void 0 === n && (m = 32, n = a.chars[m]);
                    var o = this._glyphs[g];
                    o ? o.texture = n.texture : (o = new PIXI.Sprite(n.texture), o.name = f.text[l], this._glyphs.push(o)), o.position.x = f.chars[l] + h - i, o.position.y = f.y + n.yOffset * c - j, o.scale.set(c), o.tint = this.tint, o.texture.requiresReTint = !0, o.cachedTint = 16777215, o.parent || this.addChild(o), g++;
                }
            }
            for(k = g; k < this._glyphs.length; k++)this.removeChild(this._glyphs[k]);
        }
    }, c53.BitmapText.prototype.purgeGlyphs = function() {
        for(var a = this._glyphs.length, b = [], c = 0; c < this._glyphs.length; c++)this._glyphs[c].parent !== this ? this._glyphs[c].destroy() : b.push(this._glyphs[c]);
        return this._glyphs = [], this._glyphs = b, this.updateText(), a - b.length;
    }, c53.BitmapText.prototype.updateTransform = function() {
        !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    }, Object.defineProperty(c53.BitmapText.prototype, "align", {
        get: function() {
            return this._align;
        },
        set: function(a) {
            a === this._align || "left" !== a && "center" !== a && "right" !== a || (this._align = a, this.updateText());
        }
    }), Object.defineProperty(c53.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint;
        },
        set: function(a) {
            a !== this._tint && (this._tint = a, this.updateText());
        }
    }), Object.defineProperty(c53.BitmapText.prototype, "font", {
        get: function() {
            return this._font;
        },
        set: function(a) {
            a !== this._font && (this._font = a.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText());
        }
    }), Object.defineProperty(c53.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize;
        },
        set: function(a) {
            (a = parseInt(a, 10)) !== this._fontSize && a > 0 && (this._fontSize = a, this.updateText());
        }
    }), Object.defineProperty(c53.BitmapText.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(a) {
            a !== this._text && (this._text = a.toString() || "", this.updateText());
        }
    }), Object.defineProperty(c53.BitmapText.prototype, "maxWidth", {
        get: function() {
            return this._maxWidth;
        },
        set: function(a) {
            a !== this._maxWidth && (this._maxWidth = a, this.updateText());
        }
    }), Object.defineProperty(c53.BitmapText.prototype, "smoothed", {
        get: function() {
            return !this._data.base.scaleMode;
        },
        set: function(a) {
            this._data.base.scaleMode = a ? 0 : 1;
        }
    }), c53.RetroFont = function(a, b, d, e, f, g, h, i, j, k) {
        if (!a.cache.checkImageKey(b)) return !1;
        void 0 !== g && null !== g || (g = a.cache.getImage(b).width / d), this.characterWidth = d, this.characterHeight = e, this.characterSpacingX = h || 0, this.characterSpacingY = i || 0, this.characterPerRow = g, this.offsetX = j || 0, this.offsetY = k || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = a.cache.getImage(b), this._text = "", this.grabData = [], this.frameData = new c53.FrameData;
        for(var l = this.offsetX, m = this.offsetY, n = 0, o = 0; o < f.length; o++){
            var p = this.frameData.addFrame(new c53.Frame(o, l, m, this.characterWidth, this.characterHeight));
            this.grabData[f.charCodeAt(o)] = p.index, n++, n === this.characterPerRow ? (n = 0, l = this.offsetX, m += this.characterHeight + this.characterSpacingY) : l += this.characterWidth + this.characterSpacingX;
        }
        a.cache.updateFrameData(b, this.frameData), this.stamp = new c53.Image(a, 0, 0, b, 0), c53.RenderTexture.call(this, a, 100, 100, "", c53.scaleModes.NEAREST), this.type = c53.RETROFONT;
    }, c53.RetroFont.prototype = Object.create(c53.RenderTexture.prototype), c53.RetroFont.prototype.constructor = c53.RetroFont, c53.RetroFont.ALIGN_LEFT = "left", c53.RetroFont.ALIGN_RIGHT = "right", c53.RetroFont.ALIGN_CENTER = "center", c53.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", c53.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", c53.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", c53.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", c53.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", c53.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", c53.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", c53.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", c53.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", c53.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", c53.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", c53.RetroFont.prototype.setFixedWidth = function(a, b) {
        void 0 === b && (b = "left"), this.fixedWidth = a, this.align = b;
    }, c53.RetroFont.prototype.setText = function(a, b, c, d, e, f) {
        this.multiLine = b || !1, this.customSpacingX = c || 0, this.customSpacingY = d || 0, this.align = e || "left", this.autoUpperCase = !f, a.length > 0 && (this.text = a);
    }, c53.RetroFont.prototype.buildRetroFontText = function() {
        var a = 0, b = 0;
        if (this.clear(), this.multiLine) {
            var d = this._text.split("\n");
            this.fixedWidth > 0 ? this.resize(this.fixedWidth, d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
            for(var e = 0; e < d.length; e++)a = 0, this.align === c53.RetroFont.ALIGN_RIGHT ? a = this.width - d[e].length * (this.characterWidth + this.customSpacingX) : this.align === c53.RetroFont.ALIGN_CENTER && (a = this.width / 2 - d[e].length * (this.characterWidth + this.customSpacingX) / 2, a += this.customSpacingX / 2), a < 0 && (a = 0), this.pasteLine(d[e], a, b, this.customSpacingX), b += this.characterHeight + this.customSpacingY;
        } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), a = 0, this.align === c53.RetroFont.ALIGN_RIGHT ? a = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === c53.RetroFont.ALIGN_CENTER && (a = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, a += this.customSpacingX / 2), a < 0 && (a = 0), this.pasteLine(this._text, a, 0, this.customSpacingX);
        this.requiresReTint = !0;
    }, c53.RetroFont.prototype.pasteLine = function(a, b, c, d) {
        for(var e = 0; e < a.length; e++)if (" " === a.charAt(e)) b += this.characterWidth + d;
        else if (this.grabData[a.charCodeAt(e)] >= 0 && (this.stamp.frame = this.grabData[a.charCodeAt(e)], this.renderXY(this.stamp, b, c, !1), (b += this.characterWidth + d) > this.width)) break;
    }, c53.RetroFont.prototype.getLongestLine = function() {
        var a = 0;
        if (this._text.length > 0) for(var b = this._text.split("\n"), c = 0; c < b.length; c++)b[c].length > a && (a = b[c].length);
        return a;
    }, c53.RetroFont.prototype.removeUnsupportedCharacters = function(a) {
        for(var b = "", c = 0; c < this._text.length; c++){
            var d = this._text[c], e = d.charCodeAt(0);
            (this.grabData[e] >= 0 || !a && "\n" === d) && (b = b.concat(d));
        }
        return b;
    }, c53.RetroFont.prototype.updateOffset = function(a, b) {
        if (this.offsetX !== a || this.offsetY !== b) {
            for(var c = a - this.offsetX, d = b - this.offsetY, e = this.game.cache.getFrameData(this.stamp.key).getFrames(), f = e.length; f--;)e[f].x += c, e[f].y += d;
            this.buildRetroFontText();
        }
    }, Object.defineProperty(c53.RetroFont.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(a) {
            var b;
            (b = this.autoUpperCase ? a.toUpperCase() : a) !== this._text && (this._text = b, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText());
        }
    }), Object.defineProperty(c53.RetroFont.prototype, "smoothed", {
        get: function() {
            return this.stamp.smoothed;
        },
        set: function(a) {
            this.stamp.smoothed = a, this.buildRetroFontText();
        }
    }), c53.Rope = function(a, b, d, e, f, g) {
        this.points = [], this.points = g, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c53.ROPE, this.points = g, PIXI.DisplayObjectContainer.call(this), this.texture = c53.Cache.DEFAULT, this.uvs = new Float32Array([
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]), this.vertices = new Float32Array([
            0,
            0,
            100,
            0,
            100,
            100,
            0,
            100
        ]), this.colors = new Float32Array([
            1,
            1,
            1,
            1
        ]), this.indices = new Uint16Array([
            0,
            1,
            2,
            3
        ]), g && (this.vertices = new Float32Array(4 * g.length), this.uvs = new Float32Array(4 * g.length), this.colors = new Float32Array(2 * g.length), this.indices = new Uint16Array(2 * g.length)), this.dirty = !0, this.canvasPadding = 0, this.drawMode = c53.Rope.TRIANGLE_STRIP, c53.Component.Core.init.call(this, a, b, d, e, f), this.refresh();
    }, c53.Rope.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c53.Rope.prototype.constructor = c53.Rope, c53.Component.Core.install.call(c53.Rope.prototype, [
        "Angle",
        "Animation",
        "AutoCull",
        "Bounds",
        "BringToTop",
        "Crop",
        "Delta",
        "Destroy",
        "FixedToCamera",
        "InWorld",
        "LifeSpan",
        "LoadTexture",
        "Overlap",
        "PhysicsBody",
        "Reset",
        "ScaleMinMax",
        "Smoothed"
    ]), c53.Rope.prototype.preUpdatePhysics = c53.Component.PhysicsBody.preUpdate, c53.Rope.prototype.preUpdateLifeSpan = c53.Component.LifeSpan.preUpdate, c53.Rope.prototype.preUpdateInWorld = c53.Component.InWorld.preUpdate, c53.Rope.prototype.preUpdateCore = c53.Component.Core.preUpdate, c53.Rope.TRIANGLE_STRIP = 0, c53.Rope.TRIANGLES = 1, c53.Rope.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    }, c53.Rope.prototype.update = function() {
        this._hasUpdateAnimation && this.updateAnimation.call(this);
    }, c53.Rope.prototype.reset = function(a, b) {
        return c53.Component.Reset.prototype.reset.call(this, a, b), this;
    }, c53.Rope.prototype.refresh = function() {
        var a = this.points;
        if (!(a.length < 1)) {
            var b = this.uvs, c = this.indices, d = this.colors;
            this.count -= 0.2, b[0] = 0, b[1] = 0, b[2] = 0, b[3] = 1, d[0] = 1, d[1] = 1, c[0] = 0, c[1] = 1;
            for(var e, f, g = a.length, h = 1; h < g; h++)e = 4 * h, f = h / (g - 1), b[e] = f, b[e + 1] = 0, b[e + 2] = f, b[e + 3] = 1, e = 2 * h, d[e] = 1, d[e + 1] = 1, e = 2 * h, c[e] = e, c[e + 1] = e + 1;
        }
    }, c53.Rope.prototype.updateTransform = function() {
        var a = this.points;
        if (!(a.length < 1)) {
            var b, c = a[0], d = {
                x: 0,
                y: 0
            };
            this.count -= 0.2;
            for(var e, f, g, h, i, j = this.vertices, k = a.length, l = 0; l < k; l++)e = a[l], f = 4 * l, b = l < a.length - 1 ? a[l + 1] : e, d.y = -(b.x - c.x), d.x = b.y - c.y, g = 10 * (1 - l / (k - 1)), g > 1 && (g = 1), h = Math.sqrt(d.x * d.x + d.y * d.y), i = this.texture.height / 2, d.x /= h, d.y /= h, d.x *= i, d.y *= i, j[f] = e.x + d.x, j[f + 1] = e.y + d.y, j[f + 2] = e.x - d.x, j[f + 3] = e.y - d.y, c = e;
            PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
        }
    }, c53.Rope.prototype.setTexture = function(a) {
        this.texture = a;
    }, c53.Rope.prototype._renderWebGL = function(a) {
        !this.visible || this.alpha <= 0 || (a.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(a), a.shaderManager.setShader(a.shaderManager.stripShader), this._renderStrip(a), a.spriteBatch.start());
    }, c53.Rope.prototype._initWebGL = function(a) {
        var b = a.gl;
        this._vertexBuffer = b.createBuffer(), this._indexBuffer = b.createBuffer(), this._uvBuffer = b.createBuffer(), this._colorBuffer = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer), b.bufferData(b.ARRAY_BUFFER, this.vertices, b.DYNAMIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer), b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._colorBuffer), b.bufferData(b.ARRAY_BUFFER, this.colors, b.STATIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer), b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW);
    }, c53.Rope.prototype._renderStrip = function(a) {
        var b = a.gl, d = a.projection, e = a.offset, f = a.shaderManager.stripShader, g = this.drawMode === c53.Rope.TRIANGLE_STRIP ? b.TRIANGLE_STRIP : b.TRIANGLES;
        a.blendModeManager.setBlendMode(this.blendMode), b.uniformMatrix3fv(f.translationMatrix, !1, this.worldTransform.toArray(!0)), b.uniform2f(f.projectionVector, d.x, -d.y), b.uniform2f(f.offsetVector, -e.x, -e.y), b.uniform1f(f.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer), b.bufferData(b.ARRAY_BUFFER, this.vertices, b.STATIC_DRAW), b.vertexAttribPointer(f.aVertexPosition, 2, b.FLOAT, !1, 0, 0), b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer), b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW), b.vertexAttribPointer(f.aTextureCoord, 2, b.FLOAT, !1, 0, 0), b.activeTexture(b.TEXTURE0), this.texture.baseTexture._dirty[b.id] ? a.renderer.updateTexture(this.texture.baseTexture) : b.bindTexture(b.TEXTURE_2D, this.texture.baseTexture._glTextures[b.id]), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer), b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW)) : (b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer), b.bufferSubData(b.ARRAY_BUFFER, 0, this.vertices), b.vertexAttribPointer(f.aVertexPosition, 2, b.FLOAT, !1, 0, 0), b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer), b.vertexAttribPointer(f.aTextureCoord, 2, b.FLOAT, !1, 0, 0), b.activeTexture(b.TEXTURE0), this.texture.baseTexture._dirty[b.id] ? a.renderer.updateTexture(this.texture.baseTexture) : b.bindTexture(b.TEXTURE_2D, this.texture.baseTexture._glTextures[b.id]), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), b.drawElements(g, this.indices.length, b.UNSIGNED_SHORT, 0);
    }, c53.Rope.prototype._renderCanvas = function(a) {
        var b = a.context, d = this.worldTransform, e = d.tx * a.resolution + a.shakeX, f = d.ty * a.resolution + a.shakeY;
        a.roundPixels ? b.setTransform(d.a, d.b, d.c, d.d, 0 | e, 0 | f) : b.setTransform(d.a, d.b, d.c, d.d, e, f), this.drawMode === c53.Rope.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(b) : this._renderCanvasTriangles(b);
    }, c53.Rope.prototype._renderCanvasTriangleStrip = function(a) {
        var b = this.vertices, c = this.uvs, d = b.length / 2;
        this.count++;
        for(var e = 0; e < d - 2; e++){
            var f = 2 * e;
            this._renderCanvasDrawTriangle(a, b, c, f, f + 2, f + 4);
        }
    }, c53.Rope.prototype._renderCanvasTriangles = function(a) {
        var b = this.vertices, c = this.uvs, d = this.indices, e = d.length;
        this.count++;
        for(var f = 0; f < e; f += 3){
            var g = 2 * d[f], h = 2 * d[f + 1], i = 2 * d[f + 2];
            this._renderCanvasDrawTriangle(a, b, c, g, h, i);
        }
    }, c53.Rope.prototype._renderCanvasDrawTriangle = function(a, b, c, d, e, f) {
        var g = this.texture.baseTexture.source, h = this.texture.width, i = this.texture.height, j = b[d], k = b[e], l = b[f], m = b[d + 1], n = b[e + 1], o = b[f + 1], p = c[d] * h, q = c[e] * h, r = c[f] * h, s = c[d + 1] * i, t = c[e + 1] * i, u = c[f + 1] * i;
        if (this.canvasPadding > 0) {
            var v = this.canvasPadding / this.worldTransform.a, w = this.canvasPadding / this.worldTransform.d, x = (j + k + l) / 3, y = (m + n + o) / 3, z = j - x, A = m - y, B = Math.sqrt(z * z + A * A);
            j = x + z / B * (B + v), m = y + A / B * (B + w), z = k - x, A = n - y, B = Math.sqrt(z * z + A * A), k = x + z / B * (B + v), n = y + A / B * (B + w), z = l - x, A = o - y, B = Math.sqrt(z * z + A * A), l = x + z / B * (B + v), o = y + A / B * (B + w);
        }
        a.save(), a.beginPath(), a.moveTo(j, m), a.lineTo(k, n), a.lineTo(l, o), a.closePath(), a.clip();
        var C = p * t + s * r + q * u - t * r - s * q - p * u, D = j * t + s * l + k * u - t * l - s * k - j * u, E = p * k + j * r + q * l - k * r - j * q - p * l, F = p * t * l + s * k * r + j * q * u - j * t * r - s * q * l - p * k * u, G = m * t + s * o + n * u - t * o - s * n - m * u, H = p * n + m * r + q * o - n * r - m * q - p * o, I = p * t * o + s * n * r + m * q * u - m * t * r - s * q * o - p * n * u;
        a.transform(D / C, G / C, E / C, H / C, F / C, I / C), a.drawImage(g, 0, 0), a.restore();
    }, c53.Rope.prototype.renderStripFlat = function(a) {
        var b = this.context, c = a.vertices, d = c.length / 2;
        this.count++, b.beginPath();
        for(var e = 1; e < d - 2; e++){
            var f = 2 * e, g = c[f], h = c[f + 2], i = c[f + 4], j = c[f + 1], k = c[f + 3], l = c[f + 5];
            b.moveTo(g, j), b.lineTo(h, k), b.lineTo(i, l);
        }
        b.fillStyle = "#FF0000", b.fill(), b.closePath();
    }, c53.Rope.prototype.getBounds = function(a) {
        for(var b = a || this.worldTransform, c = b.a, d = b.b, e = b.c, f = b.d, g = b.tx, h = b.ty, i = -1 / 0, j = -1 / 0, k = 1 / 0, l = 1 / 0, m = this.vertices, n = 0; n < m.length; n += 2){
            var o = m[n], p = m[n + 1], q = c * o + e * p + g, r = f * p + d * o + h;
            k = q < k ? q : k, l = r < l ? r : l, i = q > i ? q : i, j = r > j ? r : j;
        }
        if (k === -1 / 0 || j === 1 / 0) return PIXI.EmptyRectangle;
        var s = this._bounds;
        return s.x = k, s.width = i - k, s.y = l, s.height = j - l, this._currentBounds = s, s;
    }, Object.defineProperty(c53.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation;
        },
        set: function(a) {
            a && "function" == typeof a ? (this._hasUpdateAnimation = !0, this._updateAnimation = a) : (this._hasUpdateAnimation = !1, this._updateAnimation = null);
        }
    }), Object.defineProperty(c53.Rope.prototype, "segments", {
        get: function() {
            for(var a, b, d, e, f, g, h, i, j = [], k = 0; k < this.points.length; k++)a = 4 * k, b = this.vertices[a] * this.scale.x, d = this.vertices[a + 1] * this.scale.y, e = this.vertices[a + 4] * this.scale.x, f = this.vertices[a + 3] * this.scale.y, g = c53.Math.difference(b, e), h = c53.Math.difference(d, f), b += this.world.x, d += this.world.y, i = new c53.Rectangle(b, d, g, h), j.push(i);
            return j;
        }
    }), c53.TileSprite = function(a, b, d, e, f, g, h) {
        b = b || 0, d = d || 0, e = e || 256, f = f || 256, g = g || null, h = h || null, PIXI.Sprite.call(this, new PIXI.Texture(c53.Cache.DEFAULT.baseTexture), e, f), this.type = c53.TILESPRITE, this.physicsType = c53.SPRITE, this._scroll = new c53.Point, this.tileScale = new c53.Point(1, 1), this.tileScaleOffset = new c53.Point(1, 1), this.tilePosition = new c53.Point, this.textureDebug = !1, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0, this._width = e, this._height = f, c53.Component.Core.init.call(this, a, b, d, g, h);
    }, c53.TileSprite.prototype = Object.create(PIXI.Sprite.prototype), c53.TileSprite.prototype.constructor = c53.TileSprite, c53.Component.Core.install.call(c53.TileSprite.prototype, [
        "Angle",
        "Animation",
        "AutoCull",
        "Bounds",
        "BringToTop",
        "Destroy",
        "FixedToCamera",
        "Health",
        "InCamera",
        "InputEnabled",
        "InWorld",
        "LifeSpan",
        "LoadTexture",
        "Overlap",
        "PhysicsBody",
        "Reset",
        "Smoothed"
    ]), c53.TileSprite.prototype.preUpdatePhysics = c53.Component.PhysicsBody.preUpdate, c53.TileSprite.prototype.preUpdateLifeSpan = c53.Component.LifeSpan.preUpdate, c53.TileSprite.prototype.preUpdateInWorld = c53.Component.InWorld.preUpdate, c53.TileSprite.prototype.preUpdateCore = c53.Component.Core.preUpdate, c53.TileSprite.prototype.preUpdate = function() {
        return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    }, c53.TileSprite.prototype.autoScroll = function(a, b) {
        return this._scroll.set(a, b), this;
    }, c53.TileSprite.prototype.stopScroll = function() {
        return this._scroll.set(0, 0), this;
    }, c53.TileSprite.prototype.destroy = function(a) {
        c53.Component.Destroy.prototype.destroy.call(this, a), PIXI.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null);
    }, c53.TileSprite.prototype.reset = function(a, b) {
        return c53.Component.Reset.prototype.reset.call(this, a, b), this.tilePosition.x = 0, this.tilePosition.y = 0, this;
    }, c53.TileSprite.prototype.setTexture = function(a) {
        return this.texture !== a && (this.texture = a, this.refreshTexture = !0, this.cachedTint = 16777215), this;
    }, c53.TileSprite.prototype._renderWebGL = function(a) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            if (this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                if (this.generateTilingTexture(!0, a), !this.tilingTexture) return;
                this.tilingTexture.needsUpdate && (this.tilingTexture.baseTexture.textureIndex = this.texture.baseTexture.textureIndex, a.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1);
            }
            a.spriteBatch.renderTilingSprite(this);
            for(var b = 0; b < this.children.length; b++)this.children[b]._renderWebGL(a);
            var c = !1;
            this._filters && (c = !0, a.spriteBatch.stop(), a.filterManager.popFilter()), this._mask && (c || a.spriteBatch.stop(), a.maskManager.popMask(this._mask, a)), c && a.spriteBatch.start();
        }
    }, c53.TileSprite.prototype._renderCanvas = function(a) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            var b = a.context;
            this._mask && a.maskManager.pushMask(this._mask, a), b.globalAlpha = this.worldAlpha;
            var c = this.worldTransform, d = a.resolution, e = c.tx * d + a.shakeX, f = c.ty * d + a.shakeY;
            if (b.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, e, f), this.refreshTexture) {
                if (this.generateTilingTexture(!1, a), !this.tilingTexture) return;
                this.tilePattern = b.createPattern(this.tilingTexture.baseTexture.source, "repeat");
            }
            var g = a.currentBlendMode;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, b.globalCompositeOperation = PIXI.blendModesCanvas[a.currentBlendMode]);
            var h = this.tilePosition, i = this.tileScale;
            h.x %= this.tilingTexture.baseTexture.width, h.y %= this.tilingTexture.baseTexture.height, b.scale(i.x, i.y), b.translate(h.x + this.anchor.x * -this._width, h.y + this.anchor.y * -this._height), b.fillStyle = this.tilePattern, e = -h.x, f = -h.y;
            var j = this._width / i.x, k = this._height / i.y;
            a.roundPixels && (e |= 0, f |= 0, j |= 0, k |= 0), b.fillRect(e, f, j, k), b.scale(1 / i.x, 1 / i.y), b.translate(-h.x + this.anchor.x * this._width, -h.y + this.anchor.y * this._height), this._mask && a.maskManager.popMask(a);
            for(var l = 0; l < this.children.length; l++)this.children[l]._renderCanvas(a);
            g !== this.blendMode && (a.currentBlendMode = g, b.globalCompositeOperation = PIXI.blendModesCanvas[g]);
        }
    }, c53.TileSprite.prototype.onTextureUpdate = function() {}, c53.TileSprite.prototype.generateTilingTexture = function(a) {
        if (this.texture.baseTexture.hasLoaded) {
            var b = this.texture, d = b.frame, e = this._frame.sourceSizeW || this._frame.width, f = this._frame.sourceSizeH || this._frame.height, g = 0, h = 0;
            this._frame.trimmed && (g = this._frame.spriteSourceSizeX, h = this._frame.spriteSourceSizeY), a && (e = c53.Math.getNextPowerOfTwo(e), f = c53.Math.getNextPowerOfTwo(f)), this.canvasBuffer ? (this.canvasBuffer.resize(e, f), this.tilingTexture.baseTexture.width = e, this.tilingTexture.baseTexture.height = f, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new PIXI.CanvasBuffer(e, f), this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, e, f));
            var i = b.crop.width, j = b.crop.height;
            i === e && j === f || (i = e, j = f), this.canvasBuffer.context.drawImage(b.baseTexture.source, b.crop.x, b.crop.y, b.crop.width, b.crop.height, g, h, i, j), this.tileScaleOffset.x = d.width / e, this.tileScaleOffset.y = d.height / f, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0;
        }
    }, c53.TileSprite.prototype.getBounds = function() {
        var a = this._width, b = this._height, c = a * (1 - this.anchor.x), d = a * -this.anchor.x, e = b * (1 - this.anchor.y), f = b * -this.anchor.y, g = this.worldTransform, h = g.a, i = g.b, j = g.c, k = g.d, l = g.tx, m = g.ty, n = h * d + j * f + l, o = k * f + i * d + m, p = h * c + j * f + l, q = k * f + i * c + m, r = h * c + j * e + l, s = k * e + i * c + m, t = h * d + j * e + l, u = k * e + i * d + m, v = -1 / 0, w = -1 / 0, x = 1 / 0, y = 1 / 0;
        x = n < x ? n : x, x = p < x ? p : x, x = r < x ? r : x, x = t < x ? t : x, y = o < y ? o : y, y = q < y ? q : y, y = s < y ? s : y, y = u < y ? u : y, v = n > v ? n : v, v = p > v ? p : v, v = r > v ? r : v, v = t > v ? t : v, w = o > w ? o : w, w = q > w ? q : w, w = s > w ? s : w, w = u > w ? u : w;
        var z = this._bounds;
        return z.x = x, z.width = v - x, z.y = y, z.height = w - y, this._currentBounds = z, z;
    }, Object.defineProperty(c53.TileSprite.prototype, "width", {
        get: function() {
            return this._width;
        },
        set: function(a) {
            this._width = a;
        }
    }), Object.defineProperty(c53.TileSprite.prototype, "height", {
        get: function() {
            return this._height;
        },
        set: function(a) {
            this._height = a;
        }
    }), c53.CanvasPool = {
        create: function(a, b, d) {
            var e, f = c53.CanvasPool.getFirst();
            if (-1 === f) {
                var g = {
                    parent: a,
                    canvas: document.createElement("canvas")
                };
                c53.CanvasPool.pool.push(g), e = g.canvas;
            } else c53.CanvasPool.pool[f].parent = a, e = c53.CanvasPool.pool[f].canvas;
            return void 0 !== b && (e.width = b, e.height = d), e;
        },
        getFirst: function() {
            for(var a = c53.CanvasPool.pool, b = 0; b < a.length; b++)if (!a[b].parent) return b;
            return -1;
        },
        remove: function(a) {
            for(var b = c53.CanvasPool.pool, d = 0; d < b.length; d++)b[d].parent === a && (b[d].parent = null, b[d].canvas.width = 1, b[d].canvas.height = 1);
        },
        removeByCanvas: function(a) {
            for(var b = c53.CanvasPool.pool, d = 0; d < b.length; d++)b[d].canvas === a && (b[d].parent = null, b[d].canvas.width = 1, b[d].canvas.height = 1);
        },
        getTotal: function() {
            for(var a = c53.CanvasPool.pool, b = 0, d = 0; d < a.length; d++)a[d].parent && b++;
            return b;
        },
        getFree: function() {
            for(var a = c53.CanvasPool.pool, b = 0, d = 0; d < a.length; d++)a[d].parent || b++;
            return b;
        }
    }, c53.CanvasPool.pool = [], c53.Device = function() {
        this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.canHandleAlpha = !1, this.canUseMultiply = !1, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1;
    }, c53.Device = new c53.Device, c53.Device.onInitialized = new c53.Signal, c53.Device.whenReady = function(a, b, c) {
        var d = this._readyCheck;
        if (this.deviceReadyAt || !d) a.call(b, this);
        else if (d._monitor || c) d._queue = d._queue || [], d._queue.push([
            a,
            b
        ]);
        else {
            d._monitor = d.bind(this), d._queue = d._queue || [], d._queue.push([
                a,
                b
            ]);
            var e = void 0 !== window.cordova, f = navigator.isCocoonJS;
            "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(d._monitor, 0) : e && !f ? document.addEventListener("deviceready", d._monitor, !1) : (document.addEventListener("DOMContentLoaded", d._monitor, !1), window.addEventListener("load", d._monitor, !1));
        }
    }, c53.Device._readyCheck = function() {
        var a = this._readyCheck;
        if (document.body) {
            if (!this.deviceReadyAt) {
                this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", a._monitor), document.removeEventListener("DOMContentLoaded", a._monitor), window.removeEventListener("load", a._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                for(var b; b = a._queue.shift();){
                    var c = b[0], d = b[1];
                    c.call(d, this);
                }
                this._readyCheck = null, this._initialize = null, this.onInitialized = null;
            }
        } else window.setTimeout(a._monitor, 20);
    }, c53.Device._initialize = function() {
        function a73() {
            var a = navigator.userAgent;
            /Playstation Vita/.test(a) ? n.vita = !0 : /Kindle/.test(a) || /\bKF[A-Z][A-Z]+/.test(a) || /Silk.*Mobile Safari/.test(a) ? n.kindle = !0 : /Android/.test(a) ? n.android = !0 : /CrOS/.test(a) ? n.chromeOS = !0 : /iP[ao]d|iPhone/i.test(a) ? (n.iOS = !0, navigator.appVersion.match(/OS (\d+)/), n.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(a) ? n.linux = !0 : /Mac OS/.test(a) ? n.macOS = !0 : /Windows/.test(a) && (n.windows = !0), (/Windows Phone/i.test(a) || /IEMobile/i.test(a)) && (n.android = !1, n.iOS = !1, n.macOS = !1, n.windows = !0, n.windowsPhone = !0);
            var b = /Silk/.test(a);
            (n.windows || n.macOS || n.linux && !b || n.chromeOS) && (n.desktop = !0), (n.windowsPhone || /Windows NT/i.test(a) && /Touch/i.test(a)) && (n.desktop = !1);
        }
        function b64() {
            var a = c53.CanvasPool.create(this, 6, 1), b = a.getContext("2d");
            b.fillStyle = "rgba(10, 20, 30, 0.5)", b.fillRect(0, 0, 1, 1);
            var d = b.getImageData(0, 0, 1, 1);
            if (d) {
                b.putImageData(d, 1, 0);
                var e = b.getImageData(1, 0, 1, 1);
                n.canHandleAlpha = e.data[0] === d.data[0] && e.data[1] === d.data[1] && e.data[2] === d.data[2] && e.data[3] === d.data[3];
            }
            b.globalCompositeOperation = "multiply", n.canUseMultiply = "multiply" === b.globalCompositeOperation, c53.CanvasPool.removeByCanvas(a), PIXI.CanvasTinter.tintMethod = n.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel;
        }
        function d46() {
            n.canvas = !!window.CanvasRenderingContext2D || n.cocoonJS;
            try {
                n.localStorage = !!localStorage.getItem;
            } catch (a74) {
                n.localStorage = !1;
            }
            n.file = !!(window.File && window.FileReader && window.FileList && window.Blob), n.fileSystem = !!window.requestFileSystem, n.webGL = function() {
                try {
                    var a = document.createElement("canvas");
                    return a.screencanvas = !1, !!window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl"));
                } catch (a) {
                    return !1;
                }
            }(), n.webGL = !!n.webGL, n.worker = !!window.Worker, n.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, n.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, n.getUserMedia = n.getUserMedia && !!navigator.getUserMedia && !!window.URL, n.firefox && n.firefoxVersion < 21 && (n.getUserMedia = !1), !n.iOS && (n.ie || n.firefox || n.chrome) && (n.canvasBitBltShift = !0), (n.safari || n.mobileSafari) && (n.canvasBitBltShift = !1);
        }
        function e30() {
            ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (n.touch = !0), (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (n.mspointer = !0), n.cocoonJS || ("onwheel" in window || n.ie && "WheelEvent" in window ? n.wheelEvent = "wheel" : "onmousewheel" in window ? n.wheelEvent = "mousewheel" : n.firefox && "MouseScrollEvent" in window && (n.wheelEvent = "DOMMouseScroll"));
        }
        function f() {
            for(var a = [
                "requestFullscreen",
                "requestFullScreen",
                "webkitRequestFullscreen",
                "webkitRequestFullScreen",
                "msRequestFullscreen",
                "msRequestFullScreen",
                "mozRequestFullScreen",
                "mozRequestFullscreen"
            ], b = document.createElement("div"), c = 0; c < a.length; c++)if (b[a[c]]) {
                n.fullscreen = !0, n.requestFullscreen = a[c];
                break;
            }
            var d = [
                "cancelFullScreen",
                "exitFullscreen",
                "webkitCancelFullScreen",
                "webkitExitFullscreen",
                "msCancelFullScreen",
                "msExitFullscreen",
                "mozCancelFullScreen",
                "mozExitFullscreen"
            ];
            if (n.fullscreen) {
                for(var c = 0; c < d.length; c++)if (document[d[c]]) {
                    n.cancelFullscreen = d[c];
                    break;
                }
            }
            window.Element && Element.ALLOW_KEYBOARD_INPUT && (n.fullscreenKeyboard = !0);
        }
        function g() {
            var a = navigator.userAgent;
            if (/Arora/.test(a) ? n.arora = !0 : /Edge\/\d+/.test(a) ? n.edge = !0 : /Chrome\/(\d+)/.test(a) && !n.windowsPhone ? (n.chrome = !0, n.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(a) ? n.epiphany = !0 : /Firefox\D+(\d+)/.test(a) ? (n.firefox = !0, n.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(a) && n.iOS ? n.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(a) ? (n.ie = !0, n.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(a) ? n.midori = !0 : /Opera/.test(a) ? n.opera = !0 : /Safari\/(\d+)/.test(a) && !n.windowsPhone ? (n.safari = !0, /Version\/(\d+)\./.test(a) && (n.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(a) && (n.ie = !0, n.trident = !0, n.tridentVersion = parseInt(RegExp.$1, 10), n.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(a) && (n.silk = !0), navigator.standalone && (n.webApp = !0), void 0 !== window.cordova && (n.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (n.node = !0), n.node && "object" == typeof process.versions && (n.nodeWebkit = !!process.versions["node-webkit"], n.electron = !!process.versions.electron), navigator.isCocoonJS && (n.cocoonJS = !0), n.cocoonJS) try {
                n.cocoonJSApp = "undefined" != typeof CocoonJS;
            } catch (a75) {
                n.cocoonJSApp = !1;
            }
            void 0 !== window.ejecta && (n.ejecta = !0), /Crosswalk/.test(a) && (n.crosswalk = !0);
        }
        function h() {
            var a = document.createElement("video");
            try {
                !!a.canPlayType && (a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (n.oggVideo = !0), a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.h264Video = !0, n.mp4Video = !0), a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (n.webmVideo = !0), a.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (n.vp9Video = !0), a.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.hlsVideo = !0));
            } catch (a76) {}
        }
        function i() {
            n.audioData = !!window.Audio, n.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
            var a = document.createElement("audio");
            try {
                if (!!a.canPlayType && (a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (n.ogg = !0), (a.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || a.canPlayType("audio/opus;").replace(/^no$/, "")) && (n.opus = !0), a.canPlayType("audio/mpeg;").replace(/^no$/, "") && (n.mp3 = !0), a.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (n.wav = !0), (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;").replace(/^no$/, "")) && (n.m4a = !0), a.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (n.webm = !0), "" !== a.canPlayType('audio/mp4;codecs="ec-3"'))) {
                    if (n.edge) n.dolby = !0;
                    else if (n.safari && n.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var b = parseInt(RegExp.$1, 10), c = parseInt(RegExp.$2, 10);
                        (10 === b && c >= 11 || b > 10) && (n.dolby = !0);
                    }
                }
            } catch (a77) {}
        }
        function j() {
            var a = new ArrayBuffer(4), b = new Uint8Array(a), c = new Uint32Array(a);
            return b[0] = 161, b[1] = 178, b[2] = 195, b[3] = 212, 3569595041 === c[0] || 2712847316 !== c[0] && null;
        }
        function k() {
            if (void 0 === Uint8ClampedArray) return !1;
            var a = c53.CanvasPool.create(this, 1, 1), b = a.getContext("2d");
            if (!b) return !1;
            var d = b.createImageData(1, 1);
            return c53.CanvasPool.remove(this), d.data instanceof Uint8ClampedArray;
        }
        function l() {
            n.pixelRatio = window.devicePixelRatio || 1, n.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), n.iPhone4 = 2 === n.pixelRatio && n.iPhone, n.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? n.typedArray = !0 : n.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (n.littleEndian = j(), n.LITTLE_ENDIAN = n.littleEndian), n.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== n.littleEndian && k(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (n.vibration = !0);
        }
        function m() {
            var a, b = document.createElement("p"), c = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(b, null);
            for(var d in c)void 0 !== b.style[d] && (b.style[d] = "translate3d(1px,1px,1px)", a = window.getComputedStyle(b).getPropertyValue(c[d]));
            document.body.removeChild(b), n.css3D = void 0 !== a && a.length > 0 && "none" !== a;
        }
        var n = this;
        a73(), g(), i(), h(), m(), l(), d46(), b64(), f(), e30();
    }, c53.Device.canPlayAudio = function(a) {
        return !("mp3" !== a || !this.mp3) || !("ogg" !== a || !this.ogg && !this.opus) || !("m4a" !== a || !this.m4a) || !("opus" !== a || !this.opus) || !("wav" !== a || !this.wav) || !("webm" !== a || !this.webm) || !("mp4" !== a || !this.dolby);
    }, c53.Device.canPlayVideo = function(a) {
        return !("webm" !== a || !this.webmVideo && !this.vp9Video) || !("mp4" !== a || !this.mp4Video && !this.h264Video) || !("ogg" !== a && "ogv" !== a || !this.oggVideo) || !("mpeg" !== a || !this.hlsVideo);
    }, c53.Device.isConsoleOpen = function() {
        return !(!window.console || !window.console.firebug) || !(!window.console || (console.profile(), console.profileEnd(), console.clear && console.clear(), !console.profiles)) && console.profiles.length > 0;
    }, c53.Device.isAndroidStockBrowser = function() {
        var a = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return a && a[1] < 537;
    }, c53.Canvas = {
        create: function(a, b, d, e, f) {
            b = b || 256, d = d || 256;
            var g = f ? document.createElement("canvas") : c53.CanvasPool.create(a, b, d);
            return "string" == typeof e && "" !== e && (g.id = e), g.width = b, g.height = d, g.style.display = "block", g;
        },
        setBackgroundColor: function(a, b) {
            return b = b || "rgb(0,0,0)", a.style.backgroundColor = b, a;
        },
        setTouchAction: function(a, b) {
            return b = b || "none", a.style.msTouchAction = b, a.style["ms-touch-action"] = b, a.style["touch-action"] = b, a;
        },
        setUserSelect: function(a, b) {
            return b = b || "none", a.style["-webkit-touch-callout"] = b, a.style["-webkit-user-select"] = b, a.style["-khtml-user-select"] = b, a.style["-moz-user-select"] = b, a.style["-ms-user-select"] = b, a.style["user-select"] = b, a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", a;
        },
        addToDOM: function(a, b, c) {
            var d;
            return void 0 === c && (c = !0), b && ("string" == typeof b ? d = document.getElementById(b) : "object" == typeof b && 1 === b.nodeType && (d = b)), d || (d = document.body), c && d.style && (d.style.overflow = "hidden"), d.appendChild(a), a;
        },
        removeFromDOM: function(a) {
            a.parentNode && a.parentNode.removeChild(a);
        },
        setTransform: function(a, b, c, d, e, f, g) {
            return a.setTransform(d, f, g, e, b, c), a;
        },
        setSmoothingEnabled: function(a, b) {
            var d = c53.Canvas.getSmoothingPrefix(a);
            return d && (a[d] = b), a;
        },
        getSmoothingPrefix: function(a) {
            var b = [
                "i",
                "webkitI",
                "msI",
                "mozI",
                "oI"
            ];
            for(var c in b){
                var d = b[c] + "mageSmoothingEnabled";
                if (d in a) return d;
            }
            return null;
        },
        getSmoothingEnabled: function(a) {
            var b = c53.Canvas.getSmoothingPrefix(a);
            if (b) return a[b];
        },
        setImageRenderingCrisp: function(a) {
            for(var b = [
                "optimizeSpeed",
                "crisp-edges",
                "-moz-crisp-edges",
                "-webkit-optimize-contrast",
                "optimize-contrast",
                "pixelated"
            ], c = 0; c < b.length; c++)a.style["image-rendering"] = b[c];
            return a.style.msInterpolationMode = "nearest-neighbor", a;
        },
        setImageRenderingBicubic: function(a) {
            return a.style["image-rendering"] = "auto", a.style.msInterpolationMode = "bicubic", a;
        }
    }, c53.RequestAnimationFrame = function(a, b) {
        void 0 === b && (b = !1), this.game = a, this.isRunning = !1, this.forceSetTimeOut = b;
        for(var c = [
            "ms",
            "moz",
            "webkit",
            "o"
        ], d = 0; d < c.length && !window.requestAnimationFrame; d++)window.requestAnimationFrame = window[c[d] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[c[d] + "CancelAnimationFrame"] || window[c[d] + "CancelRequestAnimationFrame"];
        this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null;
    }, c53.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = !0;
            var a = this;
            !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                return a.updateSetTimeout();
            }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(b) {
                return a.updateRAF(b);
            }, this._timeOutID = window.requestAnimationFrame(this._onLoop));
        },
        updateRAF: function(a) {
            this.isRunning && (this.game.update(Math.floor(a)), this._timeOutID = window.requestAnimationFrame(this._onLoop));
        },
        updateSetTimeout: function() {
            this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall));
        },
        stop: function() {
            this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1;
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut;
        },
        isRAF: function() {
            return !1 === this._isSetTimeOut;
        }
    }, c53.RequestAnimationFrame.prototype.constructor = c53.RequestAnimationFrame, c53.Math = {
        PI2: 2 * Math.PI,
        HALF_PI: 0.5 * Math.PI,
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        degToRad: function(a) {
            return a * c53.Math.DEG_TO_RAD;
        },
        radToDeg: function(a) {
            return a * c53.Math.RAD_TO_DEG;
        },
        getNextPowerOfTwo: function(a) {
            if (a > 0 && 0 == (a & a - 1)) return a;
            for(var b = 1; b < a;)b <<= 1;
            return b;
        },
        isPowerOfTwo: function(a, b) {
            return a > 0 && 0 == (a & a - 1) && b > 0 && 0 == (b & b - 1);
        },
        random: function(a, b) {
            if (void 0 === a && (a = 0), void 0 === b && (b = 1), a === b) return a;
            if (a > b) {
                var c = a;
                a = b, b = c;
            }
            return Math.random() * (b - a) + a;
        },
        between: function(a, b) {
            if (void 0 === a && (a = 0), void 0 === b && (b = 1), a === b) return a;
            if (a > b) {
                var c = a;
                a = b, b = c;
            }
            return a = Math.ceil(a), b = Math.floor(b), Math.floor(Math.random() * (b - a + 1)) + a;
        },
        fuzzyEqual: function(a, b, c) {
            return void 0 === c && (c = 0.0001), Math.abs(a - b) < c;
        },
        fuzzyLessThan: function(a, b, c) {
            return void 0 === c && (c = 0.0001), a < b + c;
        },
        fuzzyGreaterThan: function(a, b, c) {
            return void 0 === c && (c = 0.0001), a > b - c;
        },
        fuzzyCeil: function(a, b) {
            return void 0 === b && (b = 0.0001), Math.ceil(a - b);
        },
        fuzzyFloor: function(a, b) {
            return void 0 === b && (b = 0.0001), Math.floor(a + b);
        },
        average: function() {
            for(var a = 0, b = arguments.length, c = 0; c < b; c++)a += +arguments[c];
            return a / b;
        },
        shear: function(a) {
            return a % 1;
        },
        snapTo: function(a, b, c) {
            return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.round(a / b), c + a);
        },
        snapToFloor: function(a, b, c) {
            return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.floor(a / b), c + a);
        },
        snapToCeil: function(a, b, c) {
            return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.ceil(a / b), c + a);
        },
        roundTo: function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.round(a * d) / d;
        },
        floorTo: function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.floor(a * d) / d;
        },
        ceilTo: function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.ceil(a * d) / d;
        },
        rotateToAngle: function(a, b, d) {
            return void 0 === d && (d = 0.05), a === b ? a : (Math.abs(b - a) <= d || Math.abs(b - a) >= c53.Math.PI2 - d ? a = b : (Math.abs(b - a) > Math.PI && (b < a ? b += c53.Math.PI2 : b -= c53.Math.PI2), b > a ? a += d : b < a && (a -= d)), a);
        },
        getShortestAngle: function(a, b) {
            var c = b - a;
            return 0 === c ? 0 : c - 360 * Math.floor((c - -180) / 360);
        },
        angleBetween: function(a, b, c, d) {
            return Math.atan2(d - b, c - a);
        },
        angleBetweenY: function(a, b, c, d) {
            return Math.atan2(c - a, d - b);
        },
        angleBetweenPoints: function(a, b) {
            return Math.atan2(b.y - a.y, b.x - a.x);
        },
        angleBetweenPointsY: function(a, b) {
            return Math.atan2(b.x - a.x, b.y - a.y);
        },
        reverseAngle: function(a) {
            return this.normalizeAngle(a + Math.PI, !0);
        },
        normalizeAngle: function(a) {
            return a %= 2 * Math.PI, a >= 0 ? a : a + 2 * Math.PI;
        },
        maxAdd: function(a, b, c) {
            return Math.min(a + b, c);
        },
        minSub: function(a, b, c) {
            return Math.max(a - b, c);
        },
        wrap: function(a, b, c) {
            var d = c - b;
            if (d <= 0) return 0;
            var e = (a - b) % d;
            return e < 0 && (e += d), e + b;
        },
        wrapValue: function(a, b, c) {
            return a = Math.abs(a), b = Math.abs(b), c = Math.abs(c), (a + b) % c;
        },
        isOdd: function(a) {
            return !!(1 & a);
        },
        isEven: function(a) {
            return !(1 & a);
        },
        min: function() {
            if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0];
            else var a = arguments;
            for(var b = 1, c = 0, d = a.length; b < d; b++)a[b] < a[c] && (c = b);
            return a[c];
        },
        max: function() {
            if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0];
            else var a = arguments;
            for(var b = 1, c = 0, d = a.length; b < d; b++)a[b] > a[c] && (c = b);
            return a[c];
        },
        minProperty: function(a) {
            if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1];
            else var b = arguments.slice(1);
            for(var c = 1, d = 0, e = b.length; c < e; c++)b[c][a] < b[d][a] && (d = c);
            return b[d][a];
        },
        maxProperty: function(a) {
            if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1];
            else var b = arguments.slice(1);
            for(var c = 1, d = 0, e = b.length; c < e; c++)b[c][a] > b[d][a] && (d = c);
            return b[d][a];
        },
        wrapAngle: function(a, b) {
            return b ? this.wrap(a, -Math.PI, Math.PI) : this.wrap(a, -180, 180);
        },
        linearInterpolation: function(a, b) {
            var c = a.length - 1, d = c * b, e = Math.floor(d);
            return b < 0 ? this.linear(a[0], a[1], d) : b > 1 ? this.linear(a[c], a[c - 1], c - d) : this.linear(a[e], a[e + 1 > c ? c : e + 1], d - e);
        },
        bezierInterpolation: function(a, b) {
            for(var c = 0, d = a.length - 1, e = 0; e <= d; e++)c += Math.pow(1 - b, d - e) * Math.pow(b, e) * a[e] * this.bernstein(d, e);
            return c;
        },
        catmullRomInterpolation: function(a, b) {
            var c = a.length - 1, d = c * b, e = Math.floor(d);
            return a[0] === a[c] ? (b < 0 && (e = Math.floor(d = c * (1 + b))), this.catmullRom(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : b < 0 ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -d) - a[0]) : b > 1 ? a[c] - (this.catmullRom(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : this.catmullRom(a[e ? e - 1 : 0], a[e], a[c < e + 1 ? c : e + 1], a[c < e + 2 ? c : e + 2], d - e);
        },
        linear: function(a, b, c) {
            return (b - a) * c + a;
        },
        bernstein: function(a, b) {
            return this.factorial(a) / this.factorial(b) / this.factorial(a - b);
        },
        factorial: function(a) {
            if (0 === a) return 1;
            for(var b = a; --a;)b *= a;
            return b;
        },
        catmullRom: function(a, b, c, d, e) {
            var f = 0.5 * (c - a), g = 0.5 * (d - b), h = e * e;
            return (2 * b - 2 * c + f + g) * (e * h) + (-3 * b + 3 * c - 2 * f - g) * h + f * e + b;
        },
        difference: function(a, b) {
            return Math.abs(a - b);
        },
        roundAwayFromZero: function(a) {
            return a > 0 ? Math.ceil(a) : Math.floor(a);
        },
        sinCosGenerator: function(a, b, c, d) {
            void 0 === b && (b = 1), void 0 === c && (c = 1), void 0 === d && (d = 1);
            for(var e = b, f = c, g = d * Math.PI / a, h = [], i = [], j = 0; j < a; j++)f -= e * g, e += f * g, h[j] = f, i[j] = e;
            return {
                sin: i,
                cos: h,
                length: a
            };
        },
        hypot: function(a, b) {
            return Math.sqrt(a * a + b * b);
        },
        distance: function(a, b, c, d) {
            var e = a - c, f = b - d;
            return Math.sqrt(e * e + f * f);
        },
        distanceSq: function(a, b, c, d) {
            var e = a - c, f = b - d;
            return e * e + f * f;
        },
        distancePow: function(a, b, c, d, e) {
            return void 0 === e && (e = 2), Math.sqrt(Math.pow(c - a, e) + Math.pow(d - b, e));
        },
        clamp: function(a, b, c) {
            return a < b ? b : c < a ? c : a;
        },
        clampBottom: function(a, b) {
            return a < b ? b : a;
        },
        within: function(a, b, c) {
            return Math.abs(a - b) <= c;
        },
        mapLinear: function(a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b);
        },
        smoothstep: function(a, b, c) {
            return (a = Math.max(0, Math.min(1, (a - b) / (c - b)))) * a * (3 - 2 * a);
        },
        smootherstep: function(a, b, c) {
            return (a = Math.max(0, Math.min(1, (a - b) / (c - b)))) * a * a * (a * (6 * a - 15) + 10);
        },
        sign: function(a) {
            return a < 0 ? -1 : a > 0 ? 1 : 0;
        },
        percent: function(a, b, c) {
            return void 0 === c && (c = 0), a > b || c > b ? 1 : a < c || c > a ? 0 : (a - c) / b;
        }
    }, c53.RandomDataGenerator = function(a) {
        void 0 === a && (a = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof a ? this.state(a) : this.sow(a);
    }, c53.RandomDataGenerator.prototype = {
        rnd: function() {
            var a = 2091639 * this.s0 + 0.00000000023283064365386963 * this.c;
            return this.c = 0 | a, this.s0 = this.s1, this.s1 = this.s2, this.s2 = a - this.c, this.s2;
        },
        sow: function(a) {
            if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, a) for(var b = 0; b < a.length && null != a[b]; b++){
                var c = a[b];
                this.s0 -= this.hash(c), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(c), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(c), this.s2 += ~~(this.s2 < 0);
            }
        },
        hash: function(a) {
            var b, c, d;
            for(d = 4022871197, a = a.toString(), c = 0; c < a.length; c++)d += a.charCodeAt(c), b = 0.02519603282416938 * d, d = b >>> 0, b -= d, b *= d, d = b >>> 0, b -= d, d += 4294967296 * b;
            return 0.00000000023283064365386963 * (d >>> 0);
        },
        integer: function() {
            return 4294967296 * this.rnd.apply(this);
        },
        frac: function() {
            return this.rnd.apply(this) + 0.00000000000000011102230246251565 * (2097152 * this.rnd.apply(this) | 0);
        },
        real: function() {
            return this.integer() + this.frac();
        },
        integerInRange: function(a, b) {
            return Math.floor(this.realInRange(0, b - a + 1) + a);
        },
        between: function(a, b) {
            return this.integerInRange(a, b);
        },
        realInRange: function(a, b) {
            return this.frac() * (b - a) + a;
        },
        normal: function() {
            return 1 - 2 * this.frac();
        },
        uuid: function() {
            var a = "", b = "";
            for(b = a = ""; a++ < 36; b += ~a % 5 | 3 * a & 4 ? (15 ^ a ? 8 ^ this.frac() * (20 ^ a ? 16 : 4) : 4).toString(16) : "-");
            return b;
        },
        pick: function(a) {
            return a[this.integerInRange(0, a.length - 1)];
        },
        sign: function() {
            return this.pick([
                -1,
                1
            ]);
        },
        weightedPick: function(a) {
            return a[~~(Math.pow(this.frac(), 2) * (a.length - 1) + 0.5)];
        },
        timestamp: function(a, b) {
            return this.realInRange(a || 946684800000, b || 1577862000000);
        },
        angle: function() {
            return this.integerInRange(-180, 180);
        },
        state: function(a) {
            return "string" == typeof a && a.match(/^!rnd/) && (a = a.split(","), this.c = parseFloat(a[1]), this.s0 = parseFloat(a[2]), this.s1 = parseFloat(a[3]), this.s2 = parseFloat(a[4])), [
                "!rnd",
                this.c,
                this.s0,
                this.s1,
                this.s2
            ].join(",");
        }
    }, c53.RandomDataGenerator.prototype.constructor = c53.RandomDataGenerator, c53.QuadTree = function(a, b, c, d, e, f, g) {
        this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(a, b, c, d, e, f, g);
    }, c53.QuadTree.prototype = {
        reset: function(a, b, c, d, e, f, g) {
            this.maxObjects = e || 10, this.maxLevels = f || 4, this.level = g || 0, this.bounds = {
                x: Math.round(a),
                y: Math.round(b),
                width: c,
                height: d,
                subWidth: Math.floor(c / 2),
                subHeight: Math.floor(d / 2),
                right: Math.round(a) + Math.floor(c / 2),
                bottom: Math.round(b) + Math.floor(d / 2)
            }, this.objects.length = 0, this.nodes.length = 0;
        },
        populate: function(a) {
            a.forEach(this.populateHandler, this, !0);
        },
        populateHandler: function(a) {
            a.body && a.exists && this.insert(a.body);
        },
        split: function() {
            this.nodes[0] = new c53.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new c53.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new c53.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new c53.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
        },
        insert: function(a) {
            var b, c = 0;
            if (null != this.nodes[0] && -1 !== (b = this.getIndex(a))) return void this.nodes[b].insert(a);
            if (this.objects.push(a), this.objects.length > this.maxObjects && this.level < this.maxLevels) for(null == this.nodes[0] && this.split(); c < this.objects.length;)b = this.getIndex(this.objects[c]), -1 !== b ? this.nodes[b].insert(this.objects.splice(c, 1)[0]) : c++;
        },
        getIndex: function(a) {
            var b = -1;
            return a.x < this.bounds.right && a.right < this.bounds.right ? a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 1 : a.y > this.bounds.bottom && (b = 2) : a.x > this.bounds.right && (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 0 : a.y > this.bounds.bottom && (b = 3)), b;
        },
        retrieve: function(a) {
            if (a instanceof c53.Rectangle) var b = this.objects, d = this.getIndex(a);
            else {
                if (!a.body) return this._empty;
                var b = this.objects, d = this.getIndex(a.body);
            }
            return this.nodes[0] && (-1 !== d ? b = b.concat(this.nodes[d].retrieve(a)) : (b = b.concat(this.nodes[0].retrieve(a)), b = b.concat(this.nodes[1].retrieve(a)), b = b.concat(this.nodes[2].retrieve(a)), b = b.concat(this.nodes[3].retrieve(a)))), b;
        },
        clear: function() {
            this.objects.length = 0;
            for(var a = this.nodes.length; a--;)this.nodes[a].clear(), this.nodes.splice(a, 1);
            this.nodes.length = 0;
        }
    }, c53.QuadTree.prototype.constructor = c53.QuadTree, c53.Net = function(a) {
        this.game = a;
    }, c53.Net.prototype = {
        getHostName: function() {
            return window.location && window.location.hostname ? window.location.hostname : null;
        },
        checkDomainName: function(a) {
            return -1 !== window.location.hostname.indexOf(a);
        },
        updateQueryString: function(a, b, c, d) {
            void 0 === c && (c = !1), void 0 !== d && "" !== d || (d = window.location.href);
            var e = "", f = new RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)", "gi");
            if (f.test(d)) e = void 0 !== b && null !== b ? d.replace(f, "$1" + a + "=" + b + "$2$3") : d.replace(f, "$1$3").replace(/(&|\?)$/, "");
            else if (void 0 !== b && null !== b) {
                var g = -1 !== d.indexOf("?") ? "&" : "?", h = d.split("#");
                d = h[0] + g + a + "=" + b, h[1] && (d += "#" + h[1]), e = d;
            } else e = d;
            if (!c) return e;
            window.location.href = e;
        },
        getQueryString: function(a) {
            void 0 === a && (a = "");
            var b = {}, c = location.search.substring(1).split("&");
            for(var d in c){
                var e = c[d].split("=");
                if (e.length > 1) {
                    if (a && a === this.decodeURI(e[0])) return this.decodeURI(e[1]);
                    b[this.decodeURI(e[0])] = this.decodeURI(e[1]);
                }
            }
            return b;
        },
        decodeURI: function(a) {
            return decodeURIComponent(a.replace(/\+/g, " "));
        }
    }, c53.Net.prototype.constructor = c53.Net, c53.TweenManager = function(a) {
        this.game = a, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
            Power0: c53.Easing.Power0,
            Power1: c53.Easing.Power1,
            Power2: c53.Easing.Power2,
            Power3: c53.Easing.Power3,
            Power4: c53.Easing.Power4,
            Linear: c53.Easing.Linear.None,
            Quad: c53.Easing.Quadratic.Out,
            Cubic: c53.Easing.Cubic.Out,
            Quart: c53.Easing.Quartic.Out,
            Quint: c53.Easing.Quintic.Out,
            Sine: c53.Easing.Sinusoidal.Out,
            Expo: c53.Easing.Exponential.Out,
            Circ: c53.Easing.Circular.Out,
            Elastic: c53.Easing.Elastic.Out,
            Back: c53.Easing.Back.Out,
            Bounce: c53.Easing.Bounce.Out,
            "Quad.easeIn": c53.Easing.Quadratic.In,
            "Cubic.easeIn": c53.Easing.Cubic.In,
            "Quart.easeIn": c53.Easing.Quartic.In,
            "Quint.easeIn": c53.Easing.Quintic.In,
            "Sine.easeIn": c53.Easing.Sinusoidal.In,
            "Expo.easeIn": c53.Easing.Exponential.In,
            "Circ.easeIn": c53.Easing.Circular.In,
            "Elastic.easeIn": c53.Easing.Elastic.In,
            "Back.easeIn": c53.Easing.Back.In,
            "Bounce.easeIn": c53.Easing.Bounce.In,
            "Quad.easeOut": c53.Easing.Quadratic.Out,
            "Cubic.easeOut": c53.Easing.Cubic.Out,
            "Quart.easeOut": c53.Easing.Quartic.Out,
            "Quint.easeOut": c53.Easing.Quintic.Out,
            "Sine.easeOut": c53.Easing.Sinusoidal.Out,
            "Expo.easeOut": c53.Easing.Exponential.Out,
            "Circ.easeOut": c53.Easing.Circular.Out,
            "Elastic.easeOut": c53.Easing.Elastic.Out,
            "Back.easeOut": c53.Easing.Back.Out,
            "Bounce.easeOut": c53.Easing.Bounce.Out,
            "Quad.easeInOut": c53.Easing.Quadratic.InOut,
            "Cubic.easeInOut": c53.Easing.Cubic.InOut,
            "Quart.easeInOut": c53.Easing.Quartic.InOut,
            "Quint.easeInOut": c53.Easing.Quintic.InOut,
            "Sine.easeInOut": c53.Easing.Sinusoidal.InOut,
            "Expo.easeInOut": c53.Easing.Exponential.InOut,
            "Circ.easeInOut": c53.Easing.Circular.InOut,
            "Elastic.easeInOut": c53.Easing.Elastic.InOut,
            "Back.easeInOut": c53.Easing.Back.InOut,
            "Bounce.easeInOut": c53.Easing.Bounce.InOut
        }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this);
    }, c53.TweenManager.prototype = {
        getAll: function() {
            return this._tweens;
        },
        removeAll: function() {
            for(var a = 0; a < this._tweens.length; a++)this._tweens[a].pendingDelete = !0;
            this._add = [];
        },
        removeFrom: function(a, b) {
            void 0 === b && (b = !0);
            var d, e;
            if (Array.isArray(a)) for(d = 0, e = a.length; d < e; d++)this.removeFrom(a[d]);
            else if (a.type === c53.GROUP && b) for(var d = 0, e = a.children.length; d < e; d++)this.removeFrom(a.children[d]);
            else {
                for(d = 0, e = this._tweens.length; d < e; d++)a === this._tweens[d].target && this.remove(this._tweens[d]);
                for(d = 0, e = this._add.length; d < e; d++)a === this._add[d].target && this.remove(this._add[d]);
            }
        },
        add: function(a) {
            a._manager = this, this._add.push(a);
        },
        create: function(a) {
            return new c53.Tween(a, this.game, this);
        },
        remove: function(a) {
            var b = this._tweens.indexOf(a);
            -1 !== b ? this._tweens[b].pendingDelete = !0 : -1 !== (b = this._add.indexOf(a)) && (this._add[b].pendingDelete = !0);
        },
        update: function() {
            var a = this._add.length, b = this._tweens.length;
            if (0 === b && 0 === a) return !1;
            for(var c = 0; c < b;)this._tweens[c].update(this.game.time.time) ? c++ : (this._tweens.splice(c, 1), b--);
            return a > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0;
        },
        isTweening: function(a) {
            return this._tweens.some(function(b) {
                return b.target === a;
            });
        },
        _pauseAll: function() {
            for(var a = this._tweens.length - 1; a >= 0; a--)this._tweens[a]._pause();
        },
        _resumeAll: function() {
            for(var a = this._tweens.length - 1; a >= 0; a--)this._tweens[a]._resume();
        },
        pauseAll: function() {
            for(var a = this._tweens.length - 1; a >= 0; a--)this._tweens[a].pause();
        },
        resumeAll: function() {
            for(var a = this._tweens.length - 1; a >= 0; a--)this._tweens[a].resume(!0);
        }
    }, c53.TweenManager.prototype.constructor = c53.TweenManager, c53.Tween = function(a, b, d) {
        this.game = b, this.target = a, this.manager = d, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new c53.Signal, this.onLoop = new c53.Signal, this.onRepeat = new c53.Signal, this.onChildComplete = new c53.Signal, this.onComplete = new c53.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = d.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1;
    }, c53.Tween.prototype = {
        to: function(a, b, d, e, f, g, h) {
            return (void 0 === b || b <= 0) && (b = 1000), void 0 !== d && null !== d || (d = c53.Easing.Default), void 0 === e && (e = !1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = !1), "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]), this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new c53.TweenData(this).to(a, b, d, f, g, h)), e && this.start(), this);
        },
        from: function(a, b, d, e, f, g, h) {
            return void 0 === b && (b = 1000), void 0 !== d && null !== d || (d = c53.Easing.Default), void 0 === e && (e = !1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = !1), "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]), this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new c53.TweenData(this).from(a, b, d, f, g, h)), e && this.start(), this);
        },
        start: function(a) {
            if (void 0 === a && (a = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
            for(var b = 0; b < this.timeline.length; b++)for(var c in this.timeline[b].vEnd)this.properties[c] = this.target[c] || 0, Array.isArray(this.properties[c]) || (this.properties[c] *= 1);
            for(var b = 0; b < this.timeline.length; b++)this.timeline[b].loadValues();
            return this.manager.add(this), this.isRunning = !0, (a < 0 || a > this.timeline.length - 1) && (a = 0), this.current = a, this.timeline[this.current].start(), this;
        },
        stop: function(a) {
            return void 0 === a && (a = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, a && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this;
        },
        updateTweenData: function(a, b, c) {
            if (0 === this.timeline.length) return this;
            if (void 0 === c && (c = 0), -1 === c) for(var d = 0; d < this.timeline.length; d++)this.timeline[d][a] = b;
            else this.timeline[c][a] = b;
            return this;
        },
        delay: function(a, b) {
            return this.updateTweenData("delay", a, b);
        },
        repeat: function(a, b, c) {
            return void 0 === b && (b = 0), this.updateTweenData("repeatCounter", a, c), this.updateTweenData("repeatDelay", b, c);
        },
        repeatDelay: function(a, b) {
            return this.updateTweenData("repeatDelay", a, b);
        },
        yoyo: function(a, b, c) {
            return void 0 === b && (b = 0), this.updateTweenData("yoyo", a, c), this.updateTweenData("yoyoDelay", b, c);
        },
        yoyoDelay: function(a, b) {
            return this.updateTweenData("yoyoDelay", a, b);
        },
        easing: function(a, b) {
            return "string" == typeof a && this.manager.easeMap[a] && (a = this.manager.easeMap[a]), this.updateTweenData("easingFunction", a, b);
        },
        interpolation: function(a, b, d) {
            return void 0 === b && (b = c53.Math), this.updateTweenData("interpolationFunction", a, d), this.updateTweenData("interpolationContext", b, d);
        },
        repeatAll: function(a) {
            return void 0 === a && (a = 0), this.repeatCounter = a, this;
        },
        chain: function() {
            for(var a = arguments.length; a--;)a > 0 ? arguments[a - 1].chainedTween = arguments[a] : this.chainedTween = arguments[a];
            return this;
        },
        loop: function(a) {
            return void 0 === a && (a = !0), this.repeatCounter = a ? -1 : 0, this;
        },
        onUpdateCallback: function(a, b) {
            return this._onUpdateCallback = a, this._onUpdateCallbackContext = b, this;
        },
        pause: function() {
            this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time;
        },
        _pause: function() {
            this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time);
        },
        resume: function() {
            if (this.isPaused) {
                this.isPaused = !1, this._codePaused = !1;
                for(var a = 0; a < this.timeline.length; a++)this.timeline[a].isRunning || (this.timeline[a].startTime += this.game.time.time - this._pausedTime);
            }
        },
        _resume: function() {
            this._codePaused || this.resume();
        },
        update: function(a) {
            if (this.pendingDelete || !this.target) return !1;
            if (this.isPaused) return !0;
            var b = this.timeline[this.current].update(a);
            if (b === c53.TweenData.PENDING) return !0;
            if (b === c53.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
            if (b === c53.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
            if (b === c53.TweenData.COMPLETE) {
                var d = !1;
                return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, d = !0) : ++this.current === this.timeline.length && (this.current = 0, d = !0), d ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0);
            }
        },
        generateData: function(a, b) {
            if (null === this.game || null === this.target) return null;
            void 0 === a && (a = 60), void 0 === b && (b = []);
            for(var c = 0; c < this.timeline.length; c++)for(var d in this.timeline[c].vEnd)this.properties[d] = this.target[d] || 0, Array.isArray(this.properties[d]) || (this.properties[d] *= 1);
            for(var c = 0; c < this.timeline.length; c++)this.timeline[c].loadValues();
            for(var c = 0; c < this.timeline.length; c++)b = b.concat(this.timeline[c].generateData(a));
            return b;
        }
    }, Object.defineProperty(c53.Tween.prototype, "totalDuration", {
        get: function() {
            for(var a = 0, b = 0; b < this.timeline.length; b++)a += this.timeline[b].duration;
            return a;
        }
    }), c53.Tween.prototype.constructor = c53.Tween, c53.TweenData = function(a) {
        this.parent = a, this.game = a.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1000, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = c53.Easing.Default, this.interpolationFunction = c53.Math.linearInterpolation, this.interpolationContext = c53.Math, this.isRunning = !1, this.isFrom = !1;
    }, c53.TweenData.PENDING = 0, c53.TweenData.RUNNING = 1, c53.TweenData.LOOPED = 2, c53.TweenData.COMPLETE = 3, c53.TweenData.prototype = {
        to: function(a, b, c, d, e, f) {
            return this.vEnd = a, this.duration = b, this.easingFunction = c, this.delay = d, this.repeatTotal = e, this.yoyo = f, this.isFrom = !1, this;
        },
        from: function(a, b, c, d, e, f) {
            return this.vEnd = a, this.duration = b, this.easingFunction = c, this.delay = d, this.repeatTotal = e, this.yoyo = f, this.isFrom = !0, this;
        },
        start: function() {
            if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom) for(var a in this.vStartCache)this.vStart[a] = this.vEndCache[a], this.vEnd[a] = this.vStartCache[a], this.parent.target[a] = this.vStart[a];
            return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this;
        },
        loadValues: function() {
            for(var a in this.parent.properties){
                if (this.vStart[a] = this.parent.properties[a], Array.isArray(this.vEnd[a])) {
                    if (0 === this.vEnd[a].length) continue;
                    0 === this.percent && (this.vEnd[a] = [
                        this.vStart[a]
                    ].concat(this.vEnd[a]));
                }
                void 0 !== this.vEnd[a] ? ("string" == typeof this.vEnd[a] && (this.vEnd[a] = this.vStart[a] + parseFloat(this.vEnd[a], 10)), this.parent.properties[a] = this.vEnd[a]) : this.vEnd[a] = this.vStart[a], this.vStartCache[a] = this.vStart[a], this.vEndCache[a] = this.vEnd[a];
            }
            return this;
        },
        update: function(a) {
            if (this.isRunning) {
                if (a < this.startTime) return c53.TweenData.RUNNING;
            } else {
                if (!(a >= this.startTime)) return c53.TweenData.PENDING;
                this.isRunning = !0;
            }
            var b = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
            this.parent.reverse ? (this.dt -= b * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += b * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
            for(var d in this.vEnd){
                var e = this.vStart[d], f = this.vEnd[d];
                Array.isArray(f) ? this.parent.target[d] = this.interpolationFunction.call(this.interpolationContext, f, this.value) : this.parent.target[d] = e + (f - e) * this.value;
            }
            return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : c53.TweenData.RUNNING;
        },
        generateData: function(a) {
            this.parent.reverse ? this.dt = this.duration : this.dt = 0;
            var b = [], c = !1, d = 1 / a * 1000;
            do {
                this.parent.reverse ? (this.dt -= d, this.dt = Math.max(this.dt, 0)) : (this.dt += d, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                var e = {};
                for(var f in this.vEnd){
                    var g = this.vStart[f], h = this.vEnd[f];
                    Array.isArray(h) ? e[f] = this.interpolationFunction(h, this.value) : e[f] = g + (h - g) * this.value;
                }
                b.push(e), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (c = !0);
            }while (!c)
            if (this.yoyo) {
                var i = b.slice();
                i.reverse(), b = b.concat(i);
            }
            return b;
        },
        repeat: function() {
            if (this.yoyo) {
                if (this.inReverse && 0 === this.repeatCounter) {
                    for(var a in this.vStartCache)this.vStart[a] = this.vStartCache[a], this.vEnd[a] = this.vEndCache[a];
                    return this.inReverse = !1, c53.TweenData.COMPLETE;
                }
                this.inReverse = !this.inReverse;
            } else if (0 === this.repeatCounter) return c53.TweenData.COMPLETE;
            if (this.inReverse) for(var a in this.vStartCache)this.vStart[a] = this.vEndCache[a], this.vEnd[a] = this.vStartCache[a];
            else {
                for(var a in this.vStartCache)this.vStart[a] = this.vStartCache[a], this.vEnd[a] = this.vEndCache[a];
                this.repeatCounter > 0 && this.repeatCounter--;
            }
            return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, c53.TweenData.LOOPED;
        }
    }, c53.TweenData.prototype.constructor = c53.TweenData, c53.Easing = {
        Linear: {
            None: function(a) {
                return a;
            }
        },
        Quadratic: {
            In: function(a) {
                return a * a;
            },
            Out: function(a) {
                return a * (2 - a);
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1);
            }
        },
        Cubic: {
            In: function(a) {
                return a * a * a;
            },
            Out: function(a) {
                return --a * a * a + 1;
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2);
            }
        },
        Quartic: {
            In: function(a) {
                return a * a * a * a;
            },
            Out: function(a) {
                return 1 - --a * a * a * a;
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2);
            }
        },
        Quintic: {
            In: function(a) {
                return a * a * a * a * a;
            },
            Out: function(a) {
                return --a * a * a * a * a + 1;
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? 0.5 * a * a * a * a * a : 0.5 * ((a -= 2) * a * a * a * a + 2);
            }
        },
        Sinusoidal: {
            In: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : 1 - Math.cos(a * Math.PI / 2);
            },
            Out: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : Math.sin(a * Math.PI / 2);
            },
            InOut: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : 0.5 * (1 - Math.cos(Math.PI * a));
            }
        },
        Exponential: {
            In: function(a) {
                return 0 === a ? 0 : Math.pow(1024, a - 1);
            },
            Out: function(a) {
                return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
            },
            InOut: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : (a *= 2) < 1 ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (2 - Math.pow(2, -10 * (a - 1)));
            }
        },
        Circular: {
            In: function(a) {
                return 1 - Math.sqrt(1 - a * a);
            },
            Out: function(a) {
                return Math.sqrt(1 - --a * a);
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
            }
        },
        Elastic: {
            In: function(a) {
                var b, c = 0.1, d = 0.4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), -c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d));
            },
            Out: function(a) {
                var b, c = 0.1, d = 0.4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), c * Math.pow(2, -10 * a) * Math.sin((a - b) * (2 * Math.PI) / d) + 1);
            },
            InOut: function(a) {
                var b, c = 0.1, d = 0.4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), (a *= 2) < 1 ? c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d) * -0.5 : c * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d) * 0.5 + 1);
            }
        },
        Back: {
            In: function(a) {
                var b = 1.70158;
                return a * a * ((b + 1) * a - b);
            },
            Out: function(a) {
                var b = 1.70158;
                return --a * a * ((b + 1) * a + b) + 1;
            },
            InOut: function(a) {
                var b = 2.5949095;
                return (a *= 2) < 1 ? a * a * ((b + 1) * a - b) * 0.5 : 0.5 * ((a -= 2) * a * ((b + 1) * a + b) + 2);
            }
        },
        Bounce: {
            In: function(a) {
                return 1 - c53.Easing.Bounce.Out(1 - a);
            },
            Out: function(a) {
                return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
            },
            InOut: function(a) {
                return a < 0.5 ? 0.5 * c53.Easing.Bounce.In(2 * a) : 0.5 * c53.Easing.Bounce.Out(2 * a - 1) + 0.5;
            }
        }
    }, c53.Easing.Default = c53.Easing.Linear.None, c53.Easing.Power0 = c53.Easing.Linear.None, c53.Easing.Power1 = c53.Easing.Quadratic.Out, c53.Easing.Power2 = c53.Easing.Cubic.Out, c53.Easing.Power3 = c53.Easing.Quartic.Out, c53.Easing.Power4 = c53.Easing.Quintic.Out, c53.Time = function(a) {
        this.game = a, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1000, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1000, this.fpsMax = 0, this.msMin = 1000, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new c53.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = [];
    }, c53.Time.prototype = {
        boot: function() {
            this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time;
        },
        add: function(a) {
            return this._timers.push(a), a;
        },
        create: function(a) {
            void 0 === a && (a = !0);
            var b = new c53.Timer(this.game, a);
            return this._timers.push(b), b;
        },
        removeAll: function() {
            for(var a = 0; a < this._timers.length; a++)this._timers[a].destroy();
            this._timers = [], this.events.removeAll();
        },
        refresh: function() {
            var a = this.time;
            this.time = Date.now(), this.elapsedMS = this.time - a;
        },
        update: function(a) {
            var b = this.time;
            this.time = Date.now(), this.elapsedMS = this.time - b, this.prevTime = this.now, this.now = a, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1000 / this._desiredFps - (this.timeExpected - a))), this.timeExpected = a + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers());
        },
        updateTimers: function() {
            for(var a = 0, b = this._timers.length; a < b;)this._timers[a].update(this.time) ? a++ : (this._timers.splice(a, 1), b--);
        },
        updateAdvancedTiming: function() {
            this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1000 && (this.fps = Math.round(1000 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0);
        },
        gamePaused: function() {
            this._pauseStarted = Date.now(), this.events.pause();
            for(var a = this._timers.length; a--;)this._timers[a]._pause();
        },
        gameResumed: function() {
            this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
            for(var a = this._timers.length; a--;)this._timers[a]._resume();
        },
        totalElapsedSeconds: function() {
            return 0.001 * (this.time - this._started);
        },
        elapsedSince: function(a) {
            return this.time - a;
        },
        elapsedSecondsSince: function(a) {
            return 0.001 * (this.time - a);
        },
        reset: function() {
            this._started = this.time, this.removeAll();
        }
    }, Object.defineProperty(c53.Time.prototype, "desiredFps", {
        get: function() {
            return this._desiredFps;
        },
        set: function(a) {
            this._desiredFps = a, this.physicsElapsed = 1 / a, this.physicsElapsedMS = 1000 * this.physicsElapsed, this.desiredFpsMult = 1 / a;
        }
    }), c53.Time.prototype.constructor = c53.Time, c53.Timer = function(a, b) {
        void 0 === b && (b = !0), this.game = a, this.running = !1, this.autoDestroy = b, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new c53.Signal, this.nextTick = 0, this.timeCap = 1000, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0;
    }, c53.Timer.MINUTE = 60000, c53.Timer.SECOND = 1000, c53.Timer.HALF = 500, c53.Timer.QUARTER = 250, c53.Timer.prototype = {
        create: function(a, b, d, e, f, g) {
            a = Math.round(a);
            var h = a;
            0 === this._now ? h += this.game.time.time : h += this._now;
            var i = new c53.TimerEvent(this, a, h, d, b, e, f, g);
            return this.events.push(i), this.order(), this.expired = !1, i;
        },
        add: function(a, b, c) {
            return this.create(a, !1, 0, b, c, Array.prototype.slice.call(arguments, 3));
        },
        repeat: function(a, b, c, d) {
            return this.create(a, !1, b, c, d, Array.prototype.slice.call(arguments, 4));
        },
        loop: function(a, b, c) {
            return this.create(a, !0, 0, b, c, Array.prototype.slice.call(arguments, 3));
        },
        start: function(a) {
            if (!this.running) {
                this._started = this.game.time.time + (a || 0), this.running = !0;
                for(var b = 0; b < this.events.length; b++)this.events[b].tick = this.events[b].delay + this._started;
            }
        },
        stop: function(a) {
            this.running = !1, void 0 === a && (a = !0), a && (this.events.length = 0);
        },
        remove: function(a) {
            for(var b = 0; b < this.events.length; b++)if (this.events[b] === a) return this.events[b].pendingDelete = !0, !0;
            return !1;
        },
        order: function() {
            this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick);
        },
        sortHandler: function(a, b) {
            return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0;
        },
        clearPendingEvents: function() {
            for(this._i = this.events.length; this._i--;)this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
            this._len = this.events.length, this._i = 0;
        },
        update: function(a) {
            if (this.paused) return !0;
            if (this.elapsed = a - this._now, this._now = a, this.elapsed > this.timeCap && this.adjustEvents(a - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                for(; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;)this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this));
            }
            return !this.expired || !this.autoDestroy;
        },
        pause: function() {
            this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0));
        },
        _pause: function() {
            !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0);
        },
        adjustEvents: function(a) {
            for(var b = 0; b < this.events.length; b++)if (!this.events[b].pendingDelete) {
                var c = this.events[b].tick - a;
                c < 0 && (c = 0), this.events[b].tick = this._now + c;
            }
            var d = this.nextTick - a;
            this.nextTick = d < 0 ? this._now : this._now + d;
        },
        resume: function() {
            if (this.paused) {
                var a = this.game.time.time;
                this._pauseTotal += a - this._now, this._now = a, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1;
            }
        },
        _resume: function() {
            this._codePaused || this.resume();
        },
        removeAll: function() {
            this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0;
        },
        destroy: function() {
            this.onComplete.removeAll(), this.running = !1, this.expired = !0, this.events = [], this._len = 0, this._i = 0;
        }
    }, Object.defineProperty(c53.Timer.prototype, "next", {
        get: function() {
            return this.nextTick;
        }
    }), Object.defineProperty(c53.Timer.prototype, "duration", {
        get: function() {
            return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0;
        }
    }), Object.defineProperty(c53.Timer.prototype, "length", {
        get: function() {
            return this.events.length;
        }
    }), Object.defineProperty(c53.Timer.prototype, "ms", {
        get: function() {
            return this.running ? this._now - this._started - this._pauseTotal : 0;
        }
    }), Object.defineProperty(c53.Timer.prototype, "seconds", {
        get: function() {
            return this.running ? 0.001 * this.ms : 0;
        }
    }), c53.Timer.prototype.constructor = c53.Timer, c53.TimerEvent = function(a, b, c, d, e, f, g, h) {
        this.timer = a, this.delay = b, this.tick = c, this.repeatCount = d - 1, this.loop = e, this.callback = f, this.callbackContext = g, this.args = h, this.pendingDelete = !1;
    }, c53.TimerEvent.prototype.constructor = c53.TimerEvent, c53.AnimationManager = function(a) {
        this.sprite = a, this.game = a.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = [];
    }, c53.AnimationManager.prototype = {
        loadFrameData: function(a, b) {
            if (void 0 === a) return !1;
            if (this.isLoaded) for(var c in this._anims)this._anims[c].updateFrameData(a);
            return this._frameData = a, void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b, this.isLoaded = !0, !0;
        },
        copyFrameData: function(a, b) {
            if (this._frameData = a.clone(), this.isLoaded) for(var c in this._anims)this._anims[c].updateFrameData(this._frameData);
            return void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b, this.isLoaded = !0, !0;
        },
        add: function(a, b, d, e, f) {
            return b = b || [], d = d || 60, void 0 === e && (e = !1), void 0 === f && (f = !(!b || "number" != typeof b[0])), this._outputFrames = [], this._frameData.getFrameIndexes(b, f, this._outputFrames), this._anims[a] = new c53.Animation(this.game, this.sprite, a, this._frameData, this._outputFrames, d, e), this.currentAnim = this._anims[a], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[a];
        },
        validateFrames: function(a, b) {
            void 0 === b && (b = !0);
            for(var c = 0; c < a.length; c++)if (!0 === b) {
                if (a[c] > this._frameData.total) return !1;
            } else if (!1 === this._frameData.checkFrameName(a[c])) return !1;
            return !0;
        },
        play: function(a, b, c, d) {
            if (this._anims[a]) return this.currentAnim === this._anims[a] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(b, c, d)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[a], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(b, c, d));
        },
        stop: function(a, b) {
            void 0 === b && (b = !1), !this.currentAnim || "string" == typeof a && a !== this.currentAnim.name || this.currentAnim.stop(b);
        },
        update: function() {
            return !(this.updateIfVisible && !this.sprite.visible) && !(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0);
        },
        next: function(a) {
            this.currentAnim && (this.currentAnim.next(a), this.currentFrame = this.currentAnim.currentFrame);
        },
        previous: function(a) {
            this.currentAnim && (this.currentAnim.previous(a), this.currentFrame = this.currentAnim.currentFrame);
        },
        getAnimation: function(a) {
            return "string" == typeof a && this._anims[a] ? this._anims[a] : null;
        },
        refreshFrame: function() {},
        destroy: function() {
            var a = null;
            for(var a in this._anims)this._anims.hasOwnProperty(a) && this._anims[a].destroy();
            this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null;
        }
    }, c53.AnimationManager.prototype.constructor = c53.AnimationManager, Object.defineProperty(c53.AnimationManager.prototype, "frameData", {
        get: function() {
            return this._frameData;
        }
    }), Object.defineProperty(c53.AnimationManager.prototype, "frameTotal", {
        get: function() {
            return this._frameData.total;
        }
    }), Object.defineProperty(c53.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused;
        },
        set: function(a) {
            this.currentAnim.paused = a;
        }
    }), Object.defineProperty(c53.AnimationManager.prototype, "name", {
        get: function() {
            if (this.currentAnim) return this.currentAnim.name;
        }
    }), Object.defineProperty(c53.AnimationManager.prototype, "frame", {
        get: function() {
            if (this.currentFrame) return this.currentFrame.index;
        },
        set: function(a) {
            var b;
            "number" == typeof a && this._frameData && (b = this._frameData.getFrame(a)) && (this.currentFrame = b, this.sprite.setFrame(this.currentFrame));
        }
    }), Object.defineProperty(c53.AnimationManager.prototype, "frameName", {
        get: function() {
            if (this.currentFrame) return this.currentFrame.name;
        },
        set: function(a) {
            var b;
            "string" == typeof a && this._frameData && (b = this._frameData.getFrameByName(a)) ? (this.currentFrame = b, this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)) : console.warn("Cannot set frameName: " + a);
        }
    }), c53.Animation = function(a, b, d, e, f, g, h) {
        void 0 === h && (h = !1), this.game = a, this._parent = b, this._frameData = e, this.name = d, this._frames = [], this._frames = this._frames.concat(f), this.delay = 1000 / g, this.loop = h, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new c53.Signal, this.onUpdate = null, this.onComplete = new c53.Signal, this.onLoop = new c53.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this);
    }, c53.Animation.prototype = {
        play: function(a, b, c) {
            return "number" == typeof a && (this.delay = 1000 / a), "boolean" == typeof b && (this.loop = b), void 0 !== c && (this.killOnComplete = c), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this;
        },
        restart: function() {
            this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this);
        },
        reverse: function() {
            return this.reversed = !this.reversed, this;
        },
        reverseOnce: function() {
            return this.onComplete.addOnce(this.reverse, this), this.reverse();
        },
        setFrame: function(a, b) {
            var c;
            if (void 0 === b && (b = !1), "string" == typeof a) for(var d = 0; d < this._frames.length; d++)this._frameData.getFrame(this._frames[d]).name === a && (c = d);
            else if ("number" == typeof a) {
                if (b) c = a;
                else for(var d = 0; d < this._frames.length; d++)this._frames[d] === a && (c = d);
            }
            if (c) {
                var e = this.isReversed ? -1 : 1;
                this._frameIndex = c - e, this._timeNextFrame = this.game.time.time, this.update();
            }
        },
        stop: function(a, b) {
            void 0 === a && (a = !1), void 0 === b && (b = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, a && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), b && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this));
        },
        onPause: function() {
            this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time);
        },
        onResume: function() {
            this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff);
        },
        update: function() {
            return !this.isPaused && !!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0));
        },
        updateCurrentFrame: function(a, b) {
            if (void 0 === b && (b = !1), !this._frameData) return !1;
            var c = this.currentFrame.index;
            return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (b || !b && c !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !a || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData);
        },
        next: function(a) {
            void 0 === a && (a = 1);
            var b = this._frameIndex + a;
            b >= this._frames.length && (this.loop ? b %= this._frames.length : b = this._frames.length - 1), b !== this._frameIndex && (this._frameIndex = b, this.updateCurrentFrame(!0));
        },
        previous: function(a) {
            void 0 === a && (a = 1);
            var b = this._frameIndex - a;
            b < 0 && (this.loop ? b = this._frames.length + b : b++), b !== this._frameIndex && (this._frameIndex = b, this.updateCurrentFrame(!0));
        },
        updateFrameData: function(a) {
            this._frameData = a, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;
        },
        destroy: function() {
            this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose());
        },
        complete: function() {
            this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill();
        }
    }, c53.Animation.prototype.constructor = c53.Animation, Object.defineProperty(c53.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused;
        },
        set: function(a) {
            this.isPaused = a, a ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay);
        }
    }), Object.defineProperty(c53.Animation.prototype, "reversed", {
        get: function() {
            return this.isReversed;
        },
        set: function(a) {
            this.isReversed = a;
        }
    }), Object.defineProperty(c53.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length;
        }
    }), Object.defineProperty(c53.Animation.prototype, "frame", {
        get: function() {
            return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex;
        },
        set: function(a) {
            this.currentFrame = this._frameData.getFrame(this._frames[a]), null !== this.currentFrame && (this._frameIndex = a, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame));
        }
    }), Object.defineProperty(c53.Animation.prototype, "speed", {
        get: function() {
            return 1000 / this.delay;
        },
        set: function(a) {
            a > 0 && (this.delay = 1000 / a);
        }
    }), Object.defineProperty(c53.Animation.prototype, "enableUpdate", {
        get: function() {
            return null !== this.onUpdate;
        },
        set: function(a) {
            a && null === this.onUpdate ? this.onUpdate = new c53.Signal : a || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null);
        }
    }), c53.Animation.generateFrameNames = function(a, b, d, e, f) {
        void 0 === e && (e = "");
        var g = [], h = "";
        if (b < d) for(var i = b; i <= d; i++)h = "number" == typeof f ? c53.Utils.pad(i.toString(), f, "0", 1) : i.toString(), h = a + h + e, g.push(h);
        else for(var i = b; i >= d; i--)h = "number" == typeof f ? c53.Utils.pad(i.toString(), f, "0", 1) : i.toString(), h = a + h + e, g.push(h);
        return g;
    }, c53.Frame = function(a, b, d, e, f, g) {
        this.index = a, this.x = b, this.y = d, this.width = e, this.height = f, 0 !== this.width && 0 !== this.height || console.warn('Phaser.Frame: Frame "' + this.name + '" has a width or height of zero'), this.name = g, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(f / 2), this.distance = c53.Math.distance(0, 0, e, f), this.rotated = !1, this.trimmed = !1, this.sourceSizeW = e, this.sourceSizeH = f, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height;
    }, c53.Frame.prototype = {
        resize: function(a, b) {
            this.width = a, this.height = b, this.centerX = Math.floor(a / 2), this.centerY = Math.floor(b / 2), this.distance = c53.Math.distance(0, 0, a, b), this.sourceSizeW = a, this.sourceSizeH = b, this.right = this.x + a, this.bottom = this.y + b;
        },
        setTrim: function(a, b, c, d, e, f, g) {
            this.trimmed = a, a && (this.sourceSizeW = b, this.sourceSizeH = c, this.centerX = Math.floor(b / 2), this.centerY = Math.floor(c / 2), this.spriteSourceSizeX = d, this.spriteSourceSizeY = e, this.spriteSourceSizeW = f, this.spriteSourceSizeH = g);
        },
        clone: function() {
            var a = new c53.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
            for(var b in this)this.hasOwnProperty(b) && (a[b] = this[b]);
            return a;
        },
        getRect: function(a) {
            return void 0 === a ? a = new c53.Rectangle(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height), a;
        }
    }, c53.Frame.prototype.constructor = c53.Frame, c53.FrameData = function() {
        this._frames = [], this._frameNames = [];
    }, c53.FrameData.prototype = {
        addFrame: function(a) {
            return a.index = this._frames.length, this._frames.push(a), "" !== a.name && (this._frameNames[a.name] = a.index), a;
        },
        getFrame: function(a) {
            return a >= this._frames.length && (a = 0), this._frames[a];
        },
        getFrameByName: function(a) {
            return "number" == typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null;
        },
        checkFrameName: function(a) {
            return null != this._frameNames[a];
        },
        clone: function() {
            for(var a = new c53.FrameData, b = 0; b < this._frames.length; b++)a._frames.push(this._frames[b].clone());
            for(var d in this._frameNames)this._frameNames.hasOwnProperty(d) && a._frameNames.push(this._frameNames[d]);
            return a;
        },
        getFrameRange: function(a, b, c) {
            void 0 === c && (c = []);
            for(var d = a; d <= b; d++)c.push(this._frames[d]);
            return c;
        },
        getFrames: function(a, b, c) {
            if (void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length) for(var d = 0; d < this._frames.length; d++)c.push(this._frames[d]);
            else for(var d = 0; d < a.length; d++)b ? c.push(this.getFrame(a[d])) : c.push(this.getFrameByName(a[d]));
            return c;
        },
        getFrameIndexes: function(a, b, c) {
            if (void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length) for(var d = 0; d < this._frames.length; d++)c.push(this._frames[d].index);
            else for(var d = 0; d < a.length; d++)b && this._frames[a[d]] ? c.push(this._frames[a[d]].index) : this.getFrameByName(a[d]) && c.push(this.getFrameByName(a[d]).index);
            return c;
        },
        destroy: function() {
            this._frames = null, this._frameNames = null;
        }
    }, c53.FrameData.prototype.constructor = c53.FrameData, Object.defineProperty(c53.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length;
        }
    }), c53.AnimationParser = {
        spriteSheet: function(a, b, d, e, f, g, h, i) {
            void 0 === f && (f = -1), void 0 === g && (g = 0), void 0 === h && (h = 0), void 0 === i && (i = 0);
            var j = b;
            if ("string" == typeof b && (j = a.cache.getImage(b)), null === j) return null;
            var k = j.width, l = j.height;
            d <= 0 && (d = Math.floor(-k / Math.min(-1, d))), e <= 0 && (e = Math.floor(-l / Math.min(-1, e)));
            var m = Math.floor((k - g) / (d + h)), n = Math.floor((l - g) / (e + h)), o = m * n;
            if (i > o || i < -o) return console.warn("Phaser.AnimationParser.spriteSheet: skipFrames = " + i.toString() + " is larger than total sprite number " + o.toString()), null;
            if (i < 0 && (i = o + i), -1 !== f && (o = i + f), 0 === k || 0 === l || k < d || l < e || 0 === o) return console.warn("Phaser.AnimationParser.spriteSheet: '" + b + "'s width/height zero or width/height < given frameWidth/frameHeight"), null;
            for(var p = new c53.FrameData, q = g, r = g, s = 0; s < o; s++)p.addFrame(new c53.Frame(s, q, r, d, e, "")), (q += d + h) + d > k && (q = g, r += e + h);
            return p;
        },
        JSONData: function(a, b) {
            if (!b.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(b);
            for(var d, e = new c53.FrameData, f = b.frames, g = 0; g < f.length; g++)d = e.addFrame(new c53.Frame(g, f[g].frame.x, f[g].frame.y, f[g].frame.w, f[g].frame.h, f[g].filename)), f[g].trimmed && d.setTrim(f[g].trimmed, f[g].sourceSize.w, f[g].sourceSize.h, f[g].spriteSourceSize.x, f[g].spriteSourceSize.y, f[g].spriteSourceSize.w, f[g].spriteSourceSize.h), f[g].rotated && (d.rotated = !0);
            return e;
        },
        JSONDataPyxel: function(a78, b) {
            if ([
                "layers",
                "tilewidth",
                "tileheight",
                "tileswide",
                "tileshigh"
            ].forEach(function(a) {
                if (!b[a]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + a + '" key.'), void console.log(b);
            }), 1 !== b.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void console.log(b);
            for(var d, e = new c53.FrameData, f = b.tileheight, g = b.tilewidth, h = b.layers[0].tiles, i = 0; i < h.length; i++)d = e.addFrame(new c53.Frame(i, h[i].x, h[i].y, g, f, "frame_" + i)), d.setTrim(!1);
            return e;
        },
        JSONDataHash: function(a, b) {
            if (!b.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(b);
            var d, e = new c53.FrameData, f = b.frames, g = 0;
            for(var h in f)d = e.addFrame(new c53.Frame(g, f[h].frame.x, f[h].frame.y, f[h].frame.w, f[h].frame.h, h)), f[h].trimmed && d.setTrim(f[h].trimmed, f[h].sourceSize.w, f[h].sourceSize.h, f[h].spriteSourceSize.x, f[h].spriteSourceSize.y, f[h].spriteSourceSize.w, f[h].spriteSourceSize.h), f[h].rotated && (d.rotated = !0), g++;
            return e;
        },
        XMLData: function(a, b) {
            if (!b.getElementsByTagName("TextureAtlas")) return void console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
            for(var d, e, f, g, h, i, j, k, l, m, n, o = new c53.FrameData, p = b.getElementsByTagName("SubTexture"), q = 0; q < p.length; q++)f = p[q].attributes, e = f.name.value, g = parseInt(f.x.value, 10), h = parseInt(f.y.value, 10), i = parseInt(f.width.value, 10), j = parseInt(f.height.value, 10), k = null, l = null, f.frameX && (k = Math.abs(parseInt(f.frameX.value, 10)), l = Math.abs(parseInt(f.frameY.value, 10)), m = parseInt(f.frameWidth.value, 10), n = parseInt(f.frameHeight.value, 10)), d = o.addFrame(new c53.Frame(q, g, h, i, j, e)), null === k && null === l || d.setTrim(!0, i, j, k, l, m, n);
            return o;
        }
    }, c53.Cache = function(a) {
        this.game = a, this.autoResolveURL = !1, this._cache = {
            canvas: {},
            image: {},
            texture: {},
            sound: {},
            video: {},
            text: {},
            json: {},
            xml: {},
            physics: {},
            tilemap: {},
            binary: {},
            bitmapData: {},
            bitmapFont: {},
            shader: {},
            renderTexture: {},
            compressedTexture: {}
        }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new c53.Signal, this._cacheMap = [], this._cacheMap[c53.Cache.CANVAS] = this._cache.canvas, this._cacheMap[c53.Cache.IMAGE] = this._cache.image, this._cacheMap[c53.Cache.TEXTURE] = this._cache.texture, this._cacheMap[c53.Cache.SOUND] = this._cache.sound, this._cacheMap[c53.Cache.TEXT] = this._cache.text, this._cacheMap[c53.Cache.PHYSICS] = this._cache.physics, this._cacheMap[c53.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[c53.Cache.BINARY] = this._cache.binary, this._cacheMap[c53.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[c53.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[c53.Cache.JSON] = this._cache.json, this._cacheMap[c53.Cache.XML] = this._cache.xml, this._cacheMap[c53.Cache.VIDEO] = this._cache.video, this._cacheMap[c53.Cache.SHADER] = this._cache.shader, this._cacheMap[c53.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage();
    }, c53.Cache.CANVAS = 1, c53.Cache.IMAGE = 2, c53.Cache.TEXTURE = 3, c53.Cache.SOUND = 4, c53.Cache.TEXT = 5, c53.Cache.PHYSICS = 6, c53.Cache.TILEMAP = 7, c53.Cache.BINARY = 8, c53.Cache.BITMAPDATA = 9, c53.Cache.BITMAPFONT = 10, c53.Cache.JSON = 11, c53.Cache.XML = 12, c53.Cache.VIDEO = 13, c53.Cache.SHADER = 14, c53.Cache.RENDER_TEXTURE = 15, c53.Cache.DEFAULT = null, c53.Cache.MISSING = null, c53.Cache.prototype = {
        addCompressedTextureMetaData: function(a, b, d, e) {
            this.checkImageKey(a) && this.removeImage(a);
            var f = d in c53.LoaderParser ? c53.LoaderParser[d](e) : e, g = {
                key: a,
                url: b,
                data: f,
                base: new PIXI.BaseTexture(f, null, this.game.resolution),
                frame: new c53.Frame(0, 0, 0, f.width, f.height, a),
                frameData: new c53.FrameData,
                fileFormat: d
            };
            return g.frameData.addFrame(new c53.Frame(0, 0, 0, f.width, f.height, b)), this._cache.image[a] = g, this._resolveURL(b, g), g;
        },
        addCanvas: function(a, b, c) {
            void 0 === c && (c = b.getContext("2d")), this._cache.canvas[a] = {
                canvas: b,
                context: c
            };
        },
        addImage: function(a, b, d) {
            this.checkImageKey(a) && this.removeImage(a), !1 === d.complete && console.warn('Phaser.Cache.addImage: Image "' + a + "\" hasn't been retrieved yet");
            var e = {
                key: a,
                url: b,
                data: d,
                base: new PIXI.BaseTexture(d, null, this.game.resolution),
                frame: new c53.Frame(0, 0, 0, d.width, d.height, a),
                frameData: new c53.FrameData
            };
            return e.frameData.addFrame(new c53.Frame(0, 0, 0, d.width, d.height, b)), this._cache.image[a] = e, this._resolveURL(b, e), "__default" === a ? c53.Cache.DEFAULT = new PIXI.Texture(e.base) : "__missing" === a && (c53.Cache.MISSING = new PIXI.Texture(e.base)), e;
        },
        addDefaultImage: function() {
            var a = this, b = new Image;
            b.onload = function() {
                var d = a.addImage("__default", null, b);
                d.base.skipRender = !0, c53.Cache.DEFAULT = new PIXI.Texture(d.base), b.onload = null;
            }, b.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
        },
        addMissingImage: function() {
            var a = this, b = new Image;
            b.onload = function() {
                var d = a.addImage("__missing", null, b);
                c53.Cache.MISSING = new PIXI.Texture(d.base), b.onload = null;
            }, b.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
        },
        addSound: function(a, b, c, d, e) {
            void 0 === d && (d = !0, e = !1), void 0 === e && (d = !1, e = !0);
            var f = !1;
            e && (f = !0), this._cache.sound[a] = {
                url: b,
                data: c,
                isDecoding: !1,
                decoded: f,
                webAudio: d,
                audioTag: e,
                locked: this.game.sound.touchLocked
            }, this._resolveURL(b, this._cache.sound[a]);
        },
        addText: function(a, b, c) {
            this._cache.text[a] = {
                url: b,
                data: c
            }, this._resolveURL(b, this._cache.text[a]);
        },
        addPhysicsData: function(a, b, c, d) {
            this._cache.physics[a] = {
                url: b,
                data: c,
                format: d
            }, this._resolveURL(b, this._cache.physics[a]);
        },
        addTilemap: function(a, b, c, d) {
            this._cache.tilemap[a] = {
                url: b,
                data: c,
                format: d
            }, this._resolveURL(b, this._cache.tilemap[a]);
        },
        addBinary: function(a, b) {
            this._cache.binary[a] = b;
        },
        addBitmapData: function(a, b, d) {
            return b.key = a, void 0 === d && (d = new c53.FrameData, d.addFrame(b.textureFrame)), this._cache.bitmapData[a] = {
                data: b,
                frameData: d
            }, b;
        },
        addBitmapFont: function(a, b, d, e, f, g, h) {
            var i = {
                url: b,
                data: d,
                font: null,
                base: new PIXI.BaseTexture(d, null, this.game.resolution)
            };
            void 0 === g && (g = 0), void 0 === h && (h = 0), i.font = "json" === f ? c53.LoaderParser.jsonBitmapFont(e, i.base, g, h, !1, this.game.resolution) : c53.LoaderParser.xmlBitmapFont(e, i.base, g, h, !1, this.game.resolution), this._cache.bitmapFont[a] = i, this._resolveURL(b, i);
        },
        addBitmapFontFromAtlas: function(a, b, d, e, f, g, h) {
            var i = this.getFrameByName(b, d);
            if (i) {
                var j = {
                    font: null,
                    base: this.getBaseTexture(b),
                    frame: i
                };
                void 0 === g && (g = 0), void 0 === h && (h = 0);
                var k;
                "json" === f ? (k = this.getJSON(e), j.font = c53.LoaderParser.jsonBitmapFont(k, j.base, g, h, i, this.game.resolution)) : (k = this.getXML(e), j.font = c53.LoaderParser.xmlBitmapFont(k, j.base, g, h, i, this.game.resolution)), this._cache.bitmapFont[a] = j;
            }
        },
        addJSON: function(a, b, c) {
            this._cache.json[a] = {
                url: b,
                data: c
            }, this._resolveURL(b, this._cache.json[a]);
        },
        addXML: function(a, b, c) {
            this._cache.xml[a] = {
                url: b,
                data: c
            }, this._resolveURL(b, this._cache.xml[a]);
        },
        addVideo: function(a, b, c, d) {
            this._cache.video[a] = {
                url: b,
                data: c,
                isBlob: d,
                locked: !0
            }, this._resolveURL(b, this._cache.video[a]);
        },
        addShader: function(a, b, c) {
            this._cache.shader[a] = {
                url: b,
                data: c
            }, this._resolveURL(b, this._cache.shader[a]);
        },
        addRenderTexture: function(a, b) {
            this._cache.renderTexture[a] = {
                texture: b,
                frame: new c53.Frame(0, 0, 0, b.width, b.height, "", "")
            };
        },
        addSpriteSheet: function(a, b, d, e, f, g, h, i, j) {
            void 0 === g && (g = -1), void 0 === h && (h = 0), void 0 === i && (i = 0);
            var k = {
                key: a,
                url: b,
                data: d,
                frameWidth: e,
                frameHeight: f,
                margin: h,
                spacing: i,
                base: new PIXI.BaseTexture(d, null, this.game.resolution),
                frameData: c53.AnimationParser.spriteSheet(this.game, d, e, f, g, h, i, j)
            };
            this._cache.image[a] = k, this._resolveURL(b, k);
        },
        addTextureAtlas: function(a, b, d, e, f) {
            var g = {
                key: a,
                url: b,
                data: d,
                base: new PIXI.BaseTexture(d, null, this.game.resolution)
            };
            f === c53.Loader.TEXTURE_ATLAS_XML_STARLING ? g.frameData = c53.AnimationParser.XMLData(this.game, e, a) : f === c53.Loader.TEXTURE_ATLAS_JSON_PYXEL ? g.frameData = c53.AnimationParser.JSONDataPyxel(this.game, e, a) : Array.isArray(e.frames) ? g.frameData = c53.AnimationParser.JSONData(this.game, e, a) : g.frameData = c53.AnimationParser.JSONDataHash(this.game, e, a), this._cache.image[a] = g, this._resolveURL(b, g);
        },
        reloadSound: function(a) {
            var b = this, c = this.getSound(a);
            c && (c.data.src = c.url, c.data.addEventListener("canplaythrough", function() {
                return b.reloadSoundComplete(a);
            }, !1), c.data.load());
        },
        reloadSoundComplete: function(a) {
            var b = this.getSound(a);
            b && (b.locked = !1, this.onSoundUnlock.dispatch(a));
        },
        updateSound: function(a, b, c) {
            var d = this.getSound(a);
            d && (d[b] = c);
        },
        decodedSound: function(a, b) {
            var c = this.getSound(a);
            c.data = b, c.decoded = !0, c.isDecoding = !1;
        },
        isSoundDecoded: function(a) {
            var b = this.getItem(a, c53.Cache.SOUND, "isSoundDecoded");
            if (b) return b.decoded;
        },
        isSoundReady: function(a) {
            var b = this.getItem(a, c53.Cache.SOUND, "isSoundDecoded");
            if (b) return b.decoded && !this.game.sound.touchLocked;
        },
        checkKey: function(a, b) {
            return !!this._cacheMap[a][b];
        },
        checkURL: function(a) {
            return !!this._urlMap[this._resolveURL(a)];
        },
        checkCanvasKey: function(a) {
            return this.checkKey(c53.Cache.CANVAS, a);
        },
        checkImageKey: function(a) {
            return this.checkKey(c53.Cache.IMAGE, a);
        },
        checkTextureKey: function(a) {
            return this.checkKey(c53.Cache.TEXTURE, a);
        },
        checkSoundKey: function(a) {
            return this.checkKey(c53.Cache.SOUND, a);
        },
        checkTextKey: function(a) {
            return this.checkKey(c53.Cache.TEXT, a);
        },
        checkPhysicsKey: function(a) {
            return this.checkKey(c53.Cache.PHYSICS, a);
        },
        checkTilemapKey: function(a) {
            return this.checkKey(c53.Cache.TILEMAP, a);
        },
        checkBinaryKey: function(a) {
            return this.checkKey(c53.Cache.BINARY, a);
        },
        checkBitmapDataKey: function(a) {
            return this.checkKey(c53.Cache.BITMAPDATA, a);
        },
        checkBitmapFontKey: function(a) {
            return this.checkKey(c53.Cache.BITMAPFONT, a);
        },
        checkJSONKey: function(a) {
            return this.checkKey(c53.Cache.JSON, a);
        },
        checkXMLKey: function(a) {
            return this.checkKey(c53.Cache.XML, a);
        },
        checkVideoKey: function(a) {
            return this.checkKey(c53.Cache.VIDEO, a);
        },
        checkShaderKey: function(a) {
            return this.checkKey(c53.Cache.SHADER, a);
        },
        checkRenderTextureKey: function(a) {
            return this.checkKey(c53.Cache.RENDER_TEXTURE, a);
        },
        getItem: function(a, b, c, d) {
            return this.checkKey(b, a) ? void 0 === d ? this._cacheMap[b][a] : this._cacheMap[b][a][d] : (c && console.warn("Phaser.Cache." + c + ': Key "' + a + '" not found in Cache.'), null);
        },
        getCanvas: function(a) {
            return this.getItem(a, c53.Cache.CANVAS, "getCanvas", "canvas");
        },
        getImage: function(a, b) {
            void 0 !== a && null !== a || (a = "__default"), void 0 === b && (b = !1);
            var d = this.getItem(a, c53.Cache.IMAGE, "getImage");
            return null === d && (d = this.getItem("__missing", c53.Cache.IMAGE, "getImage")), b ? d : d.data;
        },
        getTextureFrame: function(a) {
            return this.getItem(a, c53.Cache.TEXTURE, "getTextureFrame", "frame");
        },
        getSound: function(a) {
            return this.getItem(a, c53.Cache.SOUND, "getSound");
        },
        getSoundData: function(a) {
            return this.getItem(a, c53.Cache.SOUND, "getSoundData", "data");
        },
        getText: function(a) {
            return this.getItem(a, c53.Cache.TEXT, "getText", "data");
        },
        getPhysicsData: function(a, b, d) {
            var e = this.getItem(a, c53.Cache.PHYSICS, "getPhysicsData", "data");
            if (null === e || void 0 === b || null === b) return e;
            if (e[b]) {
                var f = e[b];
                if (!f || !d) return f;
                for(var g in f)if (g = f[g], g.fixtureKey === d) return g;
                console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + d + " in " + a + '"');
            } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + a + " / " + b + '"');
            return null;
        },
        getTilemapData: function(a) {
            return this.getItem(a, c53.Cache.TILEMAP, "getTilemapData");
        },
        getBinary: function(a) {
            return this.getItem(a, c53.Cache.BINARY, "getBinary");
        },
        getBitmapData: function(a) {
            return this.getItem(a, c53.Cache.BITMAPDATA, "getBitmapData", "data");
        },
        getBitmapFont: function(a) {
            return this.getItem(a, c53.Cache.BITMAPFONT, "getBitmapFont");
        },
        getJSON: function(a, b) {
            var d = this.getItem(a, c53.Cache.JSON, "getJSON", "data");
            return d ? b ? c53.Utils.extend(!0, Array.isArray(d) ? [] : {}, d) : d : null;
        },
        getXML: function(a) {
            return this.getItem(a, c53.Cache.XML, "getXML", "data");
        },
        getVideo: function(a) {
            return this.getItem(a, c53.Cache.VIDEO, "getVideo");
        },
        getShader: function(a) {
            return this.getItem(a, c53.Cache.SHADER, "getShader", "data");
        },
        getRenderTexture: function(a) {
            return this.getItem(a, c53.Cache.RENDER_TEXTURE, "getRenderTexture");
        },
        getBaseTexture: function(a, b) {
            return void 0 === b && (b = c53.Cache.IMAGE), this.getItem(a, b, "getBaseTexture", "base");
        },
        getFrame: function(a, b) {
            return void 0 === b && (b = c53.Cache.IMAGE), this.getItem(a, b, "getFrame", "frame");
        },
        getFrameCount: function(a, b) {
            var c = this.getFrameData(a, b);
            return c ? c.total : 0;
        },
        getFrameData: function(a, b) {
            return void 0 === b && (b = c53.Cache.IMAGE), this.getItem(a, b, "getFrameData", "frameData");
        },
        hasFrameData: function(a, b) {
            return void 0 === b && (b = c53.Cache.IMAGE), null !== this.getItem(a, b, "", "frameData");
        },
        updateFrameData: function(a, b, d) {
            void 0 === d && (d = c53.Cache.IMAGE), this._cacheMap[d][a] && (this._cacheMap[d][a].frameData = b);
        },
        getFrameByIndex: function(a, b, c) {
            var d = this.getFrameData(a, c);
            return d ? d.getFrame(b) : null;
        },
        getFrameByName: function(a, b, c) {
            var d = this.getFrameData(a, c);
            return d ? d.getFrameByName(b) : null;
        },
        getURL: function(a) {
            var a = this._resolveURL(a);
            return a ? this._urlMap[a] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + a + '" or Cache.autoResolveURL was false'), null);
        },
        getKeys: function(a) {
            void 0 === a && (a = c53.Cache.IMAGE);
            var b = [];
            if (this._cacheMap[a]) for(var d in this._cacheMap[a])"__default" !== d && "__missing" !== d && b.push(d);
            return b;
        },
        removeCanvas: function(a) {
            delete this._cache.canvas[a];
        },
        removeImage: function(a, b) {
            void 0 === b && (b = !0);
            var c = this.getImage(a, !0);
            b && c.base && c.base.destroy(), delete this._cache.image[a];
        },
        removeSound: function(a) {
            delete this._cache.sound[a];
        },
        removeText: function(a) {
            delete this._cache.text[a];
        },
        removePhysics: function(a) {
            delete this._cache.physics[a];
        },
        removeTilemap: function(a) {
            delete this._cache.tilemap[a];
        },
        removeBinary: function(a) {
            delete this._cache.binary[a];
        },
        removeBitmapData: function(a) {
            delete this._cache.bitmapData[a];
        },
        removeBitmapFont: function(a) {
            delete this._cache.bitmapFont[a];
        },
        removeJSON: function(a) {
            delete this._cache.json[a];
        },
        removeXML: function(a) {
            delete this._cache.xml[a];
        },
        removeVideo: function(a) {
            delete this._cache.video[a];
        },
        removeShader: function(a) {
            delete this._cache.shader[a];
        },
        removeRenderTexture: function(a) {
            delete this._cache.renderTexture[a];
        },
        removeSpriteSheet: function(a) {
            delete this._cache.spriteSheet[a];
        },
        removeTextureAtlas: function(a) {
            delete this._cache.image[a];
        },
        clearGLTextures: function() {
            for(var a in this._cache.image)this._cache.image[a].base._glTextures = [];
        },
        _resolveURL: function(a, b) {
            return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + a, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", b && (this._urlMap[this._urlTemp] = b), this._urlTemp) : null;
        },
        destroy: function() {
            for(var a = 0; a < this._cacheMap.length; a++){
                var b = this._cacheMap[a];
                for(var c in b)"__default" !== c && "__missing" !== c && (this.destroyItem(b[c]), delete b[c]);
            }
            this._urlMap = null, this._urlResolver = null, this._urlTemp = null;
        },
        destroyItem: function(a) {
            a.destroy ? a.destroy() : (a.base && a.base.destroy && a.base.destroy(), a.data && a.data.destroy && a.data.destroy(), a.frameData && a.frameData.destroy && a.frameData.destroy(), a.texture && a.texture.destroy && a.texture.destroy(!0));
        }
    }, c53.Cache.prototype.constructor = c53.Cache, c53.Loader = function(a) {
        this.game = a, this.cache = a.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
            requestedWith: !1,
            json: "application/json",
            xml: "application/xml"
        }, this.onLoadStart = new c53.Signal, this.onLoadComplete = new c53.Signal, this.onPackComplete = new c53.Signal, this.onFileStart = new c53.Signal, this.onFileComplete = new c53.Signal, this.onFileError = new c53.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0;
    }, c53.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, c53.Loader.TEXTURE_ATLAS_JSON_HASH = 1, c53.Loader.TEXTURE_ATLAS_XML_STARLING = 2, c53.Loader.PHYSICS_LIME_CORONA_JSON = 3, c53.Loader.PHYSICS_PHASER_JSON = 4, c53.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, c53.Loader.prototype = {
        setPreloadSprite: function(a, b) {
            b = b || 0, this.preloadSprite = {
                sprite: a,
                direction: b,
                width: a.width,
                height: a.height,
                rect: null
            }, this.preloadSprite.rect = 0 === b ? new c53.Rectangle(0, 0, 1, a.height) : new c53.Rectangle(0, 0, a.width, 1), a.crop(this.preloadSprite.rect), a.visible = !0;
        },
        resize: function() {
            this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height);
        },
        checkKeyExists: function(a, b) {
            return this.getAssetIndex(a, b) > -1;
        },
        getAssetIndex: function(a, b) {
            for(var c = -1, d = 0; d < this._fileList.length; d++){
                var e = this._fileList[d];
                if (e.type === a && e.key === b && (c = d, !e.loaded && !e.loading)) break;
            }
            return c;
        },
        getAsset: function(a, b) {
            var c = this.getAssetIndex(a, b);
            return c > -1 && {
                index: c,
                file: this._fileList[c]
            };
        },
        reset: function(a, b) {
            void 0 === b && (b = !1), this.resetLocked || (a && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, b && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()));
        },
        addToFileList: function(a, b, c, d, e, f) {
            if (void 0 === e && (e = !1), void 0 === b || "" === b) return console.warn("Phaser.Loader: Invalid or no key given of type " + a), this;
            if (void 0 === c || null === c) {
                if (!f) return console.warn("Phaser.Loader: No URL given for file type: " + a + " key: " + b), this;
                c = b + f;
            }
            var g = {
                type: a,
                key: b,
                path: this.path,
                url: c,
                syncPoint: this._withSyncPointDepth > 0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1
            };
            if (d) for(var h in d)g[h] = d[h];
            var i = this.getAssetIndex(a, b);
            if (e && i > -1) {
                var j = this._fileList[i];
                j.loading || j.loaded ? (this._fileList.push(g), this._totalFileCount++) : this._fileList[i] = g;
            } else -1 === i && (this._fileList.push(g), this._totalFileCount++);
            return this;
        },
        replaceInFileList: function(a, b, c, d) {
            return this.addToFileList(a, b, c, d, !0);
        },
        pack: function(a, b, c, d) {
            if (void 0 === b && (b = null), void 0 === c && (c = null), void 0 === d && (d = null), !b && !c) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
            var e = {
                type: "packfile",
                key: a,
                url: b,
                path: this.path,
                syncPoint: !0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1,
                callbackContext: d
            };
            c && ("string" == typeof c && (c = JSON.parse(c)), e.data = c || {}, e.loaded = !0);
            for(var f = 0; f < this._fileList.length + 1; f++){
                var g = this._fileList[f];
                if (!g || !g.loaded && !g.loading && "packfile" !== g.type) {
                    this._fileList.splice(f, 0, e), this._totalPackCount++;
                    break;
                }
            }
            return this;
        },
        image: function(a, b, c) {
            return "object" == typeof b ? this.texture(a, b, c) : this.addToFileList("image", a, b, void 0, c, ".png");
        },
        imageFromBitmapData: function(a, b, c) {
            return this.image(a, b.canvas.toDataURL("image/png"), c);
        },
        texture: function(a, b, d) {
            if (this.game.renderType === c53.WEBGL) {
                var e, f = this.game.renderer.extensions.compression;
                for(e in b)if (e.toUpperCase() in f) return this.addToFileList("texture", a, b[e], void 0, d, ".pvr");
            }
            return b.truecolor && this.addToFileList("image", a, b.truecolor, void 0, d, ".png"), this;
        },
        images: function(a, b) {
            if (Array.isArray(b)) for(var c = 0; c < a.length; c++)this.image(a[c], b[c]);
            else for(var c = 0; c < a.length; c++)this.image(a[c]);
            return this;
        },
        text: function(a, b, c) {
            return this.addToFileList("text", a, b, void 0, c, ".txt");
        },
        json: function(a, b, c) {
            return this.addToFileList("json", a, b, void 0, c, ".json");
        },
        shader: function(a, b, c) {
            return this.addToFileList("shader", a, b, void 0, c, ".frag");
        },
        xml: function(a, b, c) {
            return this.addToFileList("xml", a, b, void 0, c, ".xml");
        },
        script: function(a, b, c, d) {
            return void 0 === c && (c = !1), !1 !== c && void 0 === d && (d = this), this.addToFileList("script", a, b, {
                syncPoint: !0,
                callback: c,
                callbackContext: d
            }, !1, ".js");
        },
        binary: function(a, b, c, d) {
            return void 0 === c && (c = !1), !1 !== c && void 0 === d && (d = c), this.addToFileList("binary", a, b, {
                callback: c,
                callbackContext: d
            }, !1, ".bin");
        },
        spritesheet: function(a, b, c, d, e, f, g, h) {
            return void 0 === e && (e = -1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = 0), this.addToFileList("spritesheet", a, b, {
                frameWidth: c,
                frameHeight: d,
                frameMax: e,
                margin: f,
                spacing: g,
                skipFrames: h
            }, !1, ".png");
        },
        audio: function(a, b, c) {
            return this.game.sound.noAudio ? this : (void 0 === c && (c = !0), "string" == typeof b && (b = [
                b
            ]), this.addToFileList("audio", a, b, {
                buffer: null,
                autoDecode: c
            }));
        },
        audioSprite: function(a, b, c, d, e) {
            return this.game.sound.noAudio ? this : (void 0 === c && (c = null), void 0 === d && (d = null), void 0 === e && (e = !0), this.audio(a, b, e), c ? this.json(a + "-audioatlas", c) : d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addJSON(a + "-audioatlas", "", d)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this);
        },
        audiosprite: function(a, b, c, d, e) {
            return this.audioSprite(a, b, c, d, e);
        },
        video: function(a, b, c, d) {
            return void 0 === c && (c = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === d && (d = !1), "string" == typeof b && (b = [
                b
            ]), this.addToFileList("video", a, b, {
                buffer: null,
                asBlob: d,
                loadEvent: c
            });
        },
        tilemap: function(a, b, d, e) {
            if (void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c53.Tilemap.CSV), b || d || (b = e === c53.Tilemap.CSV ? a + ".csv" : a + ".json"), d) {
                switch(e){
                    case c53.Tilemap.CSV:
                        break;
                    case c53.Tilemap.TILED_JSON:
                        "string" == typeof d && (d = JSON.parse(d));
                }
                this.cache.addTilemap(a, null, d, e);
            } else this.addToFileList("tilemap", a, b, {
                format: e
            });
            return this;
        },
        physics: function(a, b, d, e) {
            return void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c53.Physics.LIME_CORONA_JSON), b || d || (b = a + ".json"), d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addPhysicsData(a, null, d, e)) : this.addToFileList("physics", a, b, {
                format: e
            }), this;
        },
        bitmapFont: function(a, b, c, d, e, f) {
            if (void 0 !== b && null !== b || (b = a + ".png"), void 0 === c && (c = null), void 0 === d && (d = null), null === c && null === d && (c = a + ".xml"), void 0 === e && (e = 0), void 0 === f && (f = 0), c) this.addToFileList("bitmapfont", a, b, {
                atlasURL: c,
                xSpacing: e,
                ySpacing: f
            });
            else if ("string" == typeof d) {
                var g, h;
                try {
                    g = JSON.parse(d);
                } catch (a79) {
                    h = this.parseXml(d);
                }
                if (!h && !g) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                this.addToFileList("bitmapfont", a, b, {
                    atlasURL: null,
                    atlasData: g || h,
                    atlasType: g ? "json" : "xml",
                    xSpacing: e,
                    ySpacing: f
                });
            }
            return this;
        },
        atlasJSONArray: function(a, b, d, e) {
            return this.atlas(a, b, d, e, c53.Loader.TEXTURE_ATLAS_JSON_ARRAY);
        },
        atlasJSONHash: function(a, b, d, e) {
            return this.atlas(a, b, d, e, c53.Loader.TEXTURE_ATLAS_JSON_HASH);
        },
        atlasXML: function(a, b, d, e) {
            return void 0 === d && (d = null), void 0 === e && (e = null), d || e || (d = a + ".xml"), this.atlas(a, b, d, e, c53.Loader.TEXTURE_ATLAS_XML_STARLING);
        },
        atlas: function(a, b, d, e, f) {
            if (void 0 !== b && null !== b || (b = a + ".png"), void 0 === d && (d = null), void 0 === e && (e = null), void 0 === f && (f = c53.Loader.TEXTURE_ATLAS_JSON_ARRAY), d || e || (d = f === c53.Loader.TEXTURE_ATLAS_XML_STARLING ? a + ".xml" : a + ".json"), d) this.addToFileList("textureatlas", a, b, {
                atlasURL: d,
                format: f
            });
            else {
                switch(f){
                    case c53.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                        "string" == typeof e && (e = JSON.parse(e));
                        break;
                    case c53.Loader.TEXTURE_ATLAS_XML_STARLING:
                        if ("string" == typeof e) {
                            var g = this.parseXml(e);
                            if (!g) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                            e = g;
                        }
                }
                this.addToFileList("textureatlas", a, b, {
                    atlasURL: null,
                    atlasData: e,
                    format: f
                });
            }
            return this;
        },
        withSyncPoint: function(a, b) {
            this._withSyncPointDepth++;
            try {
                a.call(b || this, this);
            } finally{
                this._withSyncPointDepth--;
            }
            return this;
        },
        addSyncPoint: function(a, b) {
            var c = this.getAsset(a, b);
            return c && (c.file.syncPoint = !0), this;
        },
        removeFile: function(a, b) {
            var c = this.getAsset(a, b);
            c && (c.loaded || c.loading || this._fileList.splice(c.index, 1));
        },
        removeAll: function() {
            this._fileList.length = 0, this._flightQueue.length = 0;
        },
        start: function() {
            this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue());
        },
        processLoadQueue: function() {
            if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
            for(var a = 0; a < this._flightQueue.length; a++){
                var b = this._flightQueue[a];
                (b.loaded || b.error) && (this._flightQueue.splice(a, 1), a--, b.loading = !1, b.requestUrl = null, b.requestObject = null, b.error && this.onFileError.dispatch(b.key, b), "packfile" !== b.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, b.key, !b.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === b.type && b.error && (this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)));
            }
            for(var c = !1, d = this.enableParallel ? Math.max(1, this.maxParallelDownloads) : 1, a = this._processingHead; a < this._fileList.length; a++){
                var b = this._fileList[a];
                if ("packfile" === b.type && !b.error && b.loaded && a === this._processingHead && (this.processPack(b), this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)), b.loaded || b.error ? a === this._processingHead && (this._processingHead = a + 1) : !b.loading && this._flightQueue.length < d && ("packfile" !== b.type || b.data ? c || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(b), b.loading = !0, this.onFileStart.dispatch(this.progress, b.key, b.url), this.loadFile(b)) : (this._flightQueue.push(b), b.loading = !0, this.loadFile(b))), !b.loaded && b.syncPoint && (c = !0), this._flightQueue.length >= d || c && this._loadedPackCount === this._totalPackCount) break;
            }
            if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
            else if (!this._flightQueue.length) {
                console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                var e = this;
                setTimeout(function() {
                    e.finishedLoading(!0);
                }, 2000);
            }
        },
        finishedLoading: function(a) {
            this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, a || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.reset(), this.onLoadComplete.dispatch(), this.game.state.loadComplete());
        },
        asyncComplete: function(a, b) {
            void 0 === b && (b = ""), a.loaded = !0, a.error = !!b, b && (a.errorMessage = b, console.warn("Phaser.Loader - " + a.type + "[" + a.key + "]: " + b)), this.processLoadQueue();
        },
        processPack: function(a) {
            var b = a.data[a.key];
            if (!b) return void console.warn("Phaser.Loader - " + a.key + ": pack has data, but not for pack key");
            for(var d = 0; d < b.length; d++){
                var e = b[d];
                switch(e.type){
                    case "image":
                        this.image(e.key, e.url, e.overwrite);
                        break;
                    case "text":
                        this.text(e.key, e.url, e.overwrite);
                        break;
                    case "json":
                        this.json(e.key, e.url, e.overwrite);
                        break;
                    case "xml":
                        this.xml(e.key, e.url, e.overwrite);
                        break;
                    case "script":
                        this.script(e.key, e.url, e.callback, a.callbackContext || this);
                        break;
                    case "binary":
                        this.binary(e.key, e.url, e.callback, a.callbackContext || this);
                        break;
                    case "spritesheet":
                        this.spritesheet(e.key, e.url, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing, e.skipFrames);
                        break;
                    case "video":
                        this.video(e.key, e.urls);
                        break;
                    case "audio":
                        this.audio(e.key, e.urls, e.autoDecode);
                        break;
                    case "audiosprite":
                        this.audiosprite(e.key, e.urls, e.jsonURL, e.jsonData, e.autoDecode);
                        break;
                    case "tilemap":
                        this.tilemap(e.key, e.url, e.data, c53.Tilemap[e.format]);
                        break;
                    case "physics":
                        this.physics(e.key, e.url, e.data, c53.Loader[e.format]);
                        break;
                    case "bitmapFont":
                        this.bitmapFont(e.key, e.textureURL, e.atlasURL, e.atlasData, e.xSpacing, e.ySpacing);
                        break;
                    case "atlasJSONArray":
                        this.atlasJSONArray(e.key, e.textureURL, e.atlasURL, e.atlasData);
                        break;
                    case "atlasJSONHash":
                        this.atlasJSONHash(e.key, e.textureURL, e.atlasURL, e.atlasData);
                        break;
                    case "atlasXML":
                        this.atlasXML(e.key, e.textureURL, e.atlasURL, e.atlasData);
                        break;
                    case "atlas":
                        this.atlas(e.key, e.textureURL, e.atlasURL, e.atlasData, c53.Loader[e.format]);
                        break;
                    case "shader":
                        this.shader(e.key, e.url, e.overwrite);
                }
            }
        },
        transformUrl: function(a, b) {
            return !!a && (a.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? a : this.baseURL + b.path + a);
        },
        loadFile: function(a) {
            switch(a.type){
                case "packfile":
                    this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                    break;
                case "image":
                case "spritesheet":
                case "textureatlas":
                case "bitmapfont":
                    this.loadImageTag(a);
                    break;
                case "audio":
                    a.url = this.getAudioURL(a.url), a.url ? this.game.sound.usingWebAudio ? this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(a) : this.fileError(a, null, "No supported audio URL specified or device does not have audio playback support");
                    break;
                case "video":
                    a.url = this.getVideoURL(a.url), a.url ? a.asBlob ? this.xhrLoad(a, this.transformUrl(a.url, a), "blob", this.fileComplete) : this.loadVideoTag(a) : this.fileError(a, null, "No supported video URL specified or device does not have video playback support");
                    break;
                case "json":
                    this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete);
                    break;
                case "xml":
                    this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.xmlLoadComplete);
                    break;
                case "tilemap":
                    a.format === c53.Tilemap.TILED_JSON ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete) : a.format === c53.Tilemap.CSV ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.csvLoadComplete) : this.asyncComplete(a, "invalid Tilemap format: " + a.format);
                    break;
                case "text":
                case "script":
                case "shader":
                case "physics":
                    this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                    break;
                case "texture":
                    "truecolor" === a.key.split("_").pop() ? this.loadImageTag(a) : this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete);
                    break;
                case "binary":
                    this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete);
            }
        },
        loadImageTag: function(a) {
            var b = this;
            a.data = new Image, a.data.name = a.key, this.crossOrigin && (a.data.crossOrigin = this.crossOrigin), a.data.onload = function() {
                a.data.onload && (a.data.onload = null, a.data.onerror = null, b.fileComplete(a));
            }, a.data.onerror = function() {
                a.data.onload && (a.data.onload = null, a.data.onerror = null, b.fileError(a));
            }, a.data.src = this.transformUrl(a.url, a), !this.game.device.firefox && a.data.complete && a.data.width && a.data.height && (a.data.onload = null, a.data.onerror = null, this.fileComplete(a));
        },
        loadVideoTag: function(a) {
            var b = this;
            a.data = document.createElement("video"), a.data.name = a.key, a.data.controls = !1, a.data.autoplay = !1;
            var d = function() {
                a.data.removeEventListener(a.loadEvent, d, !1), a.data.onerror = null, a.data.canplay = !0, c53.GAMES[b.game.id].load.fileComplete(a);
            };
            a.data.onerror = function() {
                a.data.removeEventListener(a.loadEvent, d, !1), a.data.onerror = null, a.data.canplay = !1, b.fileError(a);
            }, a.data.addEventListener(a.loadEvent, d, !1), a.data.src = this.transformUrl(a.url, a), a.data.load();
        },
        loadAudioTag: function(a) {
            var b = this;
            if (this.game.sound.touchLocked) a.data = new Audio, a.data.name = a.key, a.data.preload = "auto", a.data.src = this.transformUrl(a.url, a), this.fileComplete(a);
            else {
                a.data = new Audio, a.data.name = a.key;
                var c = function() {
                    a.data.removeEventListener("canplaythrough", c, !1), a.data.onerror = null, b.fileComplete(a);
                };
                a.data.onerror = function() {
                    a.data.removeEventListener("canplaythrough", c, !1), a.data.onerror = null, b.fileError(a);
                }, a.data.preload = "auto", a.data.src = this.transformUrl(a.url, a), a.data.addEventListener("canplaythrough", c, !1), a.data.load();
            }
        },
        xhrLoad: function(a, b65, c, d, e) {
            if (this.useXDomainRequest && window.XDomainRequest) return void this.xhrLoadWithXDR(a, b65, c, d, e);
            var f = new XMLHttpRequest;
            f.open("GET", b65, !0), f.responseType = c, !1 !== this.headers.requestedWith && f.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[a.type] && f.setRequestHeader("Accept", this.headers[a.type]), e = e || this.fileError;
            var g = this;
            f.onload = function() {
                try {
                    return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f);
                } catch (b) {
                    g.hasLoaded ? window.console && console.error(b) : g.asyncComplete(a, b.message || "Exception");
                }
            }, f.onerror = function() {
                try {
                    return e.call(g, a, f);
                } catch (b) {
                    g.hasLoaded ? window.console && console.error(b) : g.asyncComplete(a, b.message || "Exception");
                }
            }, a.requestObject = f, a.requestUrl = b65, f.send();
        },
        xhrLoadWithXDR: function(a, b66, c, d, e) {
            this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0, console.warn("Phaser.Loader - using XDomainRequest outside of IE 9"));
            var f = new window.XDomainRequest;
            f.open("GET", b66, !0), f.responseType = c, f.timeout = 3000, e = e || this.fileError;
            var g = this;
            f.onerror = function() {
                try {
                    return e.call(g, a, f);
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception");
                }
            }, f.ontimeout = function() {
                try {
                    return e.call(g, a, f);
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception");
                }
            }, f.onprogress = function() {}, f.onload = function() {
                try {
                    return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f);
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception");
                }
            }, a.requestObject = f, a.requestUrl = b66, setTimeout(function() {
                f.send();
            }, 0);
        },
        getVideoURL: function(a) {
            for(var b = 0; b < a.length; b++){
                var c, d = a[b];
                if (d.uri) {
                    if (c = d.type, d = d.uri, this.game.device.canPlayVideo(c)) return d;
                } else {
                    if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
                    d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
                    if (c = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(c)) return a[b];
                }
            }
            return null;
        },
        getAudioURL: function(a) {
            if (this.game.sound.noAudio) return null;
            for(var b = 0; b < a.length; b++){
                var c, d = a[b];
                if (d.uri) {
                    if (c = d.type, d = d.uri, this.game.device.canPlayAudio(c)) return d;
                } else {
                    if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
                    d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
                    if (c = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(c)) return a[b];
                }
            }
            return null;
        },
        fileError: function(a, b, c) {
            var d = a.requestUrl || this.transformUrl(a.url, a), e = "error loading asset from URL " + d;
            !c && b && (c = b.status), c && (e = e + " (" + c + ")"), this.asyncComplete(a, e);
        },
        fileComplete: function(a81, b67) {
            var d = !0;
            switch(a81.type){
                case "packfile":
                    var e = JSON.parse(b67.responseText);
                    a81.data = e || {};
                    break;
                case "texture":
                    var f = /\.([^.]+)$/.exec(a81.url.split("?", 1)[0])[1].toLowerCase();
                    null !== a81.data ? this.cache.addCompressedTextureMetaData(a81.key, a81.url, f, a81.data) : this.cache.addCompressedTextureMetaData(a81.key, a81.url, f, b67.response);
                    break;
                case "image":
                    this.cache.addImage(a81.key, a81.url, a81.data);
                    break;
                case "spritesheet":
                    this.cache.addSpriteSheet(a81.key, a81.url, a81.data, a81.frameWidth, a81.frameHeight, a81.frameMax, a81.margin, a81.spacing, a81.skipFrames);
                    break;
                case "textureatlas":
                    if (null == a81.atlasURL) this.cache.addTextureAtlas(a81.key, a81.url, a81.data, a81.atlasData, a81.format);
                    else if (d = !1, a81.format === c53.Loader.TEXTURE_ATLAS_JSON_ARRAY || a81.format === c53.Loader.TEXTURE_ATLAS_JSON_HASH || a81.format === c53.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(a81, this.transformUrl(a81.atlasURL, a81), "text", this.jsonLoadComplete);
                    else {
                        if (a81.format !== c53.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + a81.format);
                        this.xhrLoad(a81, this.transformUrl(a81.atlasURL, a81), "text", this.xmlLoadComplete);
                    }
                    break;
                case "bitmapfont":
                    a81.atlasURL ? (d = !1, this.xhrLoad(a81, this.transformUrl(a81.atlasURL, a81), "text", function(a, b) {
                        var c;
                        try {
                            c = JSON.parse(b.responseText);
                        } catch (a80) {}
                        c ? (a.atlasType = "json", this.jsonLoadComplete(a, b)) : (a.atlasType = "xml", this.xmlLoadComplete(a, b));
                    })) : this.cache.addBitmapFont(a81.key, a81.url, a81.data, a81.atlasData, a81.atlasType, a81.xSpacing, a81.ySpacing);
                    break;
                case "video":
                    if (a81.asBlob) try {
                        a81.data = b67.response;
                    } catch (b) {
                        throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + a81.key);
                    }
                    this.cache.addVideo(a81.key, a81.url, a81.data, a81.asBlob);
                    break;
                case "audio":
                    this.game.sound.usingWebAudio ? (a81.data = b67.response, this.cache.addSound(a81.key, a81.url, a81.data, !0, !1), a81.autoDecode && this.game.sound.decode(a81.key)) : this.cache.addSound(a81.key, a81.url, a81.data, !1, !0);
                    break;
                case "text":
                    a81.data = b67.responseText, this.cache.addText(a81.key, a81.url, a81.data);
                    break;
                case "shader":
                    a81.data = b67.responseText, this.cache.addShader(a81.key, a81.url, a81.data);
                    break;
                case "physics":
                    var e = JSON.parse(b67.responseText);
                    this.cache.addPhysicsData(a81.key, a81.url, e, a81.format);
                    break;
                case "script":
                    a81.data = document.createElement("script"), a81.data.language = "javascript", a81.data.type = "text/javascript", a81.data.defer = !1, a81.data.text = b67.responseText, document.head.appendChild(a81.data), a81.callback && (a81.data = a81.callback.call(a81.callbackContext, a81.key, b67.responseText));
                    break;
                case "binary":
                    a81.callback ? a81.data = a81.callback.call(a81.callbackContext, a81.key, b67.response) : a81.data = b67.response, this.cache.addBinary(a81.key, a81.data);
            }
            d && this.asyncComplete(a81);
        },
        jsonLoadComplete: function(a, b) {
            var c = JSON.parse(b.responseText);
            "tilemap" === a.type ? this.cache.addTilemap(a.key, a.url, c, a.format) : "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, c, a.atlasType, a.xSpacing, a.ySpacing) : "json" === a.type ? this.cache.addJSON(a.key, a.url, c) : this.cache.addTextureAtlas(a.key, a.url, a.data, c, a.format), this.asyncComplete(a);
        },
        csvLoadComplete: function(a, b) {
            var c = b.responseText;
            this.cache.addTilemap(a.key, a.url, c, a.format), this.asyncComplete(a);
        },
        xmlLoadComplete: function(a, b) {
            var c = b.responseText, d = this.parseXml(c);
            if (!d) {
                var e = b.responseType || b.contentType;
                return console.warn("Phaser.Loader - " + a.key + ": invalid XML (" + e + ")"), void this.asyncComplete(a, "invalid XML");
            }
            "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, d, a.atlasType, a.xSpacing, a.ySpacing) : "textureatlas" === a.type ? this.cache.addTextureAtlas(a.key, a.url, a.data, d, a.format) : "xml" === a.type && this.cache.addXML(a.key, a.url, d), this.asyncComplete(a);
        },
        parseXml: function(a) {
            var b;
            try {
                if (window.DOMParser) {
                    var c = new DOMParser;
                    b = c.parseFromString(a, "text/xml");
                } else b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a);
            } catch (a82) {
                b = null;
            }
            return b && b.documentElement && !b.getElementsByTagName("parsererror").length ? b : null;
        },
        updateProgress: function() {
            this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null);
        },
        totalLoadedFiles: function() {
            return this._loadedFileCount;
        },
        totalQueuedFiles: function() {
            return this._totalFileCount - this._loadedFileCount;
        },
        totalLoadedPacks: function() {
            return this._totalPackCount;
        },
        totalQueuedPacks: function() {
            return this._totalPackCount - this._loadedPackCount;
        }
    }, Object.defineProperty(c53.Loader.prototype, "progressFloat", {
        get: function() {
            var a = this._loadedFileCount / this._totalFileCount * 100;
            return c53.Math.clamp(a || 0, 0, 100);
        }
    }), Object.defineProperty(c53.Loader.prototype, "progress", {
        get: function() {
            return Math.round(this.progressFloat);
        }
    }), c53.Loader.prototype.constructor = c53.Loader, c53.LoaderParser = {
        bitmapFont: function(a, b, c, d, e, f) {
            return this.xmlBitmapFont(a, b, c, d, e, f);
        },
        xmlBitmapFont: function(a, b, c, d, e, f) {
            null == f && (f = 1);
            var g = {}, h = a.getElementsByTagName("info")[0], i = a.getElementsByTagName("common")[0];
            g.font = h.getAttribute("face"), g.size = parseInt(h.getAttribute("size"), 10), g.lineHeight = parseInt(i.getAttribute("lineHeight"), 10) + d, g.chars = {};
            for(var j = a.getElementsByTagName("char"), k = e ? e.x : 0, l = e ? e.y : 0, m = 0; m < j.length; m++){
                var n = parseInt(j[m].getAttribute("id"), 10);
                g.chars[n] = {
                    x: k + parseInt(j[m].getAttribute("x"), 10),
                    y: l + parseInt(j[m].getAttribute("y"), 10),
                    width: parseInt(j[m].getAttribute("width"), 10),
                    height: parseInt(j[m].getAttribute("height"), 10),
                    xOffset: parseInt(j[m].getAttribute("xoffset"), 10) / f,
                    yOffset: parseInt(j[m].getAttribute("yoffset"), 10) / f,
                    xAdvance: (parseInt(j[m].getAttribute("xadvance"), 10) + c) / f,
                    kerning: {}
                };
            }
            var o = a.getElementsByTagName("kerning");
            for(m = 0; m < o.length; m++){
                var p = parseInt(o[m].getAttribute("first"), 10), q = parseInt(o[m].getAttribute("second"), 10), r = parseInt(o[m].getAttribute("amount"), 10) / f;
                g.chars[q].kerning[p] = r;
            }
            return this.finalizeBitmapFont(b, g);
        },
        jsonBitmapFont: function(a83, b68, c, d, e, f) {
            null == f && (f = 1);
            var g = {
                font: a83.font.info._face,
                size: parseInt(a83.font.info._size, 10),
                lineHeight: parseInt(a83.font.common._lineHeight, 10) + d,
                chars: {}
            }, h = e ? e.x : 0, i = e ? e.y : 0;
            return a83.font.chars.char.forEach(function(a) {
                var b = parseInt(a._id, 10);
                g.chars[b] = {
                    x: h + parseInt(a._x, 10),
                    y: i + parseInt(a._y, 10),
                    width: parseInt(a._width, 10),
                    height: parseInt(a._height, 10),
                    xOffset: parseInt(a._xoffset, 10) / f,
                    yOffset: parseInt(a._yoffset, 10) / f,
                    xAdvance: (parseInt(a._xadvance, 10) + c) / f,
                    kerning: {}
                };
            }), a83.font.kernings && a83.font.kernings.kerning && a83.font.kernings.kerning.forEach(function(a) {
                g.chars[a._second].kerning[a._first] = parseInt(a._amount, 10) / f;
            }), this.finalizeBitmapFont(b68, g);
        },
        finalizeBitmapFont: function(a, b) {
            return Object.keys(b.chars).forEach(function(d) {
                var e = b.chars[d];
                e.texture = new PIXI.Texture(a, new c53.Rectangle(e.x, e.y, e.width, e.height));
            }), b;
        },
        pvr: function(a) {
            var b, c = new Uint32Array(a.slice(0, 52)), d = new Uint8Array(a), e = null, f = c[3] << 32 | c[2], g = 0;
            if (55727696 === c[0] && [
                0,
                1,
                2,
                3,
                6,
                7,
                9,
                11
            ].indexOf(f) >= 0) {
                switch(f >= 0 && f <= 3 ? b = "PVRTC" : f >= 7 && f <= 11 ? b = "S3TC" : 6 === f && (b = "ETC1"), f){
                    case 0:
                        g = 35841;
                        break;
                    case 1:
                        g = 35843;
                        break;
                    case 2:
                        g = 35840;
                        break;
                    case 3:
                        g = 35842;
                        break;
                    case 6:
                        g = 36196;
                        break;
                    case 7:
                        g = 33777;
                        break;
                    case 9:
                        g = 33778;
                        break;
                    case 11:
                        g = 33779;
                        break;
                    default:
                        g = -1;
                }
                e = {
                    complete: !0,
                    fileFormat: "PVR",
                    compressionAlgorithm: b,
                    flags: c[1],
                    pixelFormat: f,
                    colorSpace: c[4],
                    channelType: c[5],
                    height: c[6],
                    width: c[7],
                    depth: c[8],
                    numberOfSurfaces: c[9],
                    numberOfFaces: c[10],
                    numberOfMipmaps: c[11],
                    metaDataSize: c[12],
                    textureData: d.subarray(52 + c[12], d.byteLength),
                    glExtensionFormat: g
                };
            }
            return e;
        },
        dds: function(a) {
            var b = new Uint8Array(a), c = new Uint32Array(a), d = null;
            return 68 === b[0] && 68 === b[1] && 83 === b[2] && 32 === b[3] && (d = {
                complete: !0,
                fileFormat: "DDS",
                compressionAlgorithm: "S3TC",
                size: c[1],
                flags: c[2],
                height: c[3],
                width: c[4],
                pitch: c[5],
                depth: c[6],
                mipmapCount: c[7],
                formatSize: c[19],
                formatFlag: c[19],
                formatFourCC: [
                    String.fromCharCode(b[84]),
                    String.fromCharCode(b[85]),
                    String.fromCharCode(b[86]),
                    String.fromCharCode(b[87])
                ].join(""),
                formatBitCount: c[21],
                formatRBitMask: c[22],
                formatGBitMask: c[23],
                formatBBitMask: c[24],
                formatABitMask: c[25],
                caps1: c[26],
                caps2: c[27],
                caps3: c[28],
                caps4: c[29],
                reserved2: c[30],
                DXGIFormat: null,
                resourceDimension: null,
                miscFlag: null,
                arraySize: null,
                textureData: b.subarray(c[1] + 4, b.byteLength)
            }, "DX10" === d.formatFourCC && (d.DXGIFormat = c[31], d.resourceDimension = c[32], d.miscFlag = c[33], d.arraySize = c[34], d.miscFlag = c[35])), d;
        },
        ktx: function(a) {
            var b = new Uint8Array(a), c = new Uint32Array(a), d = null, e = 16 + c[15] / 4 | 0, f = c[e], g = c[7], h = 0;
            if (171 === b[0] && 75 === b[1] && 84 === b[2] && 88 === b[3] && 32 === b[4] && 49 === b[5] && 49 === b[6] && 187 === b[7] && 13 === b[8] && 10 === b[9] && 26 === b[10] && 10 === b[11] && [
                36196,
                35840,
                35841,
                35842,
                35843,
                33776,
                33777,
                33778,
                33779
            ].indexOf(g) >= 0) {
                switch(g){
                    case 36196:
                        h = "ETC1";
                        break;
                    case 35840:
                    case 35841:
                    case 35842:
                    case 35843:
                        h = "PVRTC";
                        break;
                    case 33776:
                    case 33777:
                    case 33778:
                    case 33779:
                        h = "S3TC";
                }
                d = {
                    complete: !0,
                    fileFormat: "KTX",
                    compressionAlgorithm: h,
                    endianness: c[3],
                    glType: c[4],
                    glTypeSize: c[5],
                    glFormat: c[6],
                    glInternalFormat: c[7],
                    glBaseInternalFormat: c[8],
                    width: c[9],
                    height: c[10],
                    pixelDepth: c[11],
                    numberOfArrayElements: c[12],
                    numberOfFaces: c[13],
                    numberOfMipmapLevels: c[14],
                    bytesOfKeyValueData: c[15],
                    keyAndValueByteSize: c[16],
                    imageSize: f,
                    textureData: b.subarray(4 * (e + 1), f + 100)
                };
            }
            return d;
        },
        pkm: function(a) {
            var b = new Uint8Array(a), c = null;
            return 80 === b[0] && 75 === b[1] && 77 === b[2] && 32 === b[3] && (c = {
                complete: !0,
                fileFormat: "PKM",
                compressionAlgorithm: "ETC1",
                format: 65535 & (b[6] << 8 | b[7]),
                width: 65535 & (b[8] << 8 | b[9]),
                height: 65535 & (b[10] << 8 | b[11]),
                originalWidth: 65535 & (b[12] << 8 | b[13]),
                originalHeight: 65535 & (b[14] << 8 | b[15]),
                textureData: b.subarray(16, b.length)
            }), c;
        }
    }, c53.AudioSprite = function(a, b) {
        this.game = a, this.key = b, this.config = this.game.cache.getJSON(b + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
        for(var c in this.config.spritemap){
            var d = this.config.spritemap[c], e = this.game.add.sound(this.key);
            e.addMarker(c, d.start, d.end - d.start, null, d.loop), this.sounds[c] = e;
        }
        this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey]);
    }, c53.AudioSprite.prototype = {
        play: function(a, b) {
            return void 0 === b && (b = 1), this.sounds[a].play(a, null, b);
        },
        stop: function(a) {
            if (a) this.sounds[a].stop();
            else for(var b in this.sounds)this.sounds[b].stop();
        },
        get: function(a) {
            return this.sounds[a];
        }
    }, c53.AudioSprite.prototype.constructor = c53.AudioSprite, c53.Sound = function(a, b, d, e, f) {
        void 0 === d && (d = 1), void 0 === e && (e = !1), void 0 === f && (f = a.sound.connectToMaster), this.game = a, this.name = b, this.key = b, this.loop = e, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this._globalVolume = 1, this._markedToDelete = !1, this._removeFromSoundManager = !1, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = d * this.game.sound.volume, f && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(b) && this.game.cache.isSoundReady(b) ? (this._sound = this.game.cache.getSoundData(b), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new c53.Signal, this.onPlay = new c53.Signal, this.onPause = new c53.Signal, this.onResume = new c53.Signal, this.onLoop = new c53.Signal, this.onStop = new c53.Signal, this.onMute = new c53.Signal, this.onMarkerComplete = new c53.Signal, this.onFadeComplete = new c53.Signal, this._volume = d, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1;
    }, c53.Sound.prototype = {
        soundHasUnlocked: function(a) {
            a === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration);
        },
        addMarker: function(a, b, c, d, e) {
            void 0 !== c && null !== c || (c = 1), void 0 !== d && null !== d || (d = 1), void 0 === e && (e = !1), this.markers[a] = {
                name: a,
                start: b,
                stop: b + c,
                volume: d,
                duration: c,
                durationMS: 1000 * c,
                loop: e
            };
        },
        removeMarker: function(a) {
            delete this.markers[a];
        },
        onEndedHandler: function() {
            this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop(), this._markedToDelete && (this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode), this._removeFromSoundManager ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose()));
        },
        update: function() {
            if (!this.game.cache.checkSoundKey(this.key)) return void this.destroy();
            this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()));
        },
        loopFull: function(a) {
            return this.play(null, 0, a, !0);
        },
        play: function(a, b, c, d, e) {
            if (void 0 !== a && !1 !== a && null !== a || (a = ""), void 0 === e && (e = !0), this.isPlaying && !this.allowMultiple && !e && !this.override) return this;
            if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || e)) {
                if (this.usingWebAudio) {
                    if (void 0 === this._sound.stop) this._sound.noteOff(0);
                    else try {
                        this._sound.stop(0);
                    } catch (a) {}
                    this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode);
                } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                this.isPlaying = !1;
            }
            if ("" === a && Object.keys(this.markers).length > 0) return this;
            if ("" !== a) {
                if (!this.markers[a]) return console.warn("Phaser.Sound.play: audio marker " + a + " doesn't exist"), this;
                this.currentMarker = a, this.position = this.markers[a].start, this.volume = this.markers[a].volume, this.loop = this.markers[a].loop, this.duration = this.markers[a].duration, this.durationMS = this.markers[a].durationMS, void 0 !== c && (this.volume = c), void 0 !== d && (this.loop = d), this._tempMarker = a, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop;
            } else b = b || 0, void 0 === c && (c = this._volume), void 0 === d && (d = this.loop), this.position = Math.max(0, b), this.volume = c, this.loop = d, this.duration = 0, this.durationMS = 0, this._tempMarker = a, this._tempPosition = b, this._tempVolume = c, this._tempLoop = d;
            return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === a && (this._sound.loop = !0), this.loop || "" !== a || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1000 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === a ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1000 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this;
        },
        restart: function(a, b, c, d) {
            a = a || "", b = b || 0, c = c || 1, void 0 === d && (d = !1), this.play(a, b, c, d, !0);
        },
        pause: function() {
            this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop());
        },
        resume: function() {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var a = Math.max(0, this.position + this.pausedPosition / 1000);
                    this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                    var b = this.duration - this.pausedPosition / 1000;
                    void 0 === this._sound.start ? this._sound.noteGrainOn(0, a, b) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, a) : this._sound.start(0, a, b);
                } else this._sound.currentTime = this._tempPause, this._sound.play();
                this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this);
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound) {
                if (this.usingWebAudio) {
                    if (void 0 === this._sound.stop) this._sound.noteOff(0);
                    else try {
                        this._sound.stop(0);
                    } catch (a) {}
                    this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode);
                } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
            }
            if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                var a = this.currentMarker;
                "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, a);
            }
        },
        fadeIn: function(a, b, c) {
            void 0 === b && (b = !1), void 0 === c && (c = this.currentMarker), this.paused || (this.play(c, 0, 0, b), this.fadeTo(a, 1));
        },
        fadeOut: function(a) {
            this.fadeTo(a, 0);
        },
        fadeTo: function(a, b) {
            if (this.isPlaying && !this.paused && b !== this.volume) {
                if (void 0 === a && (a = 1000), void 0 === b) return void console.warn("Phaser.Sound.fadeTo: No Volume Specified.");
                this.fadeTween = this.game.add.tween(this).to({
                    volume: b
                }, a, c53.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this);
            }
        },
        fadeComplete: function() {
            this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop();
        },
        updateGlobalVolume: function(a) {
            this.usingAudioTag && this._sound && (this._globalVolume = a, this._sound.volume = this._globalVolume * this._volume);
        },
        destroy: function(a) {
            void 0 === a && (a = !0), this._markedToDelete = !0, this._removeFromSoundManager = a, this.stop(), a ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose());
        }
    }, c53.Sound.prototype.constructor = c53.Sound, Object.defineProperty(c53.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding;
        }
    }), Object.defineProperty(c53.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key);
        }
    }), Object.defineProperty(c53.Sound.prototype, "mute", {
        get: function() {
            return this._muted || this.game.sound.mute;
        },
        set: function(a) {
            (a = a || !1) !== this._muted && (a ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this));
        }
    }), Object.defineProperty(c53.Sound.prototype, "volume", {
        get: function() {
            return this._volume;
        },
        set: function(a) {
            if (this.usingAudioTag && (a = this.game.math.clamp(a, 0, 1)), this._muted) return void (this._muteVolume = a);
            this._tempVolume = a, this._volume = a, this.usingWebAudio ? this.gainNode.gain.value = a : this.usingAudioTag && this._sound && (this._sound.volume = this._globalVolume * a);
        }
    }), c53.SoundManager = function(a) {
        this.game = a, this.onSoundDecode = new c53.Signal, this.onVolumeChange = new c53.Signal, this.onMute = new c53.Signal, this.onUnMute = new c53.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new c53.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null;
    }, c53.SoundManager.prototype = {
        boot: function() {
            if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) {
                if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void (this.touchLocked = !1);
                if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void (this.touchLocked = !1);
            }
            if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
            else if (window.AudioContext) try {
                this.context = new window.AudioContext;
            } catch (a) {
                this.context = null, this.usingWebAudio = !1, this.touchLocked = !1;
            }
            else if (window.webkitAudioContext) try {
                this.context = new window.webkitAudioContext;
            } catch (a84) {
                this.context = null, this.usingWebAudio = !1, this.touchLocked = !1;
            }
            if (null === this.context) {
                if (void 0 === window.Audio) return void (this.noAudio = !0);
                this.usingAudioTag = !0;
            } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
            this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock();
        },
        setTouchLock: function() {
            this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.device.iOSVersion > 8 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0);
        },
        unlock: function() {
            if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
            if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
            else if (this.usingWebAudio) {
                var a = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = a, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0);
            }
            return !0;
        },
        stopAll: function() {
            if (!this.noAudio) for(var a = 0; a < this._sounds.length; a++)this._sounds[a] && this._sounds[a].stop();
        },
        pauseAll: function() {
            if (!this.noAudio) for(var a = 0; a < this._sounds.length; a++)this._sounds[a] && this._sounds[a].pause();
        },
        resumeAll: function() {
            if (!this.noAudio) for(var a = 0; a < this._sounds.length; a++)this._sounds[a] && this._sounds[a].resume();
        },
        decode: function(a, b) {
            b = b || null;
            var c56 = this.game.cache.getSoundData(a);
            if (c56 && !1 === this.game.cache.isSoundDecoded(a)) {
                this.game.cache.updateSound(a, "isDecoding", !0);
                var d = this;
                try {
                    this.context.decodeAudioData(c56, function(c) {
                        c && (d.game.cache.decodedSound(a, c), d.onSoundDecode.dispatch(a, b));
                    });
                } catch (a) {}
            }
        },
        setDecodedCallback: function(a, b, d) {
            "string" == typeof a && (a = [
                a
            ]), this._watchList.reset();
            for(var e = 0; e < a.length; e++)a[e] instanceof c53.Sound ? this.game.cache.isSoundDecoded(a[e].key) || this._watchList.add(a[e].key) : this.game.cache.isSoundDecoded(a[e]) || this._watchList.add(a[e]);
            0 === this._watchList.total ? (this._watching = !1, b.call(d)) : (this._watching = !0, this._watchCallback = b, this._watchContext = d);
        },
        update: function() {
            if (!this.noAudio) {
                !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                for(var a = 0; a < this._sounds.length; a++)this._sounds[a].update();
                if (this._watching) {
                    for(var b = this._watchList.first; b;)this.game.cache.isSoundDecoded(b) && this._watchList.remove(b), b = this._watchList.next;
                    0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext));
                }
            }
        },
        add: function(a, b, d, e) {
            void 0 === b && (b = 1), void 0 === d && (d = !1), void 0 === e && (e = this.connectToMaster);
            var f = new c53.Sound(this.game, a, b, d, e);
            return this._sounds.push(f), f;
        },
        addSprite: function(a) {
            return new c53.AudioSprite(this.game, a);
        },
        remove: function(a) {
            for(var b = this._sounds.length; b--;)if (this._sounds[b] === a) return this._sounds[b].destroy(!1), this._sounds.splice(b, 1), !0;
            return !1;
        },
        removeByKey: function(a) {
            for(var b = this._sounds.length, c = 0; b--;)this._sounds[b].key === a && (this._sounds[b].destroy(!1), this._sounds.splice(b, 1), c++);
            return c;
        },
        play: function(a, b, c) {
            if (!this.noAudio) {
                var d = this.add(a, b, c);
                return d.play(), d;
            }
        },
        setMute: function() {
            if (!this._muted) {
                this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                for(var a = 0; a < this._sounds.length; a++)this._sounds[a].usingAudioTag && (this._sounds[a].mute = !0);
                this.onMute.dispatch();
            }
        },
        unsetMute: function() {
            if (this._muted && !this._codeMuted) {
                this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                for(var a = 0; a < this._sounds.length; a++)this._sounds[a].usingAudioTag && (this._sounds[a].mute = !1);
                this.onUnMute.dispatch();
            }
        },
        destroy: function() {
            this.stopAll();
            for(var a = 0; a < this._sounds.length; a++)this._sounds[a] && this._sounds[a].destroy();
            this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close());
        }
    }, c53.SoundManager.prototype.constructor = c53.SoundManager, Object.defineProperty(c53.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted;
        },
        set: function(a) {
            if (a = a || !1) {
                if (this._muted) return;
                this._codeMuted = !0, this.setMute();
            } else {
                if (!this._muted) return;
                this._codeMuted = !1, this.unsetMute();
            }
        }
    }), Object.defineProperty(c53.SoundManager.prototype, "volume", {
        get: function() {
            return this._volume;
        },
        set: function(a) {
            if (a < 0 ? a = 0 : a > 1 && (a = 1), this._volume !== a) {
                if (this._volume = a, this.usingWebAudio) this.masterGain.gain.value = a;
                else for(var b = 0; b < this._sounds.length; b++)this._sounds[b].usingAudioTag && this._sounds[b].updateGlobalVolume(a);
                this.onVolumeChange.dispatch(a);
            }
        }
    }), c53.ScaleManager = function(a, b, d) {
        this.game = a, this.dom = c53.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new c53.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new c53.Signal, this.enterIncorrectOrientation = new c53.Signal, this.leaveIncorrectOrientation = new c53.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new c53.Signal, this.onFullScreenChange = new c53.Signal, this.onFullScreenError = new c53.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new c53.Point(1, 1), this.scaleFactorInversed = new c53.Point(1, 1), this.margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            x: 0,
            y: 0
        }, this.bounds = new c53.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
            right: "layout",
            bottom: ""
        }, this.compatibility = {
            supportsFullScreen: !1,
            orientationFallback: null,
            noMargins: !1,
            scrollTo: null,
            forceMinimumDocumentHeight: !1,
            canExpandParent: !0,
            clickTrampoline: ""
        }, this._scaleMode = c53.ScaleManager.NO_SCALE, this._fullScreenScaleMode = c53.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new c53.Point(1, 1), this.trackParentInterval = 2000, this.onSizeChange = new c53.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new c53.Rectangle, this._userScaleFactor = new c53.Point(1, 1), this._userScaleTrim = new c53.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new c53.Rectangle, this._tempBounds = new c53.Rectangle, this._lastReportedCanvasSize = new c53.Rectangle, this._lastReportedGameSize = new c53.Rectangle, this._booted = !1, a.config && this.parseConfig(a.config), this.setupScale(b, d);
    }, c53.ScaleManager.EXACT_FIT = 0, c53.ScaleManager.NO_SCALE = 1, c53.ScaleManager.SHOW_ALL = 2, c53.ScaleManager.RESIZE = 3, c53.ScaleManager.USER_SCALE = 4, c53.ScaleManager.prototype = {
        boot: function() {
            var a85 = this.compatibility;
            a85.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? a85.scrollTo = new c53.Point(0, 1) : a85.scrollTo = new c53.Point(0, 0)), this.game.device.desktop ? (a85.orientationFallback = "screen", a85.clickTrampoline = "when-not-mouse") : (a85.orientationFallback = "", a85.clickTrampoline = "");
            var b = this;
            this._orientationChange = function(a) {
                return b.orientationChange(a);
            }, this._windowResize = function(a) {
                return b.windowResize(a);
            }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(a) {
                return b.fullScreenChange(a);
            }, this._fullScreenError = function(a) {
                return b.fullScreenError(a);
            }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), c53.FlexGrid && (this.grid = new c53.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null);
        },
        parseConfig: function(a) {
            void 0 !== a.scaleMode && (this._booted ? this.scaleMode = a.scaleMode : this._pendingScaleMode = a.scaleMode), void 0 !== a.fullScreenScaleMode && (this.fullScreenScaleMode = a.fullScreenScaleMode), a.fullScreenTarget && (this.fullScreenTarget = a.fullScreenTarget);
        },
        setupScale: function(a, b) {
            var d, e = new c53.Rectangle;
            "" !== this.game.parent && ("string" == typeof this.game.parent ? d = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (d = this.game.parent)), d ? (this.parentNode = d, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), e.width = this._parentBounds.width, e.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, e.width = this.dom.visualBounds.width, e.height = this.dom.visualBounds.height, this.offset.set(0, 0));
            var f = 0, g = 0;
            "number" == typeof a ? f = a : (this.parentScaleFactor.x = parseInt(a, 10) / 100, f = e.width * this.parentScaleFactor.x), "number" == typeof b ? g = b : (this.parentScaleFactor.y = parseInt(b, 10) / 100, g = e.height * this.parentScaleFactor.y), f = Math.floor(f), g = Math.floor(g), this._gameSize.setTo(0, 0, f, g), this.updateDimensions(f, g, !1);
        },
        _gameResumed: function() {
            this.queueUpdate(!0);
        },
        setGameSize: function(a, b) {
            this._gameSize.setTo(0, 0, a, b), this.currentScaleMode !== c53.ScaleManager.RESIZE && this.updateDimensions(a, b, !0), this.queueUpdate(!0);
        },
        setUserScale: function(a, b, c, d, e, f) {
            this._userScaleFactor.setTo(a, b), this._userScaleTrim.setTo(0 | c, 0 | d), void 0 === e && (e = !0), void 0 === f && (f = !0), e && this.queueUpdate(f);
        },
        setResizeCallback: function(a, b) {
            this.onResize = a, this.onResizeContext = b;
        },
        signalSizeChange: function() {
            if (!c53.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !c53.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                var a = this.width, b = this.height;
                this._lastReportedCanvasSize.setTo(0, 0, a, b), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(a, b), this.onSizeChange.dispatch(this, a, b), this.currentScaleMode === c53.ScaleManager.RESIZE && (this.game.state.resize(a, b), this.game.load.resize(a, b));
            }
        },
        setMinMax: function(a, b, c, d) {
            this.minWidth = a, this.minHeight = b, void 0 !== c && (this.maxWidth = c), void 0 !== d && (this.maxHeight = d);
        },
        preUpdate: function() {
            if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                var a = this._updateThrottle;
                this._updateThrottleReset = a >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                var b = this._parentBounds.width, d = this._parentBounds.height, e = this.getParentBounds(this._parentBounds), f = e.width !== b || e.height !== d, g = this.updateOrientationState();
                (f || g) && (this.onResize && this.onResize.call(this.onResizeContext, this, e), this.updateLayout(), this.signalSizeChange());
                var h = 2 * this._updateThrottle;
                this._updateThrottle < a && (h = Math.min(a, this._updateThrottleReset)), this._updateThrottle = c53.Math.clamp(h, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time;
            }
        },
        pauseUpdate: function() {
            this.preUpdate(), this._updateThrottle = this.trackParentInterval;
        },
        updateDimensions: function(a, b, c) {
            this.width = a * this.parentScaleFactor.x, this.height = b * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), c && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height));
        },
        updateScalingAndBounds: function() {
            this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y);
        },
        forceOrientation: function(a, b) {
            if (void 0 === b && (b = !1), !0 === a && !0 === b) return void console.warn("Phaser.ScaleManager: forceLandscape and forcePortrait cannot both be true.");
            this.forceLandscape = a, this.forcePortrait = b, this.queueUpdate(!0);
        },
        classifyOrientation: function(a) {
            return "portrait-primary" === a || "portrait-secondary" === a ? "portrait" : "landscape-primary" === a || "landscape-secondary" === a ? "landscape" : null;
        },
        updateOrientationState: function() {
            var a = this.screenOrientation, b = this.incorrectOrientation;
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
            var c = a !== this.screenOrientation, d = b !== this.incorrectOrientation;
            return d && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (c || d) && this.onOrientationChange.dispatch(this, a, b), c || d;
        },
        orientationChange: function(a) {
            this.event = a, this.queueUpdate(!0);
        },
        windowResize: function(a) {
            this.event = a, this.queueUpdate(!0);
        },
        scrollTop: function() {
            var a = this.compatibility.scrollTo;
            a && window.scrollTo(a.x, a.y);
        },
        refresh: function() {
            this.scrollTop(), this.queueUpdate(!0);
        },
        updateLayout: function() {
            var a = this.currentScaleMode;
            if (a === c53.ScaleManager.RESIZE) return void this.reflowGame();
            if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : a === c53.ScaleManager.EXACT_FIT ? this.setExactFit() : a === c53.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : a === c53.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : a === c53.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (a === c53.ScaleManager.SHOW_ALL || a === c53.ScaleManager.USER_SCALE)) {
                var b = this.getParentBounds(this._tempBounds);
                this.width = Math.min(this.width, b.width), this.height = Math.min(this.height, b.height);
            }
            this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas();
        },
        getParentBounds: function(a) {
            var b = a || new c53.Rectangle, d = this.boundingParent, e = this.dom.visualBounds, f = this.dom.layoutBounds;
            if (d) {
                var g = d.getBoundingClientRect(), h = d.offsetParent ? d.offsetParent.getBoundingClientRect() : d.getBoundingClientRect();
                b.setTo(g.left - h.left, g.top - h.top, g.width, g.height);
                var i = this.windowConstraints;
                if (i.right) {
                    var j = "layout" === i.right ? f : e;
                    b.right = Math.min(b.right, j.width);
                }
                if (i.bottom) {
                    var j = "layout" === i.bottom ? f : e;
                    b.bottom = Math.min(b.bottom, j.height);
                }
            } else b.setTo(0, 0, e.width, e.height);
            return b.setTo(Math.round(b.x), Math.round(b.y), Math.round(b.width), Math.round(b.height)), b;
        },
        alignCanvas: function(a, b) {
            var c = this.getParentBounds(this._tempBounds), d = this.game.canvas, e = this.margin;
            if (a) {
                e.left = e.right = 0;
                var f = d.getBoundingClientRect();
                if (this.width < c.width && !this.incorrectOrientation) {
                    var g = f.left - c.x, h = c.width / 2 - this.width / 2;
                    h = Math.max(h, 0);
                    var i = h - g;
                    e.left = Math.round(i);
                }
                d.style.marginLeft = e.left + "px", 0 !== e.left && (e.right = -(c.width - f.width - e.left), d.style.marginRight = e.right + "px");
            }
            if (b) {
                e.top = e.bottom = 0;
                var f = d.getBoundingClientRect();
                if (this.height < c.height && !this.incorrectOrientation) {
                    var g = f.top - c.y, h = c.height / 2 - this.height / 2;
                    h = Math.max(h, 0);
                    var i = h - g;
                    e.top = Math.round(i);
                }
                d.style.marginTop = e.top + "px", 0 !== e.top && (e.bottom = -(c.height - f.height - e.top), d.style.marginBottom = e.bottom + "px");
            }
            e.x = e.left, e.y = e.top;
        },
        reflowGame: function() {
            this.resetCanvas("", "");
            var a = this.getParentBounds(this._tempBounds);
            this.updateDimensions(a.width, a.height, !0);
        },
        reflowCanvas: function() {
            this.incorrectOrientation || (this.width = c53.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = c53.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds();
        },
        resetCanvas: function(a, b) {
            void 0 === a && (a = this.width + "px"), void 0 === b && (b = this.height + "px");
            var c = this.game.canvas;
            this.compatibility.noMargins || (c.style.marginLeft = "", c.style.marginTop = "", c.style.marginRight = "", c.style.marginBottom = ""), c.style.width = a, c.style.height = b;
        },
        queueUpdate: function(a) {
            a && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset;
        },
        reset: function(a) {
            a && this.grid && this.grid.reset();
        },
        setMaximum: function() {
            this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height;
        },
        setShowAll: function(a) {
            var b, c = this.getParentBounds(this._tempBounds), d = c.width, e = c.height;
            b = a ? Math.max(e / this.game.height, d / this.game.width) : Math.min(e / this.game.height, d / this.game.width), this.width = Math.round(this.game.width * b), this.height = Math.round(this.game.height * b);
        },
        setExactFit: function() {
            var a = this.getParentBounds(this._tempBounds);
            this.width = a.width, this.height = a.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)));
        },
        createFullScreenTarget: function() {
            var a = document.createElement("div");
            return a.style.margin = "0", a.style.padding = "0", a.style.background = "#000", a;
        },
        startFullScreen: function(a, b) {
            if (this.isFullScreen) return !1;
            if (!this.compatibility.supportsFullScreen) {
                var d = this;
                return void setTimeout(function() {
                    d.fullScreenError();
                }, 10);
            }
            if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                var e = this.game.input;
                if (e.activePointer && e.activePointer !== e.mousePointer && (b || !1 !== b)) return void e.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [
                    a,
                    !1
                ]);
            }
            void 0 !== a && this.game.renderType === c53.CANVAS && (this.game.stage.smoothed = a);
            var f = this.fullScreenTarget;
            f || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), f = this._createdFullScreenTarget);
            var g = {
                targetElement: f
            };
            if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, g), this._createdFullScreenTarget) {
                var h = this.game.canvas;
                h.parentNode.insertBefore(f, h), f.appendChild(h);
            }
            return this.game.device.fullscreenKeyboard ? f[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : f[this.game.device.requestFullscreen](), !0;
        },
        stopFullScreen: function() {
            return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0);
        },
        cleanupCreatedTarget: function() {
            var a = this._createdFullScreenTarget;
            if (a && a.parentNode) {
                var b = a.parentNode;
                b.insertBefore(this.game.canvas, a), b.removeChild(a);
            }
            this._createdFullScreenTarget = null;
        },
        prepScreenMode: function(a) {
            var b = !!this._createdFullScreenTarget, d = this._createdFullScreenTarget || this.fullScreenTarget;
            a ? (b || this.fullScreenScaleMode === c53.ScaleManager.EXACT_FIT) && d !== this.game.canvas && (this._fullScreenRestore = {
                targetWidth: d.style.width,
                targetHeight: d.style.height
            }, d.style.width = "100%", d.style.height = "100%") : (this._fullScreenRestore && (d.style.width = this._fullScreenRestore.targetWidth, d.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas());
        },
        fullScreenChange: function(a) {
            this.event = a, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height);
        },
        fullScreenError: function(a) {
            this.event = a, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this);
        },
        scaleSprite: function(a, b, c, d) {
            if (void 0 === b && (b = this.width), void 0 === c && (c = this.height), void 0 === d && (d = !1), !a || !a.scale) return a;
            if (a.scale.x = 1, a.scale.y = 1, a.width <= 0 || a.height <= 0 || b <= 0 || c <= 0) return a;
            var e = b, f = a.height * b / a.width, g = a.width * c / a.height, h = c, i = g > b;
            return i = i ? d : !d, i ? (a.width = Math.floor(e), a.height = Math.floor(f)) : (a.width = Math.floor(g), a.height = Math.floor(h)), a;
        },
        destroy: function() {
            this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1));
        }
    }, c53.ScaleManager.prototype.constructor = c53.ScaleManager, Object.defineProperty(c53.ScaleManager.prototype, "boundingParent", {
        get: function() {
            return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null;
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "scaleMode", {
        get: function() {
            return this._scaleMode;
        },
        set: function(a) {
            return a !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = a), this._scaleMode;
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "fullScreenScaleMode", {
        get: function() {
            return this._fullScreenScaleMode;
        },
        set: function(a) {
            return a !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = a, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = a), this._fullScreenScaleMode;
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "currentScaleMode", {
        get: function() {
            return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode;
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "pageAlignHorizontally", {
        get: function() {
            return this._pageAlignHorizontally;
        },
        set: function(a) {
            a !== this._pageAlignHorizontally && (this._pageAlignHorizontally = a, this.queueUpdate(!0));
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "pageAlignVertically", {
        get: function() {
            return this._pageAlignVertically;
        },
        set: function(a) {
            a !== this._pageAlignVertically && (this._pageAlignVertically = a, this.queueUpdate(!0));
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "isFullScreen", {
        get: function() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return "portrait" === this.classifyOrientation(this.screenOrientation);
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return "landscape" === this.classifyOrientation(this.screenOrientation);
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "isGamePortrait", {
        get: function() {
            return this.height > this.width;
        }
    }), Object.defineProperty(c53.ScaleManager.prototype, "isGameLandscape", {
        get: function() {
            return this.width > this.height;
        }
    }), c53.Utils.Debug = function(a) {
        this.game = a, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.lineWidth = 1, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1, this.isDisabled = !1, this._line = null, this._rect = null;
    }, c53.Utils.Debug.prototype = {
        boot: function() {
            this.game.renderType === c53.CANVAS ? this.context = this.game.context : (this.bmd = new c53.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = c53.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d")), this._line = new c53.Line, this._rect = new c53.Rectangle;
        },
        resize: function(a, b, c) {
            this.bmd.resize(b, c), this.canvas.width = b, this.canvas.height = c;
        },
        preUpdate: function() {
            this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1);
        },
        reset: function() {
            this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear();
        },
        start: function(a, b, c, d) {
            "number" != typeof a && (a = 0), "number" != typeof b && (b = 0), c = c || "rgb(255,255,255)", void 0 === d && (d = 0), this.currentX = a, this.currentY = b, this.currentColor = c, this.columnWidth = d, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = c, this.context.fillStyle = c, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha;
        },
        stop: function() {
            this.context.restore();
        },
        line: function() {
            for(var a = this.currentX, b = 0; b < arguments.length; b++)this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[b], a + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[b], a, this.currentY), a += this.columnWidth;
            this.currentY += this.lineHeight;
        },
        soundInfo: function(a, b, c, d) {
            this.start(b, c, d), this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback), this.line("Decoded: " + a.isDecoded + " Decoding: " + a.isDecoding), this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying), this.line("Time: " + a.currentTime), this.line("Volume: " + a.volume + " Muted: " + a.mute), this.line("WebAudio: " + a.usingWebAudio + " Audio: " + a.usingAudioTag), "" !== a.currentMarker && (this.line("Marker: " + a.currentMarker + " Duration: " + a.duration + " (ms: " + a.durationMS + ")"), this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop), this.line("Position: " + a.position)), this.stop();
        },
        camera: function(a, b, c) {
            var d = a.deadzone, e = a.target, f = a.view;
            d && (this._rect.setTo(f.x + d.x, f.y + d.y, d.width, d.height), this.rectangle(this._rect, b, c)), e && (this._line.setTo(f.centerX, f.centerY, e.x, e.y), this.geom(this._line, b, c), this.geom(e, b, !1, 3));
        },
        cameraInfo: function(a, b, c, d) {
            var e = a.bounds, f = a.deadzone, g = a.target, h = a.view;
            this.start(b, c, d), this.line("Camera (" + a.width + " x " + a.height + ")"), this.line("x: " + a.x + " y: " + a.y), e && this.line("Bounds x: " + e.x + " y: " + e.y + " w: " + e.width + " h: " + e.height), this.line("View x: " + h.x + " y: " + h.y + " w: " + h.width + " h: " + h.height), this.line("Deadzone: " + (f ? "x: " + f.x + " y: " + f.y + " w: " + f.width + " h: " + f.height : f)), this.line("Total in view: " + a.totalInView), this.line("At limit: x: " + a.atLimit.x + " y: " + a.atLimit.y), this.line("Target: " + (g ? g.name || g : g)), this.stop();
        },
        timer: function(a, b, c, d) {
            this.start(b, c, d), this.line("Timer (running: " + a.running + " expired: " + a.expired + ")"), this.line("Next Tick: " + a.next + " Duration: " + a.duration), this.line("Paused: " + a.paused + " Length: " + a.length), this.stop();
        },
        pointer: function(a, b, c, d, e) {
            null != a && (void 0 === b && (b = !1), c = c || "rgba(0,255,0,0.5)", d = d || "rgba(255,0,0,0.5)", !0 === b && !0 === a.isUp || (this.start(a.x, a.y - 100, e), this.context.beginPath(), this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI), a.active ? this.context.fillStyle = c : this.context.fillStyle = d, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(a.positionDown.x, a.positionDown.y), this.context.lineTo(a.position.x, a.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + a.id + " Active: " + a.active), this.line("World X: " + a.worldX + " World Y: " + a.worldY), this.line("Screen X: " + a.x + " Screen Y: " + a.y + " In: " + a.withinGame), this.line("Duration: " + a.duration + " ms"), this.line("is Down: " + a.isDown + " is Up: " + a.isUp), this.stop()));
        },
        spriteInputInfo: function(a, b, c, d) {
            this.start(b, c, d), this.line("Sprite Input: (" + a.width + " x " + a.height + ")"), this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1)), this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0)), this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0)), this.line("just over: " + a.input.justOver() + " just out: " + a.input.justOut()), this.stop();
        },
        key: function(a, b, c, d) {
            this.start(b, c, d, 150), this.line("Key:", a.keyCode, "isDown:", a.isDown), this.line("justDown:", a.justDown, "justUp:", a.justUp), this.line("Time Down:", a.timeDown.toFixed(0), "duration:", a.duration.toFixed(0)), this.stop();
        },
        inputInfo: function(a, b, c) {
            this.start(a, b, c), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop();
        },
        spriteBounds: function(a, b, c) {
            var d = a.getBounds();
            d.x += this.game.camera.x, d.y += this.game.camera.y, this.rectangle(d, b, c);
        },
        ropeSegments: function(a86, b, c) {
            var d = this;
            a86.segments.forEach(function(a) {
                d.rectangle(a, b, c);
            }, this);
        },
        spriteInfo: function(a, b, c, d) {
            this.start(b, c, d), this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y), this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1)), this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1)), this.line("visible: " + a.visible + " in camera: " + a.inCamera), this.line("bounds x: " + a._bounds.x.toFixed(1) + " y: " + a._bounds.y.toFixed(1) + " w: " + a._bounds.width.toFixed(1) + " h: " + a._bounds.height.toFixed(1)), this.stop();
        },
        spriteCoords: function(a, b, c, d) {
            this.start(b, c, d, 100), a.name && this.line(a.name), this.line("x:", a.x.toFixed(2), "y:", a.y.toFixed(2)), this.line("pos x:", a.position.x.toFixed(2), "pos y:", a.position.y.toFixed(2)), this.line("world x:", a.world.x.toFixed(2), "world y:", a.world.y.toFixed(2)), this.stop();
        },
        lineInfo: function(a, b, c, d) {
            this.start(b, c, d, 80), this.line("start.x:", a.start.x.toFixed(2), "start.y:", a.start.y.toFixed(2)), this.line("end.x:", a.end.x.toFixed(2), "end.y:", a.end.y.toFixed(2)), this.line("length:", a.length.toFixed(2), "angle:", a.angle), this.stop();
        },
        pixel: function(a, b, c, d) {
            d = d || 2, this.start(), this.context.fillStyle = c, this.context.fillRect(a, b, d, d), this.stop();
        },
        geom: function(a, b, d, e) {
            void 0 === d && (d = !0), void 0 === e && (e = 0), b = b || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = b, this.context.strokeStyle = b, this.context.lineWidth = this.lineWidth, a instanceof c53.Rectangle || 1 === e ? d ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : a instanceof c53.Circle || 2 === e ? (this.context.beginPath(), this.context.arc(a.x - this.game.camera.x, a.y - this.game.camera.y, a.radius, 0, 2 * Math.PI, !1), this.context.closePath(), d ? this.context.fill() : this.context.stroke()) : a instanceof c53.Point || 3 === e ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, 4, 4) : (a instanceof c53.Line || 4 === e) && (this.context.beginPath(), this.context.moveTo(a.start.x + 0.5 - this.game.camera.x, a.start.y + 0.5 - this.game.camera.y), this.context.lineTo(a.end.x + 0.5 - this.game.camera.x, a.end.y + 0.5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop();
        },
        rectangle: function(a, b, c) {
            void 0 === c && (c = !0), b = b || "rgba(0, 255, 0, 0.4)", this.start(), c ? (this.context.fillStyle = b, this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)) : (this.context.lineWidth = this.lineWidth, this.context.strokeStyle = b, this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)), this.stop();
        },
        text: function(a, b, c, d, e) {
            d = d || "rgb(255,255,255)", e = e || "16px Courier", this.start(), this.context.font = e, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(a, b + 1, c + 1)), this.context.fillStyle = d, this.context.fillText(a, b, c), this.stop();
        },
        quadTree: function(a, b) {
            b = b || "rgba(255,0,0,0.3)", this.start();
            var c = a.bounds;
            if (0 === a.nodes.length) {
                this.context.strokeStyle = b, this.context.strokeRect(c.x, c.y, c.width, c.height), this.text("size: " + a.objects.length, c.x + 4, c.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                for(var d = 0; d < a.objects.length; d++)this.context.strokeRect(a.objects[d].x, a.objects[d].y, a.objects[d].width, a.objects[d].height);
            } else for(var d = 0; d < a.nodes.length; d++)this.quadTree(a.nodes[d]);
            this.stop();
        },
        body: function(a, b, d) {
            a.body && (this.start(), a.body.type === c53.Physics.ARCADE ? c53.Physics.Arcade.Body.render(this.context, a.body, b, d, this.lineWidth) : a.body.type === c53.Physics.NINJA ? c53.Physics.Ninja.Body.render(this.context, a.body, b, d) : a.body.type === c53.Physics.BOX2D && c53.Physics.Box2D.renderBody(this.context, a.body, b), this.stop());
        },
        bodyInfo: function(a, b, d, e) {
            a.body && (this.start(b, d, e, 210), a.body.type === c53.Physics.ARCADE ? c53.Physics.Arcade.Body.renderBodyInfo(this, a.body) : a.body.type === c53.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, a.body), this.stop());
        },
        box2dWorld: function() {
            this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop();
        },
        box2dBody: function(a, b) {
            this.start(), c53.Physics.Box2D.renderBody(this.context, a, b), this.stop();
        },
        displayList: function(a) {
            if (void 0 === a && (a = this.game.world), a.hasOwnProperty("renderOrderID") ? console.log("[" + a.renderOrderID + "]", a) : console.log("[]", a), a.children && a.children.length > 0) for(var b = 0; b < a.children.length; b++)this.game.debug.displayList(a.children[b]);
        },
        renderer: function(a, b, c) {
            var d = this.game.renderer, e = d.renderSession;
            if (this.start(a, b, c), this.line((d.gl ? "WebGL" : "Canvas") + " Renderer (" + d.width + " x " + d.height + ")"), this.line("autoResize: " + d.autoResize), this.line("clearBeforeRender: " + d.clearBeforeRender), this.line("resolution: " + d.resolution), this.line("transparent: " + d.transparent), d.gl) {
                this.line("drawCount: " + e.drawCount), this.line("flushCount: " + e.flushCount), this.line("maxTextures: " + d.maxTextures), this.line("maxTextureSize: " + d.maxTextureSize), this.line("maxTextureAvailableSpace: " + e.maxTextureAvailableSpace), this.line("currentBatchedTextures: (" + d.currentBatchedTextures.length + ")");
                for(var f = 0; f < d.currentBatchedTextures.length; f++)this.line("  " + d.currentBatchedTextures[f]);
            } else this.line("roundPixels: " + e.roundPixels), this.line("scaleMode: " + (0 === e.scaleMode ? "LINEAR" : 1 === e.scaleMode ? "NEAREST" : e.scaleMode));
            this.stop();
        },
        destroy: function() {
            c53.CanvasPool.remove(this);
        }
    }, c53.Utils.Debug.prototype.constructor = c53.Utils.Debug, c53.DOM = {
        getOffset: function(a, b) {
            b = b || new c53.Point;
            var d = a.getBoundingClientRect(), e = c53.DOM.scrollY, f = c53.DOM.scrollX, g = document.documentElement.clientTop, h = document.documentElement.clientLeft;
            return b.x = d.left + f - h, b.y = d.top + e - g, b;
        },
        getBounds: function(a, b) {
            return void 0 === b && (b = 0), !(!(a = a && !a.nodeType ? a[0] : a) || 1 !== a.nodeType) && this.calibrate(a.getBoundingClientRect(), b);
        },
        calibrate: function(a, b) {
            b = +b || 0;
            var c = {
                width: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            return c.width = (c.right = a.right + b) - (c.left = a.left - b), c.height = (c.bottom = a.bottom + b) - (c.top = a.top - b), c;
        },
        getAspectRatio: function(a) {
            a = null == a ? this.visualBounds : 1 === a.nodeType ? this.getBounds(a) : a;
            var b = a.width, c = a.height;
            return "function" == typeof b && (b = b.call(a)), "function" == typeof c && (c = c.call(a)), b / c;
        },
        inLayoutViewport: function(a, b) {
            var c = this.getBounds(a, b);
            return !!c && c.bottom >= 0 && c.right >= 0 && c.top <= this.layoutBounds.width && c.left <= this.layoutBounds.height;
        },
        getScreenOrientation: function(a) {
            var b = window.screen, c = b.orientation || b.mozOrientation || b.msOrientation;
            if (c && "string" == typeof c.type) return c.type;
            if ("string" == typeof c) return c;
            var d = "portrait-primary", e = "landscape-primary";
            if ("screen" === a) return b.height > b.width ? d : e;
            if ("viewport" === a) return this.visualBounds.height > this.visualBounds.width ? d : e;
            if ("window.orientation" === a && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? d : e;
            if (window.matchMedia) {
                if (window.matchMedia("(orientation: portrait)").matches) return d;
                if (window.matchMedia("(orientation: landscape)").matches) return e;
            }
            return this.visualBounds.height > this.visualBounds.width ? d : e;
        },
        visualBounds: new c53.Rectangle,
        layoutBounds: new c53.Rectangle,
        documentBounds: new c53.Rectangle
    }, c53.Device.whenReady(function(a87) {
        var b69 = window && "pageXOffset" in window ? function() {
            return window.pageXOffset;
        } : function() {
            return document.documentElement.scrollLeft;
        }, d = window && "pageYOffset" in window ? function() {
            return window.pageYOffset;
        } : function() {
            return document.documentElement.scrollTop;
        };
        if (Object.defineProperty(c53.DOM, "scrollX", {
            get: b69
        }), Object.defineProperty(c53.DOM, "scrollY", {
            get: d
        }), Object.defineProperty(c53.DOM.visualBounds, "x", {
            get: b69
        }), Object.defineProperty(c53.DOM.visualBounds, "y", {
            get: d
        }), Object.defineProperty(c53.DOM.layoutBounds, "x", {
            value: 0
        }), Object.defineProperty(c53.DOM.layoutBounds, "y", {
            value: 0
        }), a87.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
            var e = function() {
                return Math.max(window.innerWidth, document.documentElement.clientWidth);
            }, f = function() {
                return Math.max(window.innerHeight, document.documentElement.clientHeight);
            };
            Object.defineProperty(c53.DOM.visualBounds, "width", {
                get: e
            }), Object.defineProperty(c53.DOM.visualBounds, "height", {
                get: f
            }), Object.defineProperty(c53.DOM.layoutBounds, "width", {
                get: e
            }), Object.defineProperty(c53.DOM.layoutBounds, "height", {
                get: f
            });
        } else Object.defineProperty(c53.DOM.visualBounds, "width", {
            get: function() {
                return window.innerWidth;
            }
        }), Object.defineProperty(c53.DOM.visualBounds, "height", {
            get: function() {
                return window.innerHeight;
            }
        }), Object.defineProperty(c53.DOM.layoutBounds, "width", {
            get: function() {
                var a = document.documentElement.clientWidth, b = window.innerWidth;
                return a < b ? b : a;
            }
        }), Object.defineProperty(c53.DOM.layoutBounds, "height", {
            get: function() {
                var a = document.documentElement.clientHeight, b = window.innerHeight;
                return a < b ? b : a;
            }
        });
        Object.defineProperty(c53.DOM.documentBounds, "x", {
            value: 0
        }), Object.defineProperty(c53.DOM.documentBounds, "y", {
            value: 0
        }), Object.defineProperty(c53.DOM.documentBounds, "width", {
            get: function() {
                var a = document.documentElement;
                return Math.max(a.clientWidth, a.offsetWidth, a.scrollWidth);
            }
        }), Object.defineProperty(c53.DOM.documentBounds, "height", {
            get: function() {
                var a = document.documentElement;
                return Math.max(a.clientHeight, a.offsetHeight, a.scrollHeight);
            }
        });
    }, null, !0), c53.ArraySet = function(a) {
        this.position = 0, this.list = a || [];
    }, c53.ArraySet.prototype = {
        add: function(a) {
            return this.exists(a) || this.list.push(a), a;
        },
        getIndex: function(a) {
            return this.list.indexOf(a);
        },
        getByKey: function(a, b) {
            for(var c = this.list.length; c--;)if (this.list[c][a] === b) return this.list[c];
            return null;
        },
        exists: function(a) {
            return this.list.indexOf(a) > -1;
        },
        reset: function() {
            this.list.length = 0;
        },
        remove: function(a) {
            var b = this.list.indexOf(a);
            if (b > -1) return this.list.splice(b, 1), a;
        },
        setAll: function(a, b) {
            for(var c = this.list.length; c--;)this.list[c] && (this.list[c][a] = b);
        },
        callAll: function(a) {
            for(var b = Array.prototype.slice.call(arguments, 1), c = this.list.length; c--;)this.list[c] && this.list[c][a] && this.list[c][a].apply(this.list[c], b);
        },
        removeAll: function(a) {
            void 0 === a && (a = !1);
            for(var b = this.list.length; b--;)if (this.list[b]) {
                var c = this.remove(this.list[b]);
                a && c.destroy();
            }
            this.position = 0, this.list = [];
        }
    }, Object.defineProperty(c53.ArraySet.prototype, "total", {
        get: function() {
            return this.list.length;
        }
    }), Object.defineProperty(c53.ArraySet.prototype, "first", {
        get: function() {
            return this.position = 0, this.list.length > 0 ? this.list[0] : null;
        }
    }), Object.defineProperty(c53.ArraySet.prototype, "next", {
        get: function() {
            return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
        }
    }), c53.ArraySet.prototype.constructor = c53.ArraySet, c53.ArrayUtils = {
        getRandomItem: function(a, b, c) {
            if (null === a) return null;
            void 0 === b && (b = 0), void 0 === c && (c = a.length);
            var d = b + Math.floor(Math.random() * c);
            return void 0 === a[d] ? null : a[d];
        },
        removeRandomItem: function(a, b, c) {
            if (null == a) return null;
            void 0 === b && (b = 0), void 0 === c && (c = a.length);
            var d = b + Math.floor(Math.random() * c);
            if (d < a.length) {
                var e = a.splice(d, 1);
                return void 0 === e[0] ? null : e[0];
            }
            return null;
        },
        shuffle: function(a) {
            for(var b = a.length - 1; b > 0; b--){
                var c = Math.floor(Math.random() * (b + 1)), d = a[b];
                a[b] = a[c], a[c] = d;
            }
            return a;
        },
        transposeMatrix: function(a) {
            for(var b = a.length, c = a[0].length, d = new Array(c), e = 0; e < c; e++){
                d[e] = new Array(b);
                for(var f = b - 1; f > -1; f--)d[e][f] = a[f][e];
            }
            return d;
        },
        rotateMatrix: function(a, b) {
            if ("string" != typeof b && (b = (b % 360 + 360) % 360), 90 === b || -270 === b || "rotateLeft" === b) a = c53.ArrayUtils.transposeMatrix(a), a = a.reverse();
            else if (-90 === b || 270 === b || "rotateRight" === b) a = a.reverse(), a = c53.ArrayUtils.transposeMatrix(a);
            else if (180 === Math.abs(b) || "rotate180" === b) {
                for(var d = 0; d < a.length; d++)a[d].reverse();
                a = a.reverse();
            }
            return a;
        },
        findClosest: function(a, b) {
            if (!b.length) return NaN;
            if (1 === b.length || a < b[0]) return b[0];
            for(var c = 1; b[c] < a;)c++;
            var d = b[c - 1], e = c < b.length ? b[c] : Number.POSITIVE_INFINITY;
            return e - a <= a - d ? e : d;
        },
        rotateRight: function(a) {
            var b = a.pop();
            return a.unshift(b), b;
        },
        rotateLeft: function(a) {
            var b = a.shift();
            return a.push(b), b;
        },
        rotate: function(a) {
            var b = a.shift();
            return a.push(b), b;
        },
        numberArray: function(a, b) {
            for(var c = [], d = a; d <= b; d++)c.push(d);
            return c;
        },
        numberArrayStep: function(a, b, d) {
            void 0 !== a && null !== a || (a = 0), void 0 !== b && null !== b || (b = a, a = 0), void 0 === d && (d = 1);
            for(var e = [], f = Math.max(c53.Math.roundAwayFromZero((b - a) / (d || 1)), 0), g = 0; g < f; g++)e.push(a), a += d;
            return e;
        }
    }, c53.LinkedList = function() {
        this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0;
    }, c53.LinkedList.prototype = {
        add: function(a) {
            return 0 === this.total && null === this.first && null === this.last ? (this.first = a, this.last = a, this.next = a, a.prev = this, this.total++, a) : (this.last.next = a, a.prev = this.last, this.last = a, this.total++, a);
        },
        reset: function() {
            this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0;
        },
        remove: function(a) {
            if (1 === this.total) return this.reset(), void (a.next = a.prev = null);
            a === this.first ? this.first = this.first.next : a === this.last && (this.last = this.last.prev), a.prev && (a.prev.next = a.next), a.next && (a.next.prev = a.prev), a.next = a.prev = null, null === this.first && (this.last = null), this.total--;
        },
        callAll: function(a) {
            if (this.first && this.last) {
                var b = this.first;
                do b && b[a] && b[a].call(b), b = b.next;
                while (b !== this.last.next)
            }
        }
    }, c53.LinkedList.prototype.constructor = c53.LinkedList, c53.Create = function(a) {
        this.game = a, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [
            {
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            },
            {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            },
            {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            },
            {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            },
            {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }
        ];
    }, c53.Create.PALETTE_ARNE = 0, c53.Create.PALETTE_JMP = 1, c53.Create.PALETTE_CGA = 2, c53.Create.PALETTE_C64 = 3, c53.Create.PALETTE_JAPANESE_MACHINE = 4, c53.Create.prototype = {
        texture: function(a, b, c, d, e, f, g, h) {
            void 0 === c && (c = 8), void 0 === d && (d = c), void 0 === e && (e = 0), void 0 === f && (f = !0);
            var i = b[0].length * c, j = b.length * d;
            null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(i, j), this.bmd.clear();
            for(var k = 0; k < b.length; k++)for(var l = b[k], m = 0; m < l.length; m++){
                var n = l[m];
                "." !== n && " " !== n && (this.ctx.fillStyle = this.palettes[e][n], this.ctx.fillRect(m * c, k * d, c, d));
            }
            return f ? this.bmd.generateTexture(a, g, h) : this.copy();
        },
        grid: function(a, b, c, d, e, f, g, h, i) {
            void 0 === g && (g = !0), null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(b, c), this.ctx.fillStyle = f;
            for(var j = 0; j < c; j += e)this.ctx.fillRect(0, j, b, 1);
            for(var k = 0; k < b; k += d)this.ctx.fillRect(k, 0, 1, c);
            return g ? this.bmd.generateTexture(a, h, i) : this.copy();
        },
        copy: function(a, b, c, d, e, f, g) {
            return null == a && (a = this.game.make.bitmapData()), a.resize(this.bmd.width, this.bmd.height), a.draw(this.bmd, b, c, d, e, f, g);
        }
    }, c53.Create.prototype.constructor = c53.Create, c53.FlexGrid = function(a, b, d) {
        this.game = a.game, this.manager = a, this.width = b, this.height = d, this.boundsCustom = new c53.Rectangle(0, 0, b, d), this.boundsFluid = new c53.Rectangle(0, 0, b, d), this.boundsFull = new c53.Rectangle(0, 0, b, d), this.boundsNone = new c53.Rectangle(0, 0, b, d), this.positionCustom = new c53.Point(0, 0), this.positionFluid = new c53.Point(0, 0), this.positionFull = new c53.Point(0, 0), this.positionNone = new c53.Point(0, 0), this.scaleCustom = new c53.Point(1, 1), this.scaleFluid = new c53.Point(1, 1), this.scaleFluidInversed = new c53.Point(1, 1), this.scaleFull = new c53.Point(1, 1), this.scaleNone = new c53.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = b / d, this.ratioV = d / b, this.multiplier = 0, this.layers = [];
    }, c53.FlexGrid.prototype = {
        setSize: function(a, b) {
            this.width = a, this.height = b, this.ratioH = a / b, this.ratioV = b / a, this.scaleNone = new c53.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh();
        },
        createCustomLayer: function(a, b, d, e) {
            void 0 === e && (e = !0), this.customWidth = a, this.customHeight = b, this.boundsCustom.width = a, this.boundsCustom.height = b;
            var f = new c53.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
            return e && this.game.world.add(f), this.layers.push(f), void 0 !== d && true && f.addMultiple(d), f;
        },
        createFluidLayer: function(a, b) {
            void 0 === b && (b = !0);
            var d = new c53.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
            return b && this.game.world.add(d), this.layers.push(d), void 0 !== a && true && d.addMultiple(a), d;
        },
        createFullLayer: function(a) {
            var b = new c53.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
            return this.game.world.add(b), this.layers.push(b), void 0 !== a && b.addMultiple(a), b;
        },
        createFixedLayer: function(a) {
            var b = new c53.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
            return this.game.world.add(b), this.layers.push(b), void 0 !== a && b.addMultiple(a), b;
        },
        reset: function() {
            for(var a = this.layers.length; a--;)this.layers[a].persist || (this.layers[a].position = null, this.layers[a].scale = null, this.layers.slice(a, 1));
        },
        onResize: function(a, b) {
            this.ratioH = a / b, this.ratioV = b / a, this.refresh(a, b);
        },
        refresh: function() {
            this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
        },
        fitSprite: function(a) {
            this.manager.scaleSprite(a), a.x = this.manager.bounds.centerX, a.y = this.manager.bounds.centerY;
        },
        debug: function() {
            this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1);
        }
    }, c53.FlexGrid.prototype.constructor = c53.FlexGrid, c53.FlexLayer = function(a, b, d, e) {
        c53.Group.call(this, a.game, null, "__flexLayer" + a.game.rnd.uuid(), !1), this.manager = a.manager, this.grid = a, this.persist = !1, this.position = b, this.bounds = d, this.scale = e, this.topLeft = d.topLeft, this.topMiddle = new c53.Point(d.halfWidth, 0), this.topRight = d.topRight, this.bottomLeft = d.bottomLeft, this.bottomMiddle = new c53.Point(d.halfWidth, d.bottom), this.bottomRight = d.bottomRight;
    }, c53.FlexLayer.prototype = Object.create(c53.Group.prototype), c53.FlexLayer.prototype.constructor = c53.FlexLayer, c53.FlexLayer.prototype.resize = function() {}, c53.FlexLayer.prototype.debug = function() {
        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
    }, c53.Color = {
        packPixel: function(a, b, d, e) {
            return c53.Device.LITTLE_ENDIAN ? (e << 24 | d << 16 | b << 8 | a) >>> 0 : (a << 24 | b << 16 | d << 8 | e) >>> 0;
        },
        unpackPixel: function(a, b, d, e) {
            return void 0 !== b && null !== b || (b = c53.Color.createColor()), void 0 !== d && null !== d || (d = !1), void 0 !== e && null !== e || (e = !1), c53.Device.LITTLE_ENDIAN ? (b.a = (4278190080 & a) >>> 24, b.b = (16711680 & a) >>> 16, b.g = (65280 & a) >>> 8, b.r = 255 & a) : (b.r = (4278190080 & a) >>> 24, b.g = (16711680 & a) >>> 16, b.b = (65280 & a) >>> 8, b.a = 255 & a), b.color = a, b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a / 255 + ")", d && c53.Color.RGBtoHSL(b.r, b.g, b.b, b), e && c53.Color.RGBtoHSV(b.r, b.g, b.b, b), b;
        },
        fromRGBA: function(a, b) {
            return b || (b = c53.Color.createColor()), b.r = (4278190080 & a) >>> 24, b.g = (16711680 & a) >>> 16, b.b = (65280 & a) >>> 8, b.a = 255 & a, b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a + ")", b;
        },
        toRGBA: function(a, b, c, d) {
            return a << 24 | b << 16 | c << 8 | d;
        },
        toABGR: function(a, b, c, d) {
            return (d << 24 | c << 16 | b << 8 | a) >>> 0;
        },
        hexToRGBArray: function(a) {
            return [
                (a >> 16 & 255) / 255,
                (a >> 8 & 255) / 255,
                (255 & a) / 255
            ];
        },
        RGBArrayToHex: function(a) {
            return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
        },
        RGBtoHSL: function(a, b, d, e) {
            e || (e = c53.Color.createColor(a, b, d, 1)), a /= 255, b /= 255, d /= 255;
            var f = Math.min(a, b, d), g = Math.max(a, b, d);
            if (e.h = 0, e.s = 0, e.l = (g + f) / 2, g !== f) {
                var h = g - f;
                e.s = e.l > 0.5 ? h / (2 - g - f) : h / (g + f), g === a ? e.h = (b - d) / h + (b < d ? 6 : 0) : g === b ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - b) / h + 4), e.h /= 6;
            }
            return e;
        },
        HSLtoRGB: function(a, b, d, e) {
            if (e ? (e.r = d, e.g = d, e.b = d) : e = c53.Color.createColor(d, d, d), 0 !== b) {
                var f = d < 0.5 ? d * (1 + b) : d + b - d * b, g = 2 * d - f;
                e.r = c53.Color.hueToColor(g, f, a + 1 / 3), e.g = c53.Color.hueToColor(g, f, a), e.b = c53.Color.hueToColor(g, f, a - 1 / 3);
            }
            return e.r = Math.floor(255 * e.r | 0), e.g = Math.floor(255 * e.g | 0), e.b = Math.floor(255 * e.b | 0), c53.Color.updateColor(e), e;
        },
        RGBtoHSV: function(a, b, d, e) {
            e || (e = c53.Color.createColor(a, b, d, 255)), a /= 255, b /= 255, d /= 255;
            var f = Math.min(a, b, d), g = Math.max(a, b, d), h = g - f;
            return e.h = 0, e.s = 0 === g ? 0 : h / g, e.v = g, g !== f && (g === a ? e.h = (b - d) / h + (b < d ? 6 : 0) : g === b ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - b) / h + 4), e.h /= 6), e;
        },
        HSVtoRGB: function(a, b, d, e) {
            void 0 === e && (e = c53.Color.createColor(0, 0, 0, 1, a, b, 0, d));
            var f, g, h, i = Math.floor(6 * a), j = 6 * a - i, k = d * (1 - b), l = d * (1 - j * b), m = d * (1 - (1 - j) * b);
            switch(i % 6){
                case 0:
                    f = d, g = m, h = k;
                    break;
                case 1:
                    f = l, g = d, h = k;
                    break;
                case 2:
                    f = k, g = d, h = m;
                    break;
                case 3:
                    f = k, g = l, h = d;
                    break;
                case 4:
                    f = m, g = k, h = d;
                    break;
                case 5:
                    f = d, g = k, h = l;
            }
            return e.r = Math.floor(255 * f), e.g = Math.floor(255 * g), e.b = Math.floor(255 * h), c53.Color.updateColor(e), e;
        },
        hueToColor: function(a, b, c) {
            return c < 0 && (c += 1), c > 1 && (c -= 1), c < 1 / 6 ? a + 6 * (b - a) * c : c < 0.5 ? b : c < 2 / 3 ? a + (b - a) * (2 / 3 - c) * 6 : a;
        },
        createColor: function(a, b, d, e, f, g, h, i) {
            var j = {
                r: a || 0,
                g: b || 0,
                b: d || 0,
                a: e || 1,
                h: f || 0,
                s: g || 0,
                l: h || 0,
                v: i || 0,
                color: 0,
                color32: 0,
                rgba: ""
            };
            return c53.Color.updateColor(j);
        },
        updateColor: function(a) {
            return a.rgba = "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + a.a.toString() + ")", a.color = c53.Color.getColor(a.r, a.g, a.b), a.color32 = c53.Color.getColor32(255 * a.a, a.r, a.g, a.b), a;
        },
        getColor32: function(a, b, c, d) {
            return a << 24 | b << 16 | c << 8 | d;
        },
        getColor: function(a, b, c) {
            return a << 16 | b << 8 | c;
        },
        RGBtoString: function(a, b, d, e, f) {
            return void 0 === e && (e = 255), void 0 === f && (f = "#"), "#" === f ? "#" + (16777216 + (a << 16) + (b << 8) + d).toString(16).slice(1) : "0x" + c53.Color.componentToHex(e) + c53.Color.componentToHex(a) + c53.Color.componentToHex(b) + c53.Color.componentToHex(d);
        },
        hexToRGB: function(a) {
            var b = c53.Color.hexToColor(a);
            if (b) return c53.Color.getColor32(b.a, b.r, b.g, b.b);
        },
        hexToColor: function(a, b70) {
            a = a.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, b, c, d) {
                return b + b + c + c + d + d;
            });
            var d47 = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
            if (d47) {
                var e = parseInt(d47[1], 16), f = parseInt(d47[2], 16), g = parseInt(d47[3], 16);
                b70 ? (b70.r = e, b70.g = f, b70.b = g) : b70 = c53.Color.createColor(e, f, g);
            }
            return b70;
        },
        webToColor: function(a, b) {
            b || (b = c53.Color.createColor());
            var d = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(a);
            return d && (b.r = parseInt(d[1], 10), b.g = parseInt(d[2], 10), b.b = parseInt(d[3], 10), b.a = void 0 !== d[4] ? parseFloat(d[4]) : 1, c53.Color.updateColor(b)), b;
        },
        valueToColor: function(a, b) {
            if (b || (b = c53.Color.createColor()), "string" == typeof a) return 0 === a.indexOf("rgb") ? c53.Color.webToColor(a, b) : (b.a = 1, c53.Color.hexToColor(a, b));
            if ("number" == typeof a) {
                var d = c53.Color.getRGB(a);
                return b.r = d.r, b.g = d.g, b.b = d.b, b.a = d.a / 255, b;
            }
            return b;
        },
        componentToHex: function(a) {
            var b = a.toString(16);
            return 1 === b.length ? "0" + b : b;
        },
        HSVColorWheel: function(a, b) {
            void 0 === a && (a = 1), void 0 === b && (b = 1);
            for(var d = [], e = 0; e <= 359; e++)d.push(c53.Color.HSVtoRGB(e / 359, a, b));
            return d;
        },
        HSLColorWheel: function(a, b) {
            void 0 === a && (a = 0.5), void 0 === b && (b = 0.5);
            for(var d = [], e = 0; e <= 359; e++)d.push(c53.Color.HSLtoRGB(e / 359, a, b));
            return d;
        },
        interpolateColor: function(a, b, d, e, f) {
            void 0 === f && (f = 255);
            var g = c53.Color.getRGB(a), h = c53.Color.getRGB(b), i = (h.red - g.red) * e / d + g.red, j = (h.green - g.green) * e / d + g.green, k = (h.blue - g.blue) * e / d + g.blue;
            return c53.Color.getColor32(f, i, j, k);
        },
        interpolateColorWithRGB: function(a, b, d, e, f, g) {
            var h = c53.Color.getRGB(a), i = (b - h.red) * g / f + h.red, j = (d - h.green) * g / f + h.green, k = (e - h.blue) * g / f + h.blue;
            return c53.Color.getColor(i, j, k);
        },
        interpolateRGB: function(a, b, d, e, f, g, h, i) {
            var j = (e - a) * i / h + a, k = (f - b) * i / h + b, l = (g - d) * i / h + d;
            return c53.Color.getColor(j, k, l);
        },
        getRandomColor: function(a, b, d) {
            if (void 0 === a && (a = 0), void 0 === b && (b = 255), void 0 === d && (d = 255), b > 255 || a > b) return c53.Color.getColor(255, 255, 255);
            var e = a + Math.round(Math.random() * (b - a)), f = a + Math.round(Math.random() * (b - a)), g = a + Math.round(Math.random() * (b - a));
            return c53.Color.getColor32(d, e, f, g);
        },
        getRGB: function(a) {
            return a > 16777215 ? {
                alpha: a >>> 24,
                red: a >> 16 & 255,
                green: a >> 8 & 255,
                blue: 255 & a,
                a: a >>> 24,
                r: a >> 16 & 255,
                g: a >> 8 & 255,
                b: 255 & a
            } : {
                alpha: 255,
                red: a >> 16 & 255,
                green: a >> 8 & 255,
                blue: 255 & a,
                a: 255,
                r: a >> 16 & 255,
                g: a >> 8 & 255,
                b: 255 & a
            };
        },
        getWebRGB: function(a) {
            if ("object" == typeof a) return "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + (a.a / 255).toString() + ")";
            var b = c53.Color.getRGB(a);
            return "rgba(" + b.r.toString() + "," + b.g.toString() + "," + b.b.toString() + "," + (b.a / 255).toString() + ")";
        },
        getAlpha: function(a) {
            return a >>> 24;
        },
        getAlphaFloat: function(a) {
            return (a >>> 24) / 255;
        },
        getRed: function(a) {
            return a >> 16 & 255;
        },
        getGreen: function(a) {
            return a >> 8 & 255;
        },
        getBlue: function(a) {
            return 255 & a;
        },
        blendNormal: function(a) {
            return a;
        },
        blendLighten: function(a, b) {
            return b > a ? b : a;
        },
        blendDarken: function(a, b) {
            return b > a ? a : b;
        },
        blendMultiply: function(a, b) {
            return a * b / 255;
        },
        blendAverage: function(a, b) {
            return (a + b) / 2;
        },
        blendAdd: function(a, b) {
            return Math.min(255, a + b);
        },
        blendSubtract: function(a, b) {
            return Math.max(0, a + b - 255);
        },
        blendDifference: function(a, b) {
            return Math.abs(a - b);
        },
        blendNegation: function(a, b) {
            return 255 - Math.abs(255 - a - b);
        },
        blendScreen: function(a, b) {
            return 255 - ((255 - a) * (255 - b) >> 8);
        },
        blendExclusion: function(a, b) {
            return a + b - 2 * a * b / 255;
        },
        blendOverlay: function(a, b) {
            return b < 128 ? 2 * a * b / 255 : 255 - 2 * (255 - a) * (255 - b) / 255;
        },
        blendSoftLight: function(a, b) {
            return b < 128 ? 2 * (64 + (a >> 1)) * (b / 255) : 255 - 2 * (255 - (64 + (a >> 1))) * (255 - b) / 255;
        },
        blendHardLight: function(a, b) {
            return c53.Color.blendOverlay(b, a);
        },
        blendColorDodge: function(a, b) {
            return 255 === b ? b : Math.min(255, (a << 8) / (255 - b));
        },
        blendColorBurn: function(a, b) {
            return 0 === b ? b : Math.max(0, 255 - (255 - a << 8) / b);
        },
        blendLinearDodge: function(a, b) {
            return c53.Color.blendAdd(a, b);
        },
        blendLinearBurn: function(a, b) {
            return c53.Color.blendSubtract(a, b);
        },
        blendLinearLight: function(a, b) {
            return b < 128 ? c53.Color.blendLinearBurn(a, 2 * b) : c53.Color.blendLinearDodge(a, 2 * (b - 128));
        },
        blendVividLight: function(a, b) {
            return b < 128 ? c53.Color.blendColorBurn(a, 2 * b) : c53.Color.blendColorDodge(a, 2 * (b - 128));
        },
        blendPinLight: function(a, b) {
            return b < 128 ? c53.Color.blendDarken(a, 2 * b) : c53.Color.blendLighten(a, 2 * (b - 128));
        },
        blendHardMix: function(a, b) {
            return c53.Color.blendVividLight(a, b) < 128 ? 0 : 255;
        },
        blendReflect: function(a, b) {
            return 255 === b ? b : Math.min(255, a * a / (255 - b));
        },
        blendGlow: function(a, b) {
            return c53.Color.blendReflect(b, a);
        },
        blendPhoenix: function(a, b) {
            return Math.min(a, b) - Math.max(a, b) + 255;
        }
    }, c53.Physics = function(a, b) {
        b = b || {}, this.game = a, this.config = b, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig();
    }, c53.Physics.ARCADE = 0, c53.Physics.P2JS = 1, c53.Physics.NINJA = 2, c53.Physics.BOX2D = 3, c53.Physics.CHIPMUNK = 4, c53.Physics.MATTERJS = 5, c53.Physics.prototype = {
        parseConfig: function() {
            this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !c53.Physics.hasOwnProperty("Arcade") || (this.arcade = new c53.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && c53.Physics.hasOwnProperty("Ninja") && (this.ninja = new c53.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && c53.Physics.hasOwnProperty("P2") && (this.p2 = new c53.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && c53.Physics.hasOwnProperty("BOX2D") && (this.box2d = new c53.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && c53.Physics.hasOwnProperty("Matter") && (this.matter = new c53.Physics.Matter(this.game, this.config));
        },
        startSystem: function(a) {
            a === c53.Physics.ARCADE ? this.arcade = new c53.Physics.Arcade(this.game) : a === c53.Physics.P2JS ? null === this.p2 ? this.p2 = new c53.Physics.P2(this.game, this.config) : this.p2.reset() : a === c53.Physics.NINJA ? this.ninja = new c53.Physics.Ninja(this.game) : a === c53.Physics.BOX2D ? null === this.box2d ? this.box2d = new c53.Physics.Box2D(this.game, this.config) : this.box2d.reset() : a === c53.Physics.MATTERJS && (null === this.matter ? this.matter = new c53.Physics.Matter(this.game, this.config) : this.matter.reset());
        },
        enable: function(a, b, d) {
            void 0 === b && (b = c53.Physics.ARCADE), void 0 === d && (d = !1), b === c53.Physics.ARCADE ? this.arcade.enable(a) : b === c53.Physics.P2JS && this.p2 ? this.p2.enable(a, d) : b === c53.Physics.NINJA && this.ninja ? this.ninja.enableAABB(a) : b === c53.Physics.BOX2D && this.box2d ? this.box2d.enable(a) : b === c53.Physics.MATTERJS && this.matter ? this.matter.enable(a) : console.warn(a.key + " is attempting to enable a physics body using an unknown physics system.");
        },
        preUpdate: function() {
            this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate();
        },
        update: function() {
            this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update();
        },
        setBoundsToWorld: function() {
            this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld();
        },
        clear: function() {
            this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear();
        },
        reset: function() {
            this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset();
        },
        destroy: function() {
            this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null;
        }
    }, c53.Physics.prototype.constructor = c53.Physics, c53.Physics.Arcade = function(a) {
        this.game = a, this.gravity = new c53.Point, this.bounds = new c53.Rectangle(0, 0, a.world.width, a.world.height), this.checkCollision = {
            up: !0,
            down: !0,
            left: !0,
            right: !0
        }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = c53.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new c53.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld();
    }, c53.Physics.Arcade.prototype.constructor = c53.Physics.Arcade, c53.Physics.Arcade.SORT_NONE = 0, c53.Physics.Arcade.LEFT_RIGHT = 1, c53.Physics.Arcade.RIGHT_LEFT = 2, c53.Physics.Arcade.TOP_BOTTOM = 3, c53.Physics.Arcade.BOTTOM_TOP = 4, c53.Physics.Arcade.prototype = {
        setBounds: function(a, b, c, d) {
            this.bounds.setTo(a, b, c, d);
        },
        setBoundsToWorld: function() {
            this.bounds.copyFrom(this.game.world.bounds);
        },
        enable: function(a, b) {
            void 0 === b && (b = !0);
            var d = 1;
            if (Array.isArray(a)) for(d = a.length; d--;)a[d] instanceof c53.Group ? this.enable(a[d].children, b) : (this.enableBody(a[d]), b && a[d].hasOwnProperty("children") && a[d].children.length > 0 && this.enable(a[d], !0));
            else a instanceof c53.Group ? this.enable(a.children, b) : (this.enableBody(a), b && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, !0));
        },
        enableBody: function(a) {
            a.hasOwnProperty("body") && null === a.body && (a.body = new c53.Physics.Arcade.Body(a), a.parent && a.parent instanceof c53.Group && a.parent.addToHash(a));
        },
        updateMotion: function(a) {
            if (a.allowRotation) {
                var b = this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag, a.maxAngular) - a.angularVelocity;
                a.angularVelocity += b, a.rotation += a.angularVelocity * this.game.time.physicsElapsed;
            }
            a.velocity.x = this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x), a.velocity.y = this.computeVelocity(2, a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y);
        },
        computeVelocity: function(a, b, c, d, e, f) {
            return void 0 === f && (f = 10000), 1 === a && b.allowGravity ? c += (this.gravity.x + b.gravity.x) * this.game.time.physicsElapsed : 2 === a && b.allowGravity && (c += (this.gravity.y + b.gravity.y) * this.game.time.physicsElapsed), d ? c += d * this.game.time.physicsElapsed : e && b.allowDrag && (e *= this.game.time.physicsElapsed, c - e > 0 ? c -= e : c + e < 0 ? c += e : c = 0), c > f ? c = f : c < -f && (c = -f), c;
        },
        overlap: function(a, b, c, d, e) {
            if (c = c || null, d = d || null, e = e || c, this._total = 0, !Array.isArray(a) && Array.isArray(b)) for(var f = 0; f < b.length; f++)this.collideHandler(a, b[f], c, d, e, !0);
            else if (Array.isArray(a) && !Array.isArray(b)) for(var f = 0; f < a.length; f++)this.collideHandler(a[f], b, c, d, e, !0);
            else if (Array.isArray(a) && Array.isArray(b)) for(var f = 0; f < a.length; f++)for(var g = 0; g < b.length; g++)this.collideHandler(a[f], b[g], c, d, e, !0);
            else this.collideHandler(a, b, c, d, e, !0);
            return this._total > 0;
        },
        collide: function(a, b, c, d, e) {
            if (c = c || null, d = d || null, e = e || c, this._total = 0, !Array.isArray(a) && Array.isArray(b)) for(var f = 0; f < b.length; f++)this.collideHandler(a, b[f], c, d, e, !1);
            else if (Array.isArray(a) && !Array.isArray(b)) for(var f = 0; f < a.length; f++)this.collideHandler(a[f], b, c, d, e, !1);
            else if (Array.isArray(a) && Array.isArray(b)) for(var f = 0; f < a.length; f++)for(var g = 0; g < b.length; g++)this.collideHandler(a[f], b[g], c, d, e, !1);
            else this.collideHandler(a, b, c, d, e, !1);
            return this._total > 0;
        },
        sortLeftRight: function(a, b) {
            return a.body && b.body ? a.body.x - b.body.x : 0;
        },
        sortRightLeft: function(a, b) {
            return a.body && b.body ? b.body.x - a.body.x : 0;
        },
        sortTopBottom: function(a, b) {
            return a.body && b.body ? a.body.y - b.body.y : 0;
        },
        sortBottomTop: function(a, b) {
            return a.body && b.body ? b.body.y - a.body.y : 0;
        },
        sort: function(a, b) {
            null !== a.physicsSortDirection ? b = a.physicsSortDirection : void 0 === b && (b = this.sortDirection), b === c53.Physics.Arcade.LEFT_RIGHT ? a.hash.sort(this.sortLeftRight) : b === c53.Physics.Arcade.RIGHT_LEFT ? a.hash.sort(this.sortRightLeft) : b === c53.Physics.Arcade.TOP_BOTTOM ? a.hash.sort(this.sortTopBottom) : b === c53.Physics.Arcade.BOTTOM_TOP && a.hash.sort(this.sortBottomTop);
        },
        collideHandler: function(a, b, d, e, f, g) {
            if (void 0 === b && a.physicsType === c53.GROUP) return this.sort(a), void this.collideGroupVsSelf(a, d, e, f, g);
            a && b && a.exists && b.exists && (this.sortDirection !== c53.Physics.Arcade.SORT_NONE && (a.physicsType === c53.GROUP && this.sort(a), b.physicsType === c53.GROUP && this.sort(b)), a.physicsType === c53.SPRITE ? b.physicsType === c53.SPRITE ? this.collideSpriteVsSprite(a, b, d, e, f, g) : b.physicsType === c53.GROUP ? this.collideSpriteVsGroup(a, b, d, e, f, g) : b.physicsType === c53.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(a, b, d, e, f, g) : a.physicsType === c53.GROUP ? b.physicsType === c53.SPRITE ? this.collideSpriteVsGroup(b, a, d, e, f, g) : b.physicsType === c53.GROUP ? this.collideGroupVsGroup(a, b, d, e, f, g) : b.physicsType === c53.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f, g) : a.physicsType === c53.TILEMAPLAYER && (b.physicsType === c53.SPRITE ? this.collideSpriteVsTilemapLayer(b, a, d, e, f, g) : b.physicsType === c53.GROUP && this.collideGroupVsTilemapLayer(b, a, d, e, f, g)));
        },
        collideSpriteVsSprite: function(a, b, c, d, e, f) {
            return !(!a.body || !b.body) && (this.separate(a.body, b.body, d, e, f) && (c && c.call(e, a, b), this._total++), !0);
        },
        collideSpriteVsGroup: function(a, b, d, e, f, g) {
            if (0 !== b.length && a.body) {
                if (this.skipQuadTree || a.body.skipQuadTree) for(var h = {}, i = 0; i < b.hash.length; i++){
                    var j = b.hash[i];
                    if (j && j.exists && j.body) {
                        if (h = j.body.getBounds(h), this.sortDirection === c53.Physics.Arcade.LEFT_RIGHT) {
                            if (a.body.right < h.x) break;
                            if (h.right < a.body.x) continue;
                        } else if (this.sortDirection === c53.Physics.Arcade.RIGHT_LEFT) {
                            if (a.body.x > h.right) break;
                            if (h.x > a.body.right) continue;
                        } else if (this.sortDirection === c53.Physics.Arcade.TOP_BOTTOM) {
                            if (a.body.bottom < h.y) break;
                            if (h.bottom < a.body.y) continue;
                        } else if (this.sortDirection === c53.Physics.Arcade.BOTTOM_TOP) {
                            if (a.body.y > h.bottom) break;
                            if (h.y > a.body.bottom) continue;
                        }
                        this.collideSpriteVsSprite(a, j, d, e, f, g);
                    }
                }
                else {
                    this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(b);
                    for(var k = this.quadTree.retrieve(a), i = 0; i < k.length; i++)this.separate(a.body, k[i], e, f, g) && (d && d.call(f, a, k[i].sprite), this._total++);
                }
            }
        },
        collideGroupVsSelf: function(a, b, d, e, f) {
            if (0 !== a.length) for(var g = 0; g < a.hash.length; g++){
                var h = {}, i = a.hash[g];
                if (i && i.exists && i.body) {
                    h = i.body.getBounds(h);
                    for(var j = g + 1; j < a.hash.length; j++){
                        var k = {}, l = a.hash[j];
                        if (l && l.exists && l.body) {
                            if (k = l.body.getBounds(k), this.sortDirection === c53.Physics.Arcade.LEFT_RIGHT) {
                                if (h.right < k.x) break;
                                if (k.right < h.x) continue;
                            } else if (this.sortDirection === c53.Physics.Arcade.RIGHT_LEFT) {
                                if (h.x > k.right) continue;
                                if (k.x > h.right) break;
                            } else if (this.sortDirection === c53.Physics.Arcade.TOP_BOTTOM) {
                                if (h.bottom < k.y) continue;
                                if (k.bottom < h.y) break;
                            } else if (this.sortDirection === c53.Physics.Arcade.BOTTOM_TOP) {
                                if (h.y > k.bottom) continue;
                                if (k.y > i.body.bottom) break;
                            }
                            this.collideSpriteVsSprite(i, l, b, d, e, f);
                        }
                    }
                }
            }
        },
        collideGroupVsGroup: function(a, b, d, e, f, g) {
            if (0 !== a.length && 0 !== b.length) for(var h = 0; h < a.children.length; h++)a.children[h].exists && (a.children[h].physicsType === c53.GROUP ? this.collideGroupVsGroup(a.children[h], b, d, e, f, g) : this.collideSpriteVsGroup(a.children[h], b, d, e, f, g));
        },
        separate: function(a, b, c, d, e) {
            if (!a.enable || !b.enable || a.checkCollision.none || b.checkCollision.none || !this.intersects(a, b)) return !1;
            if (c && !1 === c.call(d, a.sprite, b.sprite)) return !1;
            if (a.isCircle && b.isCircle) return this.separateCircle(a, b, e);
            if (a.isCircle !== b.isCircle) {
                var f = a.isCircle ? b : a, g = a.isCircle ? a : b, h = {
                    x: f.x,
                    y: f.y,
                    right: f.right,
                    bottom: f.bottom
                }, i = g.center;
                if ((i.y < h.y || i.y > h.bottom) && (i.x < h.x || i.x > h.right)) return this.separateCircle(a, b, e);
            }
            var j = !1, k = !1;
            this.forceX || Math.abs(this.gravity.y + a.gravity.y) < Math.abs(this.gravity.x + a.gravity.x) ? (j = this.separateX(a, b, e), this.intersects(a, b) && (k = this.separateY(a, b, e))) : (k = this.separateY(a, b, e), this.intersects(a, b) && (j = this.separateX(a, b, e)));
            var l = j || k;
            return l && (e ? (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite), b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite)) : (a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite), b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite))), l;
        },
        intersects: function(a, b) {
            return a !== b && (a.isCircle ? b.isCircle ? c53.Math.distance(a.center.x, a.center.y, b.center.x, b.center.y) <= a.halfWidth + b.halfWidth : this.circleBodyIntersects(a, b) : b.isCircle ? this.circleBodyIntersects(b, a) : !(a.right <= b.position.x) && !(a.bottom <= b.position.y) && !(a.position.x >= b.right) && !(a.position.y >= b.bottom));
        },
        circleBodyIntersects: function(a, b) {
            var d = c53.Math.clamp(a.center.x, b.left, b.right), e = c53.Math.clamp(a.center.y, b.top, b.bottom);
            return (a.center.x - d) * (a.center.x - d) + (a.center.y - e) * (a.center.y - e) <= a.halfWidth * a.halfWidth;
        },
        separateCircle: function(a, b, d) {
            this.getOverlapX(a, b), this.getOverlapY(a, b);
            var e = b.center.x - a.center.x, f = b.center.y - a.center.y, g = Math.atan2(f, e), h = 0;
            if (a.isCircle !== b.isCircle) {
                var i = {
                    x: b.isCircle ? a.position.x : b.position.x,
                    y: b.isCircle ? a.position.y : b.position.y,
                    right: b.isCircle ? a.right : b.right,
                    bottom: b.isCircle ? a.bottom : b.bottom
                }, j = {
                    x: a.isCircle ? a.center.x : b.center.x,
                    y: a.isCircle ? a.center.y : b.center.y,
                    radius: a.isCircle ? a.halfWidth : b.halfWidth
                };
                j.y < i.y ? j.x < i.x ? h = c53.Math.distance(j.x, j.y, i.x, i.y) - j.radius : j.x > i.right && (h = c53.Math.distance(j.x, j.y, i.right, i.y) - j.radius) : j.y > i.bottom && (j.x < i.x ? h = c53.Math.distance(j.x, j.y, i.x, i.bottom) - j.radius : j.x > i.right && (h = c53.Math.distance(j.x, j.y, i.right, i.bottom) - j.radius)), h *= -1;
            } else h = a.halfWidth + b.halfWidth - c53.Math.distance(a.center.x, a.center.y, b.center.x, b.center.y);
            if (d || 0 === h || a.immovable && b.immovable || a.customSeparateX || b.customSeparateX) return 0 !== h && (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite), b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite)), 0 !== h;
            var k = {
                x: a.velocity.x * Math.cos(g) + a.velocity.y * Math.sin(g),
                y: a.velocity.x * Math.sin(g) - a.velocity.y * Math.cos(g)
            }, l = {
                x: b.velocity.x * Math.cos(g) + b.velocity.y * Math.sin(g),
                y: b.velocity.x * Math.sin(g) - b.velocity.y * Math.cos(g)
            }, m = ((a.mass - b.mass) * k.x + 2 * b.mass * l.x) / (a.mass + b.mass), n = (2 * a.mass * k.x + (b.mass - a.mass) * l.x) / (a.mass + b.mass);
            return a.immovable || (a.velocity.x = (m * Math.cos(g) - k.y * Math.sin(g)) * a.bounce.x, a.velocity.y = (k.y * Math.cos(g) + m * Math.sin(g)) * a.bounce.y), b.immovable || (b.velocity.x = (n * Math.cos(g) - l.y * Math.sin(g)) * b.bounce.x, b.velocity.y = (l.y * Math.cos(g) + n * Math.sin(g)) * b.bounce.y), Math.abs(g) < Math.PI / 2 ? a.velocity.x > 0 && !a.immovable && b.velocity.x > a.velocity.x ? a.velocity.x *= -1 : b.velocity.x < 0 && !b.immovable && a.velocity.x < b.velocity.x ? b.velocity.x *= -1 : a.velocity.y > 0 && !a.immovable && b.velocity.y > a.velocity.y ? a.velocity.y *= -1 : b.velocity.y < 0 && !b.immovable && a.velocity.y < b.velocity.y && (b.velocity.y *= -1) : Math.abs(g) > Math.PI / 2 && (a.velocity.x < 0 && !a.immovable && b.velocity.x < a.velocity.x ? a.velocity.x *= -1 : b.velocity.x > 0 && !b.immovable && a.velocity.x > b.velocity.x ? b.velocity.x *= -1 : a.velocity.y < 0 && !a.immovable && b.velocity.y < a.velocity.y ? a.velocity.y *= -1 : b.velocity.y > 0 && !b.immovable && a.velocity.x > b.velocity.y && (b.velocity.y *= -1)), a.immovable || (a.x += a.velocity.x * this.game.time.physicsElapsed - h * Math.cos(g), a.y += a.velocity.y * this.game.time.physicsElapsed - h * Math.sin(g)), b.immovable || (b.x += b.velocity.x * this.game.time.physicsElapsed + h * Math.cos(g), b.y += b.velocity.y * this.game.time.physicsElapsed + h * Math.sin(g)), a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite), b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite), !0;
        },
        getOverlapX: function(a, b, c) {
            var d = 0, e = a.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS;
            return 0 === a.deltaX() && 0 === b.deltaX() ? (a.embedded = !0, b.embedded = !0) : a.deltaX() > b.deltaX() ? (d = a.right - b.x, d > e && !c || !1 === a.checkCollision.right || !1 === b.checkCollision.left ? d = 0 : (a.touching.none = !1, a.touching.right = !0, b.touching.none = !1, b.touching.left = !0)) : a.deltaX() < b.deltaX() && (d = a.x - b.width - b.x, -d > e && !c || !1 === a.checkCollision.left || !1 === b.checkCollision.right ? d = 0 : (a.touching.none = !1, a.touching.left = !0, b.touching.none = !1, b.touching.right = !0)), a.overlapX = d, b.overlapX = d, d;
        },
        getOverlapY: function(a, b, c) {
            var d = 0, e = a.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS;
            return 0 === a.deltaY() && 0 === b.deltaY() ? (a.embedded = !0, b.embedded = !0) : a.deltaY() > b.deltaY() ? (d = a.bottom - b.y, d > e && !c || !1 === a.checkCollision.down || !1 === b.checkCollision.up ? d = 0 : (a.touching.none = !1, a.touching.down = !0, b.touching.none = !1, b.touching.up = !0)) : a.deltaY() < b.deltaY() && (d = a.y - b.bottom, -d > e && !c || !1 === a.checkCollision.up || !1 === b.checkCollision.down ? d = 0 : (a.touching.none = !1, a.touching.up = !0, b.touching.none = !1, b.touching.down = !0)), a.overlapY = d, b.overlapY = d, d;
        },
        separateX: function(a, b, c) {
            var d = this.getOverlapX(a, b, c);
            if (c || 0 === d || a.immovable && b.immovable || a.customSeparateX || b.customSeparateX) return 0 !== d || a.embedded && b.embedded;
            var e = a.velocity.x, f = b.velocity.x;
            if (a.immovable || b.immovable) a.immovable ? (b.x += d, b.velocity.x = e - f * b.bounce.x, a.moves && (b.y += (a.y - a.prev.y) * a.friction.y)) : (a.x -= d, a.velocity.x = f - e * a.bounce.x, b.moves && (a.y += (b.y - b.prev.y) * b.friction.y));
            else {
                d *= 0.5, a.x -= d, b.x += d;
                var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1), h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1), i = 0.5 * (g + h);
                g -= i, h -= i, a.velocity.x = i + g * a.bounce.x, b.velocity.x = i + h * b.bounce.x;
            }
            return !0;
        },
        separateY: function(a, b, c) {
            var d = this.getOverlapY(a, b, c);
            if (c || 0 === d || a.immovable && b.immovable || a.customSeparateY || b.customSeparateY) return 0 !== d || a.embedded && b.embedded;
            var e = a.velocity.y, f = b.velocity.y;
            if (a.immovable || b.immovable) a.immovable ? (b.y += d, b.velocity.y = e - f * b.bounce.y, a.moves && (b.x += (a.x - a.prev.x) * a.friction.x)) : (a.y -= d, a.velocity.y = f - e * a.bounce.y, b.moves && (a.x += (b.x - b.prev.x) * b.friction.x));
            else {
                d *= 0.5, a.y -= d, b.y += d;
                var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1), h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1), i = 0.5 * (g + h);
                g -= i, h -= i, a.velocity.y = i + g * a.bounce.y, b.velocity.y = i + h * b.bounce.y;
            }
            return !0;
        },
        getObjectsUnderPointer: function(a, b, c, d) {
            if (0 !== b.length && a.exists) return this.getObjectsAtLocation(a.x, a.y, b, c, d, a);
        },
        getObjectsAtLocation: function(a, b, d, e, f, g) {
            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(d);
            for(var h = new c53.Rectangle(a, b, 1, 1), i = [], j = this.quadTree.retrieve(h), k = 0; k < j.length; k++)j[k].hitTest(a, b) && (e && e.call(f, g, j[k].sprite), i.push(j[k].sprite));
            return i;
        },
        moveToObject: function(a, b, c, d) {
            void 0 === c && (c = 60), void 0 === d && (d = 0);
            var e = Math.atan2(b.y - a.y, b.x - a.x);
            return d > 0 && (c = this.distanceBetween(a, b) / (d / 1000)), a.body.velocity.setToPolar(e, c), e;
        },
        moveToPointer: function(a, b, c, d) {
            void 0 === b && (b = 60), c = c || this.game.input.activePointer, void 0 === d && (d = 0);
            var e = this.angleToPointer(a, c);
            return d > 0 && (b = this.distanceToPointer(a, c) / (d / 1000)), a.body.velocity.setToPolar(e, b), e;
        },
        moveToXY: function(a, b, c, d, e) {
            void 0 === d && (d = 60), void 0 === e && (e = 0);
            var f = Math.atan2(c - a.y, b - a.x);
            return e > 0 && (d = this.distanceToXY(a, b, c) / (e / 1000)), a.body.velocity.setToPolar(f, d), f;
        },
        velocityFromAngle: function(a, b, d) {
            return void 0 === b && (b = 60), d = d || new c53.Point, d.setToPolar(a, b, !0);
        },
        velocityFromRotation: function(a, b, d) {
            return void 0 === b && (b = 60), d = d || new c53.Point, d.setToPolar(a, b);
        },
        accelerationFromRotation: function(a, b, d) {
            return void 0 === b && (b = 60), d = d || new c53.Point, d.setToPolar(a, b);
        },
        accelerateToObject: function(a, b, c, d, e) {
            void 0 === c && (c = 60), void 0 === d && (d = 1000), void 0 === e && (e = 1000);
            var f = this.angleBetween(a, b);
            return a.body.acceleration.setToPolar(f, c), a.body.maxVelocity.setTo(d, e), f;
        },
        accelerateToPointer: function(a, b, c, d, e) {
            void 0 === c && (c = 60), void 0 === b && (b = this.game.input.activePointer), void 0 === d && (d = 1000), void 0 === e && (e = 1000);
            var f = this.angleToPointer(a, b);
            return a.body.acceleration.setToPolar(f, c), a.body.maxVelocity.setTo(d, e), f;
        },
        accelerateToXY: function(a, b, c, d, e, f) {
            void 0 === d && (d = 60), void 0 === e && (e = 1000), void 0 === f && (f = 1000);
            var g = this.angleToXY(a, b, c);
            return a.body.acceleration.setTo(g, d), a.body.maxVelocity.setTo(e, f), g;
        },
        distanceBetween: function(a, b, c) {
            void 0 === c && (c = !1);
            var d = c ? a.world.x - b.world.x : a.x - b.x, e = c ? a.world.y - b.world.y : a.y - b.y;
            return Math.sqrt(d * d + e * e);
        },
        distanceToXY: function(a, b, c, d) {
            void 0 === d && (d = !1);
            var e = d ? a.world.x - b : a.x - b, f = d ? a.world.y - c : a.y - c;
            return Math.sqrt(e * e + f * f);
        },
        distanceToPointer: function(a, b, c) {
            void 0 === b && (b = this.game.input.activePointer), void 0 === c && (c = !1);
            var d = c ? a.world.x - b.worldX : a.x - b.worldX, e = c ? a.world.y - b.worldY : a.y - b.worldY;
            return Math.sqrt(d * d + e * e);
        },
        angleBetween: function(a, b, c) {
            return void 0 === c && (c = !1), c ? Math.atan2(b.world.y - a.world.y, b.world.x - a.world.x) : Math.atan2(b.y - a.y, b.x - a.x);
        },
        angleBetweenCenters: function(a, b) {
            var c = b.centerX - a.centerX, d = b.centerY - a.centerY;
            return Math.atan2(d, c);
        },
        angleToXY: function(a, b, c, d) {
            return void 0 === d && (d = !1), d ? Math.atan2(c - a.world.y, b - a.world.x) : Math.atan2(c - a.y, b - a.x);
        },
        angleToPointer: function(a, b, c) {
            return void 0 === b && (b = this.game.input.activePointer), void 0 === c && (c = !1), c ? Math.atan2(b.worldY - a.world.y, b.worldX - a.world.x) : Math.atan2(b.worldY - a.y, b.worldX - a.x);
        },
        worldAngleToPointer: function(a, b) {
            return this.angleToPointer(a, b, !0);
        }
    }, c53.Physics.Arcade.Body = function(a) {
        this.sprite = a, this.game = a.game, this.type = c53.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new c53.Point, this.position = new c53.Point(a.x, a.y), this.prev = new c53.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = a.angle, this.preRotation = a.angle, this.width = a.width, this.height = a.height, this.sourceWidth = a.width, this.sourceHeight = a.height, a.texture && (this.sourceWidth = a.texture.frame.width, this.sourceHeight = a.texture.frame.height), this.halfWidth = Math.abs(a.width / 2), this.halfHeight = Math.abs(a.height / 2), this.center = new c53.Point(a.x + this.halfWidth, a.y + this.halfHeight), this.velocity = new c53.Point, this.newVelocity = new c53.Point, this.deltaMax = new c53.Point, this.acceleration = new c53.Point, this.allowDrag = !0, this.drag = new c53.Point, this.allowGravity = !0, this.gravity = new c53.Point, this.bounce = new c53.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new c53.Point(10000, 10000), this.friction = new c53.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1000, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = c53.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
            none: !1,
            up: !0,
            down: !0,
            left: !0,
            right: !0
        }, this.touching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        }, this.wasTouching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        }, this.blocked = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        }, this.tilePadding = new c53.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new c53.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = a.scale.x, this._sy = a.scale.y, this._dx = 0, this._dy = 0;
    }, c53.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            if (this.syncBounds) {
                var a = this.sprite.getBounds();
                a.ceilAll(), a.width === this.width && a.height === this.height || (this.width = a.width, this.height = a.height, this._reset = !0);
            } else {
                var b = Math.abs(this.sprite.scale.x), c = Math.abs(this.sprite.scale.y);
                b === this._sx && c === this._sy || (this.width = this.sourceWidth * b, this.height = this.sourceHeight * c, this._sx = b, this._sy = c, this._reset = !0);
            }
            this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter());
        },
        updateCenter: function() {
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        preUpdate: function() {
            this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.none = !0, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.updateCenter(), this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.updateCenter(), this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1);
        },
        updateMovement: function() {
            var a = 0, b = 0 !== this.overlapX || 0 !== this.overlapY;
            if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, a = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), a = this.moveTarget.length / this.moveDistance), this.movementCallback) var c = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, a);
            return !(b || a >= 1 || void 0 !== c && !0 !== c) || (this.stopMovement(a >= 1 || this.stopVelocityOnCollide && b), !1);
        },
        stopMovement: function(a) {
            this.isMoving && (this.isMoving = !1, a && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY));
        },
        postUpdate: function() {
            this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = c53.LEFT : this.deltaX() > 0 && (this.facing = c53.RIGHT), this.deltaY() < 0 ? this.facing = c53.UP : this.deltaY() > 0 && (this.facing = c53.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.updateCenter(), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y);
        },
        checkWorldBounds: function() {
            var a = this.position, b = this.game.physics.arcade.bounds, c = this.game.physics.arcade.checkCollision, d = this.worldBounce ? -this.worldBounce.x : -this.bounce.x, e = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
            return a.x < b.x && c.left ? (a.x = b.x, this.velocity.x *= d, this.blocked.left = !0, this.blocked.none = !1) : this.right > b.right && c.right && (a.x = b.right - this.width, this.velocity.x *= d, this.blocked.right = !0, this.blocked.none = !1), a.y < b.y && c.up ? (a.y = b.y, this.velocity.y *= e, this.blocked.up = !0, this.blocked.none = !1) : this.bottom > b.bottom && c.down && (a.y = b.bottom - this.height, this.velocity.y *= e, this.blocked.down = !0, this.blocked.none = !1), !this.blocked.none;
        },
        moveFrom: function(a, b, c) {
            if (void 0 === b && (b = this.speed), 0 === b) return !1;
            var d;
            return void 0 === c ? (d = this.angle, c = this.game.math.radToDeg(d)) : d = this.game.math.degToRad(c), this.moveTimer = 0, this.moveDuration = a, 0 === c || 180 === c ? this.velocity.set(Math.cos(d) * b, 0) : 90 === c || 270 === c ? this.velocity.set(0, Math.sin(d) * b) : this.velocity.setToPolar(d, b), this.isMoving = !0, !0;
        },
        moveTo: function(a, b, d) {
            var e = b / (a / 1000);
            if (0 === e) return !1;
            var f;
            return void 0 === d ? (f = this.angle, d = this.game.math.radToDeg(f)) : f = this.game.math.degToRad(d), b = Math.abs(b), this.moveDuration = 0, this.moveDistance = b, null === this.moveTarget && (this.moveTarget = new c53.Line, this.moveEnd = new c53.Point), this.moveTarget.fromAngle(this.x, this.y, f, b), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === d || 180 === d ? this.velocity.set(Math.cos(f) * e, 0) : 90 === d || 270 === d ? this.velocity.set(0, Math.sin(f) * e) : this.velocity.setToPolar(f, e), this.isMoving = !0, !0;
        },
        setSize: function(a, b, c, d) {
            void 0 === c && (c = this.offset.x), void 0 === d && (d = this.offset.y), this.sourceWidth = a, this.sourceHeight = b, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(c, d), this.updateCenter(), this.isCircle = !1, this.radius = 0;
        },
        setCircle: function(a, b, c) {
            void 0 === b && (b = this.offset.x), void 0 === c && (c = this.offset.y), a > 0 ? (this.isCircle = !0, this.radius = a, this.sourceWidth = 2 * a, this.sourceHeight = 2 * a, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(b, c), this.updateCenter()) : this.isCircle = !1;
        },
        reset: function(a, b) {
            this.stop(), this.position.x = a - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = b - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this.updateBounds(), this.updateCenter();
        },
        stop: function() {
            this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0;
        },
        getBounds: function(a) {
            return a.x = this.x, a.y = this.y, a.right = this.right, a.bottom = this.bottom, a;
        },
        hitTest: function(a, b) {
            return this.isCircle ? c53.Circle.contains(this, a, b) : c53.Rectangle.contains(this, a, b);
        },
        onFloor: function() {
            return this.blocked.down;
        },
        onCeiling: function() {
            return this.blocked.up;
        },
        onWall: function() {
            return this.blocked.left || this.blocked.right;
        },
        deltaAbsX: function() {
            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();
        },
        deltaAbsY: function() {
            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();
        },
        deltaX: function() {
            return this.position.x - this.prev.x;
        },
        deltaY: function() {
            return this.position.y - this.prev.y;
        },
        deltaZ: function() {
            return this.rotation - this.preRotation;
        },
        destroy: function() {
            this.sprite.parent && this.sprite.parent instanceof c53.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null;
        }
    }, Object.defineProperty(c53.Physics.Arcade.Body.prototype, "left", {
        get: function() {
            return this.position.x;
        }
    }), Object.defineProperty(c53.Physics.Arcade.Body.prototype, "right", {
        get: function() {
            return this.position.x + this.width;
        }
    }), Object.defineProperty(c53.Physics.Arcade.Body.prototype, "top", {
        get: function() {
            return this.position.y;
        }
    }), Object.defineProperty(c53.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height;
        }
    }), Object.defineProperty(c53.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(a) {
            this.position.x = a;
        }
    }), Object.defineProperty(c53.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(a) {
            this.position.y = a;
        }
    }), c53.Physics.Arcade.Body.render = function(a, b, c, d, e) {
        void 0 === d && (d = !0), c = c || "rgba(0,255,0,0.4)", a.fillStyle = c, a.strokeStyle = c, a.lineWidth = e || 1, b.isCircle ? (a.beginPath(), a.arc(b.center.x - b.game.camera.x, b.center.y - b.game.camera.y, b.halfWidth, 0, 2 * Math.PI), d ? a.fill() : a.stroke()) : d ? a.fillRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height) : a.strokeRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height);
    }, c53.Physics.Arcade.Body.renderBodyInfo = function(a, b) {
        a.line("x: " + b.x.toFixed(2), "y: " + b.y.toFixed(2), "width: " + b.width, "height: " + b.height), a.line("velocity x: " + b.velocity.x.toFixed(2), "y: " + b.velocity.y.toFixed(2), "deltaX: " + b._dx.toFixed(2), "deltaY: " + b._dy.toFixed(2)), a.line("acceleration x: " + b.acceleration.x.toFixed(2), "y: " + b.acceleration.y.toFixed(2), "speed: " + b.speed.toFixed(2), "angle: " + b.angle.toFixed(2)), a.line("gravity x: " + b.gravity.x, "y: " + b.gravity.y, "bounce x: " + b.bounce.x.toFixed(2), "y: " + b.bounce.y.toFixed(2)), a.line("touching left: " + b.touching.left, "right: " + b.touching.right, "up: " + b.touching.up, "down: " + b.touching.down), a.line("blocked left: " + b.blocked.left, "right: " + b.blocked.right, "up: " + b.blocked.up, "down: " + b.blocked.down);
    }, c53.Physics.Arcade.Body.prototype.constructor = c53.Physics.Arcade.Body, c53.Physics.Arcade.TilemapCollision = function() {}, c53.Physics.Arcade.TilemapCollision.prototype = {
        TILE_BIAS: 16,
        collideSpriteVsTilemapLayer: function(a, b, c, d, e, f) {
            if (a.body) {
                var g = b.getTiles(a.body.position.x - a.body.tilePadding.x - b.getTileOffsetX(), a.body.position.y - a.body.tilePadding.y - b.getTileOffsetY(), a.body.width + a.body.tilePadding.x, a.body.height + a.body.tilePadding.y, !1, !1);
                if (0 !== g.length) for(var h = 0; h < g.length; h++)d ? d.call(e, a, g[h]) && this.separateTile(h, a.body, g[h], b, f) && (this._total++, c && c.call(e, a, g[h])) : this.separateTile(h, a.body, g[h], b, f) && (this._total++, c && c.call(e, a, g[h]));
            }
        },
        collideGroupVsTilemapLayer: function(a, b, c, d, e, f) {
            if (0 !== a.length) for(var g = 0; g < a.children.length; g++)a.children[g].exists && this.collideSpriteVsTilemapLayer(a.children[g], b, c, d, e, f);
        },
        separateTile: function(a, b, c, d, e) {
            if (!b.enable) return !1;
            var f = d.getTileOffsetX(), g = d.getTileOffsetY();
            if (!c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) return !1;
            if (e) return !0;
            if (c.collisionCallback && !c.collisionCallback.call(c.collisionCallbackContext, b.sprite, c)) return !1;
            if (void 0 !== c.layer.callbacks && c.layer.callbacks[c.index] && !c.layer.callbacks[c.index].callback.call(c.layer.callbacks[c.index].callbackContext, b.sprite, c)) return !1;
            if (!(c.faceLeft || c.faceRight || c.faceTop || c.faceBottom)) return !1;
            var h = 0, i = 0, j = 0, k = 1;
            if (b.deltaAbsX() > b.deltaAbsY() ? j = -1 : b.deltaAbsX() < b.deltaAbsY() && (k = -1), 0 !== b.deltaX() && 0 !== b.deltaY() && (c.faceLeft || c.faceRight) && (c.faceTop || c.faceBottom) && (j = Math.min(Math.abs(b.position.x - f - c.right), Math.abs(b.right - f - c.left)), k = Math.min(Math.abs(b.position.y - g - c.bottom), Math.abs(b.bottom - g - c.top))), j < k) {
                if ((c.faceLeft || c.faceRight) && 0 !== (h = this.tileCheckX(b, c, d)) && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) return !0;
                (c.faceTop || c.faceBottom) && (i = this.tileCheckY(b, c, d));
            } else {
                if ((c.faceTop || c.faceBottom) && 0 !== (i = this.tileCheckY(b, c, d)) && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) return !0;
                (c.faceLeft || c.faceRight) && (h = this.tileCheckX(b, c, d));
            }
            return 0 !== h || 0 !== i;
        },
        tileCheckX: function(a, b, c) {
            var d = 0, e = c.getTileOffsetX();
            return a.deltaX() < 0 && !a.blocked.left && b.collideRight && a.checkCollision.left ? b.faceRight && a.x - e < b.right && (d = a.x - e - b.right) < -this.TILE_BIAS && (d = 0) : a.deltaX() > 0 && !a.blocked.right && b.collideLeft && a.checkCollision.right && b.faceLeft && a.right - e > b.left && (d = a.right - e - b.left) > this.TILE_BIAS && (d = 0), 0 !== d && (a.customSeparateX ? a.overlapX = d : this.processTileSeparationX(a, d)), d;
        },
        tileCheckY: function(a, b, c) {
            var d = 0, e = c.getTileOffsetY();
            return a.deltaY() < 0 && !a.blocked.up && b.collideDown && a.checkCollision.up ? b.faceBottom && a.y - e < b.bottom && (d = a.y - e - b.bottom) < -this.TILE_BIAS && (d = 0) : a.deltaY() > 0 && !a.blocked.down && b.collideUp && a.checkCollision.down && b.faceTop && a.bottom - e > b.top && (d = a.bottom - e - b.top) > this.TILE_BIAS && (d = 0), 0 !== d && (a.customSeparateY ? a.overlapY = d : this.processTileSeparationY(a, d)), d;
        },
        processTileSeparationX: function(a, b) {
            b < 0 ? (a.blocked.left = !0, a.blocked.none = !1) : b > 0 && (a.blocked.right = !0, a.blocked.none = !1), a.position.x -= b, 0 === a.bounce.x ? a.velocity.x = 0 : a.velocity.x = -a.velocity.x * a.bounce.x;
        },
        processTileSeparationY: function(a, b) {
            b < 0 ? (a.blocked.up = !0, a.blocked.none = !1) : b > 0 && (a.blocked.down = !0, a.blocked.none = !1), a.position.y -= b, 0 === a.bounce.y ? a.velocity.y = 0 : a.velocity.y = -a.velocity.y * a.bounce.y;
        }
    }, c53.Utils.mixinPrototype(c53.Physics.Arcade.prototype, c53.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, c53.Physics.P2 = function(a, b) {
        this.game = a, void 0 === b ? b = {
            gravity: [
                0,
                0
            ],
            broadphase: new p2.SAPBroadphase
        } : (b.hasOwnProperty("gravity") || (b.gravity = [
            0,
            0
        ]), b.hasOwnProperty("broadphase") || (b.broadphase = new p2.SAPBroadphase)), this.config = b, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new c53.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
            left: null,
            right: null,
            top: null,
            bottom: null
        }, this.onBodyAdded = new c53.Signal, this.onBodyRemoved = new c53.Signal, this.onSpringAdded = new c53.Signal, this.onSpringRemoved = new c53.Signal, this.onConstraintAdded = new c53.Signal, this.onConstraintRemoved = new c53.Signal, this.onContactMaterialAdded = new c53.Signal, this.onContactMaterialRemoved = new c53.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new c53.Signal, this.onEndContact = new c53.Signal, b.hasOwnProperty("mpx") && b.hasOwnProperty("pxm") && b.hasOwnProperty("mpxi") && b.hasOwnProperty("pxmi") && (this.mpx = b.mpx, this.mpxi = b.mpxi, this.pxm = b.pxm, this.pxmi = b.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new c53.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new c53.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new c53.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1);
    }, c53.Physics.P2.prototype = {
        removeBodyNextStep: function(a) {
            this._toRemove.push(a);
        },
        preUpdate: function() {
            for(var a = this._toRemove.length; a--;)this.removeBody(this._toRemove[a]);
            this._toRemove.length = 0;
        },
        enable: function(a, b, d) {
            void 0 === b && (b = !1), void 0 === d && (d = !0);
            var e = 1;
            if (Array.isArray(a)) for(e = a.length; e--;)a[e] instanceof c53.Group ? this.enable(a[e].children, b, d) : (this.enableBody(a[e], b), d && a[e].hasOwnProperty("children") && a[e].children.length > 0 && this.enable(a[e], b, !0));
            else a instanceof c53.Group ? this.enable(a.children, b, d) : (this.enableBody(a, b), d && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, b, !0));
        },
        enableBody: function(a, b) {
            a.hasOwnProperty("body") && null === a.body && (a.body = new c53.Physics.P2.Body(this.game, a, a.x, a.y, 1), a.body.debug = b, void 0 !== a.anchor && a.anchor.set(0.5));
        },
        setImpactEvents: function(a) {
            a ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this);
        },
        setPostBroadphaseCallback: function(a, b) {
            this.postBroadphaseCallback = a, this.callbackContext = b, null !== a ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this);
        },
        postBroadphaseHandler: function(a) {
            if (this.postBroadphaseCallback && 0 !== a.pairs.length) for(var b = a.pairs.length - 2; b >= 0; b -= 2)a.pairs[b].parent && a.pairs[b + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, a.pairs[b].parent, a.pairs[b + 1].parent) && a.pairs.splice(b, 2);
        },
        impactHandler: function(a) {
            if (a.bodyA.parent && a.bodyB.parent) {
                var b = a.bodyA.parent, c = a.bodyB.parent;
                b._bodyCallbacks[a.bodyB.id] && b._bodyCallbacks[a.bodyB.id].call(b._bodyCallbackContext[a.bodyB.id], b, c, a.shapeA, a.shapeB), c._bodyCallbacks[a.bodyA.id] && c._bodyCallbacks[a.bodyA.id].call(c._bodyCallbackContext[a.bodyA.id], c, b, a.shapeB, a.shapeA), b._groupCallbacks[a.shapeB.collisionGroup] && b._groupCallbacks[a.shapeB.collisionGroup].call(b._groupCallbackContext[a.shapeB.collisionGroup], b, c, a.shapeA, a.shapeB), c._groupCallbacks[a.shapeA.collisionGroup] && c._groupCallbacks[a.shapeA.collisionGroup].call(c._groupCallbackContext[a.shapeA.collisionGroup], c, b, a.shapeB, a.shapeA);
            }
        },
        beginContactHandler: function(a) {
            a.bodyA && a.bodyB && (this.onBeginContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB, a.contactEquations), a.bodyA.parent && a.bodyA.parent.onBeginContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB, a.contactEquations), a.bodyB.parent && a.bodyB.parent.onBeginContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA, a.contactEquations));
        },
        endContactHandler: function(a) {
            a.bodyA && a.bodyB && (this.onEndContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB), a.bodyA.parent && a.bodyA.parent.onEndContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB), a.bodyB.parent && a.bodyB.parent.onEndContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA));
        },
        setBoundsToWorld: function(a, b, c, d, e) {
            this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, a, b, c, d, e);
        },
        setWorldMaterial: function(a, b, c, d, e) {
            void 0 === b && (b = !0), void 0 === c && (c = !0), void 0 === d && (d = !0), void 0 === e && (e = !0), b && this.walls.left && (this.walls.left.shapes[0].material = a), c && this.walls.right && (this.walls.right.shapes[0].material = a), d && this.walls.top && (this.walls.top.shapes[0].material = a), e && this.walls.bottom && (this.walls.bottom.shapes[0].material = a);
        },
        updateBoundsCollisionGroup: function(a) {
            void 0 === a && (a = !0);
            var b = a ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
            this.walls.left && (this.walls.left.shapes[0].collisionGroup = b), this.walls.right && (this.walls.right.shapes[0].collisionGroup = b), this.walls.top && (this.walls.top.shapes[0].collisionGroup = b), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = b), this._boundsOwnGroup = a;
        },
        setBounds: function(a, b, c, d, e, f, g, h, i) {
            void 0 === e && (e = this._boundsLeft), void 0 === f && (f = this._boundsRight), void 0 === g && (g = this._boundsTop), void 0 === h && (h = this._boundsBottom), void 0 === i && (i = this._boundsOwnGroup), this.setupWall(e, "left", a, b, 1.5707963267948966, i), this.setupWall(f, "right", a + c, b, -1.5707963267948966, i), this.setupWall(g, "top", a, b, -3.141592653589793, i), this.setupWall(h, "bottom", a, b + d, 0, i), this._boundsLeft = e, this._boundsRight = f, this._boundsTop = g, this._boundsBottom = h, this._boundsOwnGroup = i;
        },
        setupWall: function(a, b, c, d, e, f) {
            a ? (this.walls[b] ? this.walls[b].position = [
                this.pxmi(c),
                this.pxmi(d)
            ] : (this.walls[b] = new p2.Body({
                mass: 0,
                position: [
                    this.pxmi(c),
                    this.pxmi(d)
                ],
                angle: e
            }), this.walls[b].addShape(new p2.Plane), this.world.addBody(this.walls[b])), f && (this.walls[b].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[b] && (this.world.removeBody(this.walls[b]), this.walls[b] = null);
        },
        pause: function() {
            this.paused = !0;
        },
        resume: function() {
            this.paused = !1;
        },
        update: function() {
            this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate));
        },
        reset: function() {
            this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new c53.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new c53.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new c53.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1);
        },
        clear: function() {
            this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
            for(var a = this.world.constraints, b = a.length - 1; b >= 0; b--)this.world.removeConstraint(a[b]);
            for(var c = this.world.bodies, b = c.length - 1; b >= 0; b--)this.world.removeBody(c[b]);
            for(var d = this.world.springs, b = d.length - 1; b >= 0; b--)this.world.removeSpring(d[b]);
            for(var e = this.world.contactMaterials, b = e.length - 1; b >= 0; b--)this.world.removeContactMaterial(e[b]);
            this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            };
        },
        destroy: function() {
            this.clear(), this.game = null;
        },
        addBody: function(a) {
            return !a.data.world && (this.world.addBody(a.data), this.onBodyAdded.dispatch(a), !0);
        },
        removeBody: function(a) {
            return a.data.world === this.world && (this.world.removeBody(a.data), this.onBodyRemoved.dispatch(a)), a;
        },
        addSpring: function(a) {
            return a instanceof c53.Physics.P2.Spring || a instanceof c53.Physics.P2.RotationalSpring ? this.world.addSpring(a.data) : this.world.addSpring(a), this.onSpringAdded.dispatch(a), a;
        },
        removeSpring: function(a) {
            return a instanceof c53.Physics.P2.Spring || a instanceof c53.Physics.P2.RotationalSpring ? this.world.removeSpring(a.data) : this.world.removeSpring(a), this.onSpringRemoved.dispatch(a), a;
        },
        createDistanceConstraint: function(a, b, d, e, f, g) {
            if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addConstraint(new c53.Physics.P2.DistanceConstraint(this, a, b, d, e, f, g));
            console.warn("Cannot create Constraint, invalid body objects given");
        },
        createGearConstraint: function(a, b, d, e) {
            if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addConstraint(new c53.Physics.P2.GearConstraint(this, a, b, d, e));
            console.warn("Cannot create Constraint, invalid body objects given");
        },
        createRevoluteConstraint: function(a, b, d, e, f, g) {
            if (a = this.getBody(a), d = this.getBody(d), a && d) return this.addConstraint(new c53.Physics.P2.RevoluteConstraint(this, a, b, d, e, f, g));
            console.warn("Cannot create Constraint, invalid body objects given");
        },
        createLockConstraint: function(a, b, d, e, f) {
            if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addConstraint(new c53.Physics.P2.LockConstraint(this, a, b, d, e, f));
            console.warn("Cannot create Constraint, invalid body objects given");
        },
        createPrismaticConstraint: function(a, b, d, e, f, g, h) {
            if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addConstraint(new c53.Physics.P2.PrismaticConstraint(this, a, b, d, e, f, g, h));
            console.warn("Cannot create Constraint, invalid body objects given");
        },
        addConstraint: function(a) {
            return this.world.addConstraint(a), this.onConstraintAdded.dispatch(a), a;
        },
        removeConstraint: function(a) {
            return this.world.removeConstraint(a), this.onConstraintRemoved.dispatch(a), a;
        },
        addContactMaterial: function(a) {
            return this.world.addContactMaterial(a), this.onContactMaterialAdded.dispatch(a), a;
        },
        removeContactMaterial: function(a) {
            return this.world.removeContactMaterial(a), this.onContactMaterialRemoved.dispatch(a), a;
        },
        getContactMaterial: function(a, b) {
            return this.world.getContactMaterial(a, b);
        },
        setMaterial: function(a, b) {
            for(var c = b.length; c--;)b[c].setMaterial(a);
        },
        createMaterial: function(a, b) {
            a = a || "";
            var d = new c53.Physics.P2.Material(a);
            return this.materials.push(d), void 0 !== b && b.setMaterial(d), d;
        },
        createContactMaterial: function(a, b, d) {
            void 0 === a && (a = this.createMaterial()), void 0 === b && (b = this.createMaterial());
            var e = new c53.Physics.P2.ContactMaterial(a, b, d);
            return this.addContactMaterial(e);
        },
        getBodies: function() {
            for(var a = [], b = this.world.bodies.length; b--;)a.push(this.world.bodies[b].parent);
            return a;
        },
        getBody: function(a) {
            return a instanceof p2.Body ? a : a instanceof c53.Physics.P2.Body ? a.data : a.body && a.body.type === c53.Physics.P2JS ? a.body.data : null;
        },
        getSprings: function() {
            for(var a = [], b = this.world.springs.length; b--;)a.push(this.world.springs[b].parent);
            return a;
        },
        getConstraints: function() {
            for(var a = [], b = this.world.constraints.length; b--;)a.push(this.world.constraints[b]);
            return a;
        },
        hitTest: function(a, b, d, e) {
            void 0 === b && (b = this.world.bodies), void 0 === d && (d = 5), void 0 === e && (e = !1);
            for(var f = [
                this.pxmi(a.x),
                this.pxmi(a.y)
            ], g = [], h = b.length; h--;)b[h] instanceof c53.Physics.P2.Body && (!e || b[h].data.type !== p2.Body.STATIC) ? g.push(b[h].data) : b[h] instanceof p2.Body && b[h].parent && (!e || b[h].type !== p2.Body.STATIC) ? g.push(b[h]) : b[h] instanceof c53.Sprite && b[h].hasOwnProperty("body") && (!e || b[h].body.data.type !== p2.Body.STATIC) && g.push(b[h].body.data);
            return this.world.hitTest(f, g, d);
        },
        toJSON: function() {
            return this.world.toJSON();
        },
        createCollisionGroup: function(a) {
            var b = Math.pow(2, this._collisionGroupID);
            this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | b), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | b), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | b), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | b), this._collisionGroupID++;
            var d = new c53.Physics.P2.CollisionGroup(b);
            return this.collisionGroups.push(d), a && this.setCollisionGroup(a, d), d;
        },
        setCollisionGroup: function(a, b) {
            if (a instanceof c53.Group) for(var d = 0; d < a.total; d++)a.children[d].body && a.children[d].body.type === c53.Physics.P2JS && a.children[d].body.setCollisionGroup(b);
            else a.body.setCollisionGroup(b);
        },
        createSpring: function(a, b, d, e, f, g, h, i, j) {
            if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addSpring(new c53.Physics.P2.Spring(this, a, b, d, e, f, g, h, i, j));
            console.warn("Cannot create Spring, invalid body objects given");
        },
        createRotationalSpring: function(a, b, d, e, f) {
            if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addSpring(new c53.Physics.P2.RotationalSpring(this, a, b, d, e, f));
            console.warn("Cannot create Rotational Spring, invalid body objects given");
        },
        createBody: function(a, b, d, e, f, g) {
            void 0 === e && (e = !1);
            var h = new c53.Physics.P2.Body(this.game, null, a, b, d);
            if (g) {
                if (!h.addPolygon(f, g)) return !1;
            }
            return e && this.world.addBody(h.data), h;
        },
        createParticle: function(a, b, d, e, f, g) {
            void 0 === e && (e = !1);
            var h = new c53.Physics.P2.Body(this.game, null, a, b, d);
            if (g) {
                if (!h.addPolygon(f, g)) return !1;
            }
            return e && this.world.addBody(h.data), h;
        },
        convertCollisionObjects: function(a, b, c) {
            void 0 === c && (c = !0);
            for(var d = [], e = 0, f = a.collision[b].length; e < f; e++){
                var g = a.collision[b][e], h = this.createBody(g.x, g.y, 0, c, {}, g.polyline);
                h && d.push(h);
            }
            return d;
        },
        clearTilemapLayerBodies: function(a, b) {
            b = a.getLayer(b);
            for(var c = a.layers[b].bodies.length; c--;)a.layers[b].bodies[c].destroy();
            a.layers[b].bodies.length = 0;
        },
        convertTilemap: function(a, b, c, d) {
            b = a.getLayer(b), void 0 === c && (c = !0), void 0 === d && (d = !0), this.clearTilemapLayerBodies(a, b);
            for(var e = 0, f = 0, g = 0, h = 0, i = a.layers[b].height; h < i; h++){
                e = 0;
                for(var j = 0, k = a.layers[b].width; j < k; j++){
                    var l = a.layers[b].data[h][j];
                    if (l && l.index > -1 && l.collides) {
                        if (d) {
                            var m = a.getTileRight(b, j, h);
                            if (0 === e && (f = l.x * l.width, g = l.y * l.height, e = l.width), m && m.collides) e += l.width;
                            else {
                                var n = this.createBody(f, g, 0, !1);
                                n.addRectangle(e, l.height, e / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n), e = 0;
                            }
                        } else {
                            var n = this.createBody(l.x * l.width, l.y * l.height, 0, !1);
                            n.addRectangle(l.width, l.height, l.width / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n);
                        }
                    }
                }
            }
            return a.layers[b].bodies;
        },
        mpx: function(a) {
            return a *= 20;
        },
        pxm: function(a) {
            return 0.05 * a;
        },
        mpxi: function(a) {
            return a *= -20;
        },
        pxmi: function(a) {
            return -0.05 * a;
        }
    }, Object.defineProperty(c53.Physics.P2.prototype, "friction", {
        get: function() {
            return this.world.defaultContactMaterial.friction;
        },
        set: function(a) {
            this.world.defaultContactMaterial.friction = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "restitution", {
        get: function() {
            return this.world.defaultContactMaterial.restitution;
        },
        set: function(a) {
            this.world.defaultContactMaterial.restitution = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "contactMaterial", {
        get: function() {
            return this.world.defaultContactMaterial;
        },
        set: function(a) {
            this.world.defaultContactMaterial = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "applySpringForces", {
        get: function() {
            return this.world.applySpringForces;
        },
        set: function(a) {
            this.world.applySpringForces = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "applyDamping", {
        get: function() {
            return this.world.applyDamping;
        },
        set: function(a) {
            this.world.applyDamping = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "applyGravity", {
        get: function() {
            return this.world.applyGravity;
        },
        set: function(a) {
            this.world.applyGravity = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "solveConstraints", {
        get: function() {
            return this.world.solveConstraints;
        },
        set: function(a) {
            this.world.solveConstraints = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "time", {
        get: function() {
            return this.world.time;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "emitImpactEvent", {
        get: function() {
            return this.world.emitImpactEvent;
        },
        set: function(a) {
            this.world.emitImpactEvent = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "sleepMode", {
        get: function() {
            return this.world.sleepMode;
        },
        set: function(a) {
            this.world.sleepMode = a;
        }
    }), Object.defineProperty(c53.Physics.P2.prototype, "total", {
        get: function() {
            return this.world.bodies.length;
        }
    }), c53.Physics.P2.FixtureList = function(a) {
        Array.isArray(a) || (a = [
            a
        ]), this.rawList = a, this.init(), this.parse(this.rawList);
    }, c53.Physics.P2.FixtureList.prototype = {
        init: function() {
            this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = [];
        },
        setCategory: function(a, b71) {
            var c = function(b) {
                b.collisionGroup = a;
            };
            this.getFixtures(b71).forEach(c);
        },
        setMask: function(a, b72) {
            var c = function(b) {
                b.collisionMask = a;
            };
            this.getFixtures(b72).forEach(c);
        },
        setSensor: function(a, b73) {
            var c = function(b) {
                b.sensor = a;
            };
            this.getFixtures(b73).forEach(c);
        },
        setMaterial: function(a, b74) {
            var c = function(b) {
                b.material = a;
            };
            this.getFixtures(b74).forEach(c);
        },
        getFixtures: function(a88) {
            var b = [];
            if (a88) {
                a88 instanceof Array || (a88 = [
                    a88
                ]);
                var c = this;
                return a88.forEach(function(a) {
                    c.namedFixtures[a] && b.push(c.namedFixtures[a]);
                }), this.flatten(b);
            }
            return this.allFixtures;
        },
        getFixtureByKey: function(a) {
            return this.namedFixtures[a];
        },
        getGroup: function(a) {
            return this.groupedFixtures[a];
        },
        parse: function() {
            var a, b, c, d;
            c = this.rawList, d = [];
            for(a in c)b = c[a], isNaN(a - 0) ? this.namedFixtures[a] = this.flatten(b) : (this.groupedFixtures[a] = this.groupedFixtures[a] || [], this.groupedFixtures[a] = this.groupedFixtures[a].concat(b)), d.push(this.allFixtures = this.flatten(this.groupedFixtures));
        },
        flatten: function(a89) {
            var b, c;
            return b = [], c = arguments.callee, a89.forEach(function(a) {
                return Array.prototype.push.apply(b, Array.isArray(a) ? c(a) : [
                    a
                ]);
            }), b;
        }
    }, c53.Physics.P2.PointProxy = function(a, b) {
        this.world = a, this.destination = b;
    }, c53.Physics.P2.PointProxy.prototype.constructor = c53.Physics.P2.PointProxy, Object.defineProperty(c53.Physics.P2.PointProxy.prototype, "x", {
        get: function() {
            return this.world.mpx(this.destination[0]);
        },
        set: function(a) {
            this.destination[0] = this.world.pxm(a);
        }
    }), Object.defineProperty(c53.Physics.P2.PointProxy.prototype, "y", {
        get: function() {
            return this.world.mpx(this.destination[1]);
        },
        set: function(a) {
            this.destination[1] = this.world.pxm(a);
        }
    }), Object.defineProperty(c53.Physics.P2.PointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0];
        },
        set: function(a) {
            this.destination[0] = a;
        }
    }), Object.defineProperty(c53.Physics.P2.PointProxy.prototype, "my", {
        get: function() {
            return this.destination[1];
        },
        set: function(a) {
            this.destination[1] = a;
        }
    }), c53.Physics.P2.InversePointProxy = function(a, b) {
        this.world = a, this.destination = b;
    }, c53.Physics.P2.InversePointProxy.prototype.constructor = c53.Physics.P2.InversePointProxy, Object.defineProperty(c53.Physics.P2.InversePointProxy.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.destination[0]);
        },
        set: function(a) {
            this.destination[0] = this.world.pxmi(a);
        }
    }), Object.defineProperty(c53.Physics.P2.InversePointProxy.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.destination[1]);
        },
        set: function(a) {
            this.destination[1] = this.world.pxmi(a);
        }
    }), Object.defineProperty(c53.Physics.P2.InversePointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0];
        },
        set: function(a) {
            this.destination[0] = -a;
        }
    }), Object.defineProperty(c53.Physics.P2.InversePointProxy.prototype, "my", {
        get: function() {
            return this.destination[1];
        },
        set: function(a) {
            this.destination[1] = -a;
        }
    }), c53.Physics.P2.Body = function(a, b, d, e, f) {
        b = b || null, d = d || 0, e = e || 0, void 0 === f && (f = 1), this.game = a, this.world = a.physics.p2, this.sprite = b, this.type = c53.Physics.P2JS, this.offset = new c53.Point, this.data = new p2.Body({
            position: [
                this.world.pxmi(d),
                this.world.pxmi(e)
            ],
            mass: f
        }), this.data.parent = this, this.velocity = new c53.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new c53.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new c53.Point, this.onBeginContact = new c53.Signal, this.onEndContact = new c53.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, b && (this.setRectangleFromSprite(b), b.exists && this.game.physics.p2.addBody(this));
    }, c53.Physics.P2.Body.prototype = {
        createBodyCallback: function(a, b, c) {
            var d = -1;
            a.id ? d = a.id : a.body && (d = a.body.id), d > -1 && (null === b ? (delete this._bodyCallbacks[d], delete this._bodyCallbackContext[d]) : (this._bodyCallbacks[d] = b, this._bodyCallbackContext[d] = c));
        },
        createGroupCallback: function(a, b, c) {
            null === b ? (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]) : (this._groupCallbacks[a.mask] = b, this._groupCallbackContext[a.mask] = c);
        },
        getCollisionMask: function() {
            var a = 0;
            this._collideWorldBounds && (a = this.game.physics.p2.boundsCollisionGroup.mask);
            for(var b = 0; b < this.collidesWith.length; b++)a |= this.collidesWith[b].mask;
            return a;
        },
        updateCollisionMask: function(a) {
            var b = this.getCollisionMask();
            if (void 0 === a) for(var c = this.data.shapes.length - 1; c >= 0; c--)this.data.shapes[c].collisionMask = b;
            else a.collisionMask = b;
        },
        setCollisionGroup: function(a, b) {
            var c = this.getCollisionMask();
            if (void 0 === b) for(var d = this.data.shapes.length - 1; d >= 0; d--)this.data.shapes[d].collisionGroup = a.mask, this.data.shapes[d].collisionMask = c;
            else b.collisionGroup = a.mask, b.collisionMask = c;
        },
        clearCollision: function(a, b, c) {
            if (void 0 === a && (a = !0), void 0 === b && (b = !0), void 0 === c) for(var d = this.data.shapes.length - 1; d >= 0; d--)a && (this.data.shapes[d].collisionGroup = null), b && (this.data.shapes[d].collisionMask = null);
            else a && (c.collisionGroup = null), b && (c.collisionMask = null);
            a && (this.collidesWith.length = 0);
        },
        removeCollisionGroup: function(a, b, c) {
            void 0 === b && (b = !0);
            var d;
            if (Array.isArray(a)) for(var e = 0; e < a.length; e++)(d = this.collidesWith.indexOf(a[e])) > -1 && (this.collidesWith.splice(d, 1), b && (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]));
            else (d = this.collidesWith.indexOf(a)) > -1 && (this.collidesWith.splice(d, 1), b && (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]));
            var f = this.getCollisionMask();
            if (void 0 === c) for(var e = this.data.shapes.length - 1; e >= 0; e--)this.data.shapes[e].collisionMask = f;
            else c.collisionMask = f;
        },
        collides: function(a, b, c, d) {
            if (Array.isArray(a)) for(var e = 0; e < a.length; e++)-1 === this.collidesWith.indexOf(a[e]) && (this.collidesWith.push(a[e]), b && this.createGroupCallback(a[e], b, c));
            else -1 === this.collidesWith.indexOf(a) && (this.collidesWith.push(a), b && this.createGroupCallback(a, b, c));
            var f = this.getCollisionMask();
            if (void 0 === d) for(var e = this.data.shapes.length - 1; e >= 0; e--)this.data.shapes[e].collisionMask = f;
            else d.collisionMask = f;
        },
        adjustCenterOfMass: function() {
            this.data.adjustCenterOfMass(), this.shapeChanged();
        },
        getVelocityAtPoint: function(a, b) {
            return this.data.getVelocityAtPoint(a, b);
        },
        applyDamping: function(a) {
            this.data.applyDamping(a);
        },
        applyImpulse: function(a, b, c) {
            this.data.applyImpulse(a, [
                this.world.pxmi(b),
                this.world.pxmi(c)
            ]);
        },
        applyImpulseLocal: function(a, b, c) {
            this.data.applyImpulseLocal(a, [
                this.world.pxmi(b),
                this.world.pxmi(c)
            ]);
        },
        applyForce: function(a, b, c) {
            this.data.applyForce(a, [
                this.world.pxmi(b),
                this.world.pxmi(c)
            ]);
        },
        setZeroForce: function() {
            this.data.setZeroForce();
        },
        setZeroRotation: function() {
            this.data.angularVelocity = 0;
        },
        setZeroVelocity: function() {
            this.data.velocity[0] = 0, this.data.velocity[1] = 0;
        },
        setZeroDamping: function() {
            this.data.damping = 0, this.data.angularDamping = 0;
        },
        toLocalFrame: function(a, b) {
            return this.data.toLocalFrame(a, b);
        },
        toWorldFrame: function(a, b) {
            return this.data.toWorldFrame(a, b);
        },
        rotateLeft: function(a) {
            this.data.angularVelocity = this.world.pxm(-a);
        },
        rotateRight: function(a) {
            this.data.angularVelocity = this.world.pxm(a);
        },
        moveForward: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = b * Math.cos(c), this.data.velocity[1] = b * Math.sin(c);
        },
        moveBackward: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = -b * Math.cos(c), this.data.velocity[1] = -b * Math.sin(c);
        },
        thrust: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle + Math.PI / 2;
            this.data.force[0] += b * Math.cos(c), this.data.force[1] += b * Math.sin(c);
        },
        thrustLeft: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle;
            this.data.force[0] += b * Math.cos(c), this.data.force[1] += b * Math.sin(c);
        },
        thrustRight: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle;
            this.data.force[0] -= b * Math.cos(c), this.data.force[1] -= b * Math.sin(c);
        },
        reverse: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle + Math.PI / 2;
            this.data.force[0] -= b * Math.cos(c), this.data.force[1] -= b * Math.sin(c);
        },
        moveLeft: function(a) {
            this.data.velocity[0] = this.world.pxmi(-a);
        },
        moveRight: function(a) {
            this.data.velocity[0] = this.world.pxmi(a);
        },
        moveUp: function(a) {
            this.data.velocity[1] = this.world.pxmi(-a);
        },
        moveDown: function(a) {
            this.data.velocity[1] = this.world.pxmi(a);
        },
        preUpdate: function() {
            this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1);
        },
        postUpdate: function() {
            this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1;
        },
        reset: function(a, b, c, d) {
            void 0 === c && (c = !1), void 0 === d && (d = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), c && this.setZeroDamping(), d && (this.mass = 1), this.x = a, this.y = b;
        },
        addToWorld: function() {
            if (this.game.physics.p2._toRemove) for(var a = 0; a < this.game.physics.p2._toRemove.length; a++)this.game.physics.p2._toRemove[a] === this && this.game.physics.p2._toRemove.splice(a, 1);
            this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this);
        },
        removeFromWorld: function() {
            this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this);
        },
        destroy: function() {
            this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null);
        },
        clearShapes: function() {
            for(var a = this.data.shapes.length; a--;)this.data.removeShape(this.data.shapes[a]);
            this.shapeChanged();
        },
        addShape: function(a, b, c, d) {
            return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), this.data.addShape(a, [
                this.world.pxmi(b),
                this.world.pxmi(c)
            ], d), this.shapeChanged(), a;
        },
        addCircle: function(a, b, c, d) {
            var e = new p2.Circle({
                radius: this.world.pxm(a)
            });
            return this.addShape(e, b, c, d);
        },
        addRectangle: function(a, b, c, d, e) {
            var f = new p2.Box({
                width: this.world.pxm(a),
                height: this.world.pxm(b)
            });
            return this.addShape(f, c, d, e);
        },
        addPlane: function(a, b, c) {
            var d = new p2.Plane;
            return this.addShape(d, a, b, c);
        },
        addParticle: function(a, b, c) {
            var d = new p2.Particle;
            return this.addShape(d, a, b, c);
        },
        addLine: function(a, b, c, d) {
            var e = new p2.Line({
                length: this.world.pxm(a)
            });
            return this.addShape(e, b, c, d);
        },
        addCapsule: function(a, b, c, d, e) {
            var f = new p2.Capsule({
                length: this.world.pxm(a),
                radius: this.world.pxm(b)
            });
            return this.addShape(f, c, d, e);
        },
        addPolygon: function(a, b) {
            a = a || {}, Array.isArray(b) || (b = Array.prototype.slice.call(arguments, 1));
            var c = [];
            if (1 === b.length && Array.isArray(b[0])) c = b[0].slice(0);
            else if (Array.isArray(b[0])) c = b.slice();
            else if ("number" == typeof b[0]) for(var d = 0, e = b.length; d < e; d += 2)c.push([
                b[d],
                b[d + 1]
            ]);
            var f = c.length - 1;
            c[f][0] === c[0][0] && c[f][1] === c[0][1] && c.pop();
            for(var g = 0; g < c.length; g++)c[g][0] = this.world.pxmi(c[g][0]), c[g][1] = this.world.pxmi(c[g][1]);
            var h = this.data.fromPolygon(c, a);
            return this.shapeChanged(), h;
        },
        removeShape: function(a) {
            var b = this.data.removeShape(a);
            return this.shapeChanged(), b;
        },
        setCircle: function(a, b, c, d) {
            return this.clearShapes(), this.addCircle(a, b, c, d);
        },
        setRectangle: function(a, b, c, d, e) {
            return void 0 === a && (a = 16), void 0 === b && (b = 16), this.clearShapes(), this.addRectangle(a, b, c, d, e);
        },
        setRectangleFromSprite: function(a) {
            return void 0 === a && (a = this.sprite), this.clearShapes(), this.addRectangle(a.width, a.height, 0, 0, a.rotation);
        },
        setMaterial: function(a, b) {
            if (void 0 === b) for(var c = this.data.shapes.length - 1; c >= 0; c--)this.data.shapes[c].material = a;
            else b.material = a;
        },
        shapeChanged: function() {
            this.debugBody && this.debugBody.draw();
        },
        addPhaserPolygon: function(a, b) {
            for(var c = this.game.cache.getPhysicsData(a, b), d = [], e = 0; e < c.length; e++){
                var f = c[e], g = this.addFixture(f);
                d[f.filter.group] = d[f.filter.group] || [], d[f.filter.group] = d[f.filter.group].concat(g), f.fixtureKey && (d[f.fixtureKey] = g);
            }
            return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), d;
        },
        addFixture: function(a) {
            var b = [];
            if (a.circle) {
                var c = new p2.Circle({
                    radius: this.world.pxm(a.circle.radius)
                });
                c.collisionGroup = a.filter.categoryBits, c.collisionMask = a.filter.maskBits, c.sensor = a.isSensor;
                var d = p2.vec2.create();
                d[0] = this.world.pxmi(a.circle.position[0] - this.sprite.width / 2), d[1] = this.world.pxmi(a.circle.position[1] - this.sprite.height / 2), this.data.addShape(c, d), b.push(c);
            } else for(var e = a.polygons, f = p2.vec2.create(), g = 0; g < e.length; g++){
                for(var h = e[g], i = [], j = 0; j < h.length; j += 2)i.push([
                    this.world.pxmi(h[j]),
                    this.world.pxmi(h[j + 1])
                ]);
                for(var c = new p2.Convex({
                    vertices: i
                }), k = 0; k !== c.vertices.length; k++){
                    var l = c.vertices[k];
                    p2.vec2.sub(l, l, c.centerOfMass);
                }
                p2.vec2.scale(f, c.centerOfMass, 1), f[0] -= this.world.pxmi(this.sprite.width / 2), f[1] -= this.world.pxmi(this.sprite.height / 2), c.updateTriangles(), c.updateCenterOfMass(), c.updateBoundingRadius(), c.collisionGroup = a.filter.categoryBits, c.collisionMask = a.filter.maskBits, c.sensor = a.isSensor, this.data.addShape(c, f), b.push(c);
            }
            return b;
        },
        loadPolygon: function(a, b, c) {
            if (null === a) var d = b;
            else var d = this.game.cache.getPhysicsData(a, b);
            "number" != typeof c && (c = 1);
            for(var e = p2.vec2.create(), f = 0; f < d.length; f++){
                for(var g = [], h = 0; h < d[f].shape.length; h += 2)g.push([
                    this.world.pxmi(d[f].shape[h] * c),
                    this.world.pxmi(d[f].shape[h + 1] * c)
                ]);
                for(var i = new p2.Convex({
                    vertices: g
                }), j = 0; j !== i.vertices.length; j++){
                    var k = i.vertices[j];
                    p2.vec2.sub(k, k, i.centerOfMass);
                }
                p2.vec2.scale(e, i.centerOfMass, 1), e[0] -= this.world.pxmi(this.sprite.width / 2), e[1] -= this.world.pxmi(this.sprite.height / 2), i.updateTriangles(), i.updateCenterOfMass(), i.updateBoundingRadius(), this.data.addShape(i, e);
            }
            return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0;
        }
    }, c53.Physics.P2.Body.prototype.constructor = c53.Physics.P2.Body, c53.Physics.P2.Body.DYNAMIC = 1, c53.Physics.P2.Body.STATIC = 2, c53.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(c53.Physics.P2.Body.prototype, "static", {
        get: function() {
            return this.data.type === c53.Physics.P2.Body.STATIC;
        },
        set: function(a) {
            a && this.data.type !== c53.Physics.P2.Body.STATIC ? (this.data.type = c53.Physics.P2.Body.STATIC, this.mass = 0) : a || this.data.type !== c53.Physics.P2.Body.STATIC || (this.data.type = c53.Physics.P2.Body.DYNAMIC, this.mass = 1);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "dynamic", {
        get: function() {
            return this.data.type === c53.Physics.P2.Body.DYNAMIC;
        },
        set: function(a) {
            a && this.data.type !== c53.Physics.P2.Body.DYNAMIC ? (this.data.type = c53.Physics.P2.Body.DYNAMIC, this.mass = 1) : a || this.data.type !== c53.Physics.P2.Body.DYNAMIC || (this.data.type = c53.Physics.P2.Body.STATIC, this.mass = 0);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "kinematic", {
        get: function() {
            return this.data.type === c53.Physics.P2.Body.KINEMATIC;
        },
        set: function(a) {
            a && this.data.type !== c53.Physics.P2.Body.KINEMATIC ? (this.data.type = c53.Physics.P2.Body.KINEMATIC, this.mass = 4) : a || this.data.type !== c53.Physics.P2.Body.KINEMATIC || (this.data.type = c53.Physics.P2.Body.STATIC, this.mass = 0);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "allowSleep", {
        get: function() {
            return this.data.allowSleep;
        },
        set: function(a) {
            a !== this.data.allowSleep && (this.data.allowSleep = a);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "angle", {
        get: function() {
            return c53.Math.wrapAngle(c53.Math.radToDeg(this.data.angle));
        },
        set: function(a) {
            this.data.angle = c53.Math.degToRad(c53.Math.wrapAngle(a));
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "angularDamping", {
        get: function() {
            return this.data.angularDamping;
        },
        set: function(a) {
            this.data.angularDamping = a;
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "angularForce", {
        get: function() {
            return this.data.angularForce;
        },
        set: function(a) {
            this.data.angularForce = a;
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "angularVelocity", {
        get: function() {
            return this.data.angularVelocity;
        },
        set: function(a) {
            this.data.angularVelocity = a;
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "damping", {
        get: function() {
            return this.data.damping;
        },
        set: function(a) {
            this.data.damping = a;
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "fixedRotation", {
        get: function() {
            return this.data.fixedRotation;
        },
        set: function(a) {
            a !== this.data.fixedRotation && (this.data.fixedRotation = a);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "inertia", {
        get: function() {
            return this.data.inertia;
        },
        set: function(a) {
            this.data.inertia = a;
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "mass", {
        get: function() {
            return this.data.mass;
        },
        set: function(a) {
            a !== this.data.mass && (this.data.mass = a, this.data.updateMassProperties());
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "motionState", {
        get: function() {
            return this.data.type;
        },
        set: function(a) {
            a !== this.data.type && (this.data.type = a);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "rotation", {
        get: function() {
            return this.data.angle;
        },
        set: function(a) {
            this.data.angle = a;
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "sleepSpeedLimit", {
        get: function() {
            return this.data.sleepSpeedLimit;
        },
        set: function(a) {
            this.data.sleepSpeedLimit = a;
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.data.position[0]);
        },
        set: function(a) {
            this.data.position[0] = this.world.pxmi(a);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.data.position[1]);
        },
        set: function(a) {
            this.data.position[1] = this.world.pxmi(a);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "id", {
        get: function() {
            return this.data.id;
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "debug", {
        get: function() {
            return null !== this.debugBody;
        },
        set: function(a) {
            a && !this.debugBody ? this.debugBody = new c53.Physics.P2.BodyDebug(this.game, this.data) : !a && this.debugBody && (this.debugBody.destroy(), this.debugBody = null);
        }
    }), Object.defineProperty(c53.Physics.P2.Body.prototype, "collideWorldBounds", {
        get: function() {
            return this._collideWorldBounds;
        },
        set: function(a) {
            a && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !a && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask());
        }
    }), c53.Physics.P2.BodyDebug = function(a, b, d) {
        c53.Group.call(this, a);
        var e = {
            pixelsPerLengthUnit: a.physics.p2.mpx(1),
            debugPolygons: !1,
            lineWidth: 1,
            alpha: 0.5
        };
        this.settings = c53.Utils.extend(e, d), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = b, this.canvas = new c53.Graphics(a), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform();
    }, c53.Physics.P2.BodyDebug.prototype = Object.create(c53.Group.prototype), c53.Physics.P2.BodyDebug.prototype.constructor = c53.Physics.P2.BodyDebug, c53.Utils.extend(c53.Physics.P2.BodyDebug.prototype, {
        updateSpriteTransform: function() {
            this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle;
        },
        draw: function() {
            var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o;
            if (h = this.body, j = this.canvas, j.clear(), c = parseInt(this.randomPastelHex(), 16), f = 16711680, g = this.lineWidth, h instanceof p2.Body && h.shapes.length) {
                var p = h.shapes.length;
                for(d = 0; d !== p;){
                    if (b = h.shapes[d], i = b.position || 0, a = b.angle || 0, b instanceof p2.Circle) this.drawCircle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.radius * this.ppu, c, g);
                    else if (b instanceof p2.Capsule) this.drawCapsule(j, i[0] * this.ppu, i[1] * this.ppu, a, b.length * this.ppu, b.radius * this.ppu, f, c, g);
                    else if (b instanceof p2.Plane) this.drawPlane(j, i[0] * this.ppu, -i[1] * this.ppu, c, f, 5 * g, 10 * g, 10 * g, 100 * this.ppu, a);
                    else if (b instanceof p2.Line) this.drawLine(j, b.length * this.ppu, f, g);
                    else if (b instanceof p2.Box) this.drawRectangle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.width * this.ppu, b.height * this.ppu, f, c, g);
                    else if (b instanceof p2.Convex) {
                        for(l = [], m = p2.vec2.create(), e = n = 0, o = b.vertices.length; 0 <= o ? n < o : n > o; e = 0 <= o ? ++n : --n)k = b.vertices[e], p2.vec2.rotate(m, k, a), l.push([
                            (m[0] + i[0]) * this.ppu,
                            -(m[1] + i[1]) * this.ppu
                        ]);
                        this.drawConvex(j, l, b.triangles, f, c, g, this.settings.debugPolygons, [
                            i[0] * this.ppu,
                            -i[1] * this.ppu
                        ]);
                    }
                    d++;
                }
            }
        },
        drawRectangle: function(a, b, c, d, e, f, g, h, i) {
            void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1), a.beginFill(h), a.drawRect(b - e / 2, c - f / 2, e, f);
        },
        drawCircle: function(a, b, c, d, e, f, g) {
            void 0 === g && (g = 1), void 0 === f && (f = 16777215), a.lineStyle(g, 0, 1), a.beginFill(f, 1), a.drawCircle(b, c, 2 * -e), a.endFill(), a.moveTo(b, c), a.lineTo(b + e * Math.cos(-d), c + e * Math.sin(-d));
        },
        drawLine: function(a, b, c, d) {
            void 0 === d && (d = 1), void 0 === c && (c = 0), a.lineStyle(5 * d, c, 1), a.moveTo(-b / 2, 0), a.lineTo(b / 2, 0);
        },
        drawConvex: function(a, b, c, d, e, f, g, h) {
            var i, j, k, l, m, n, o, p, q, r, s;
            if (void 0 === f && (f = 1), void 0 === d && (d = 0), g) {
                for(i = [
                    16711680,
                    65280,
                    255
                ], j = 0; j !== b.length + 1;)l = b[j % b.length], m = b[(j + 1) % b.length], o = l[0], r = l[1], p = m[0], s = m[1], a.lineStyle(f, i[j % i.length], 1), a.moveTo(o, -r), a.lineTo(p, -s), a.drawCircle(o, -r, 2 * f), j++;
                return a.lineStyle(f, 0, 1), a.drawCircle(h[0], h[1], 2 * f);
            }
            for(a.lineStyle(f, d, 1), a.beginFill(e), j = 0; j !== b.length;)k = b[j], n = k[0], q = k[1], 0 === j ? a.moveTo(n, -q) : a.lineTo(n, -q), j++;
            if (a.endFill(), b.length > 2) return a.moveTo(b[b.length - 1][0], -b[b.length - 1][1]), a.lineTo(b[0][0], -b[0][1]);
        },
        drawPath: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q;
            for(void 0 === e && (e = 1), void 0 === c && (c = 0), a.lineStyle(e, c, 1), "number" == typeof d && a.beginFill(d), g = null, h = null, f = 0; f < b.length;)o = b[f], p = o[0], q = o[1], p === g && q === h || (0 === f ? a.moveTo(p, q) : (i = g, j = h, k = p, l = q, m = b[(f + 1) % b.length][0], n = b[(f + 1) % b.length][1], 0 !== (k - i) * (n - j) - (m - i) * (l - j) && a.lineTo(p, q)), g = p, h = q), f++;
            "number" == typeof d && a.endFill(), b.length > 2 && "number" == typeof d && (a.moveTo(b[b.length - 1][0], b[b.length - 1][1]), a.lineTo(b[0][0], b[0][1]));
        },
        drawPlane: function(a, b, c, d, e, f, g, h, i, j) {
            var k, l;
            void 0 === f && (f = 1), void 0 === d && (d = 16777215), a.lineStyle(f, e, 11), a.beginFill(d), a.moveTo(b, -c), k = b + Math.cos(j) * this.game.width, l = c + Math.sin(j) * this.game.height, a.lineTo(k, -l), a.moveTo(b, -c), k = b + Math.cos(j) * -this.game.width, l = c + Math.sin(j) * -this.game.height, a.lineTo(k, -l);
        },
        drawCapsule: function(a, b, c, d, e, f, g, h, i) {
            void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1);
            var j = Math.cos(d), k = Math.sin(d);
            a.beginFill(h, 1), a.drawCircle(-e / 2 * j + b, -e / 2 * k + c, 2 * -f), a.drawCircle(e / 2 * j + b, e / 2 * k + c, 2 * -f), a.endFill(), a.lineStyle(i, g, 0), a.beginFill(h, 1), a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c), a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c), a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c), a.lineTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c), a.endFill(), a.lineStyle(i, g, 1), a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c), a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c), a.moveTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c), a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c);
        },
        randomPastelHex: function() {
            var a, b, c, d;
            return c = [
                255,
                255,
                255
            ], d = Math.floor(256 * Math.random()), b = Math.floor(256 * Math.random()), a = Math.floor(256 * Math.random()), d = Math.floor((d + 3 * c[0]) / 4), b = Math.floor((b + 3 * c[1]) / 4), a = Math.floor((a + 3 * c[2]) / 4), this.rgbToHex(d, b, a);
        },
        rgbToHex: function(a, b, c) {
            return this.componentToHex(a) + this.componentToHex(b) + this.componentToHex(c);
        },
        componentToHex: function(a) {
            var b;
            return b = a.toString(16), 2 === b.length ? b : b + "0";
        }
    }), c53.Physics.P2.Spring = function(a, b, c, d, e, f, g, h, i, j) {
        this.game = a.game, this.world = a, void 0 === d && (d = 1), void 0 === e && (e = 100), void 0 === f && (f = 1), d = a.pxm(d);
        var k = {
            restLength: d,
            stiffness: e,
            damping: f
        };
        void 0 !== g && null !== g && (k.worldAnchorA = [
            a.pxm(g[0]),
            a.pxm(g[1])
        ]), void 0 !== h && null !== h && (k.worldAnchorB = [
            a.pxm(h[0]),
            a.pxm(h[1])
        ]), void 0 !== i && null !== i && (k.localAnchorA = [
            a.pxm(i[0]),
            a.pxm(i[1])
        ]), void 0 !== j && null !== j && (k.localAnchorB = [
            a.pxm(j[0]),
            a.pxm(j[1])
        ]), this.data = new p2.LinearSpring(b, c, k), this.data.parent = this;
    }, c53.Physics.P2.Spring.prototype.constructor = c53.Physics.P2.Spring, c53.Physics.P2.RotationalSpring = function(a, b, c, d, e, f) {
        this.game = a.game, this.world = a, void 0 === d && (d = null), void 0 === e && (e = 100), void 0 === f && (f = 1), d && (d = a.pxm(d));
        var g = {
            restAngle: d,
            stiffness: e,
            damping: f
        };
        this.data = new p2.RotationalSpring(b, c, g), this.data.parent = this;
    }, c53.Physics.P2.Spring.prototype.constructor = c53.Physics.P2.Spring, c53.Physics.P2.Material = function(a) {
        this.name = a, p2.Material.call(this);
    }, c53.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), c53.Physics.P2.Material.prototype.constructor = c53.Physics.P2.Material, c53.Physics.P2.ContactMaterial = function(a, b, c) {
        p2.ContactMaterial.call(this, a, b, c);
    }, c53.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), c53.Physics.P2.ContactMaterial.prototype.constructor = c53.Physics.P2.ContactMaterial, c53.Physics.P2.CollisionGroup = function(a) {
        this.mask = a;
    }, c53.Physics.P2.DistanceConstraint = function(a, b, c, d, e, f, g) {
        void 0 === d && (d = 100), void 0 === e && (e = [
            0,
            0
        ]), void 0 === f && (f = [
            0,
            0
        ]), void 0 === g && (g = Number.MAX_VALUE), this.game = a.game, this.world = a, d = a.pxm(d), e = [
            a.pxmi(e[0]),
            a.pxmi(e[1])
        ], f = [
            a.pxmi(f[0]),
            a.pxmi(f[1])
        ];
        var h = {
            distance: d,
            localAnchorA: e,
            localAnchorB: f,
            maxForce: g
        };
        p2.DistanceConstraint.call(this, b, c, h);
    }, c53.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), c53.Physics.P2.DistanceConstraint.prototype.constructor = c53.Physics.P2.DistanceConstraint, c53.Physics.P2.GearConstraint = function(a, b, c, d, e) {
        void 0 === d && (d = 0), void 0 === e && (e = 1), this.game = a.game, this.world = a;
        var f = {
            angle: d,
            ratio: e
        };
        p2.GearConstraint.call(this, b, c, f);
    }, c53.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), c53.Physics.P2.GearConstraint.prototype.constructor = c53.Physics.P2.GearConstraint, c53.Physics.P2.LockConstraint = function(a, b, c, d, e, f) {
        void 0 === d && (d = [
            0,
            0
        ]), void 0 === e && (e = 0), void 0 === f && (f = Number.MAX_VALUE), this.game = a.game, this.world = a, d = [
            a.pxm(d[0]),
            a.pxm(d[1])
        ];
        var g = {
            localOffsetB: d,
            localAngleB: e,
            maxForce: f
        };
        p2.LockConstraint.call(this, b, c, g);
    }, c53.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), c53.Physics.P2.LockConstraint.prototype.constructor = c53.Physics.P2.LockConstraint, c53.Physics.P2.PrismaticConstraint = function(a, b, c, d, e, f, g, h) {
        void 0 === d && (d = !0), void 0 === e && (e = [
            0,
            0
        ]), void 0 === f && (f = [
            0,
            0
        ]), void 0 === g && (g = [
            0,
            0
        ]), void 0 === h && (h = Number.MAX_VALUE), this.game = a.game, this.world = a, e = [
            a.pxmi(e[0]),
            a.pxmi(e[1])
        ], f = [
            a.pxmi(f[0]),
            a.pxmi(f[1])
        ];
        var i = {
            localAnchorA: e,
            localAnchorB: f,
            localAxisA: g,
            maxForce: h,
            disableRotationalLock: !d
        };
        p2.PrismaticConstraint.call(this, b, c, i);
    }, c53.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), c53.Physics.P2.PrismaticConstraint.prototype.constructor = c53.Physics.P2.PrismaticConstraint, c53.Physics.P2.RevoluteConstraint = function(a, b, c, d, e, f, g) {
        void 0 === f && (f = Number.MAX_VALUE), void 0 === g && (g = null), this.game = a.game, this.world = a, c = [
            a.pxmi(c[0]),
            a.pxmi(c[1])
        ], e = [
            a.pxmi(e[0]),
            a.pxmi(e[1])
        ], g && (g = [
            a.pxmi(g[0]),
            a.pxmi(g[1])
        ]);
        var h = {
            worldPivot: g,
            localPivotA: c,
            localPivotB: e,
            maxForce: f
        };
        p2.RevoluteConstraint.call(this, b, d, h);
    }, c53.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), c53.Physics.P2.RevoluteConstraint.prototype.constructor = c53.Physics.P2.RevoluteConstraint, c53.ImageCollection = function(a, b, c, d, e, f, g) {
        (void 0 === c || c <= 0) && (c = 32), (void 0 === d || d <= 0) && (d = 32), void 0 === e && (e = 0), void 0 === f && (f = 0), this.name = a, this.firstgid = 0 | b, this.imageWidth = 0 | c, this.imageHeight = 0 | d, this.imageMargin = 0 | e, this.imageSpacing = 0 | f, this.properties = g || {}, this.images = [], this.total = 0;
    }, c53.ImageCollection.prototype = {
        containsImageIndex: function(a) {
            return a >= this.firstgid && a < this.firstgid + this.total;
        },
        addImage: function(a, b) {
            this.images.push({
                gid: a,
                image: b
            }), this.total++;
        }
    }, c53.ImageCollection.prototype.constructor = c53.ImageCollection, c53.Tile = function(a, b, c, d, e, f) {
        this.layer = a, this.index = b, this.x = c, this.y = d, this.rotation = 0, this.flipped = !1, this.worldX = c * e, this.worldY = d * f, this.width = e, this.height = f, this.centerX = Math.abs(e / 2), this.centerY = Math.abs(f / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this;
    }, c53.Tile.prototype = {
        containsPoint: function(a, b) {
            return !(a < this.worldX || b < this.worldY || a > this.right || b > this.bottom);
        },
        intersects: function(a, b, c, d) {
            return !(c <= this.worldX) && !(d <= this.worldY) && !(a >= this.worldX + this.width) && !(b >= this.worldY + this.height);
        },
        setCollisionCallback: function(a, b) {
            this.collisionCallback = a, this.collisionCallbackContext = b;
        },
        destroy: function() {
            this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null;
        },
        setCollision: function(a, b, c, d) {
            this.collideLeft = a, this.collideRight = b, this.collideUp = c, this.collideDown = d, this.faceLeft = a, this.faceRight = b, this.faceTop = c, this.faceBottom = d;
        },
        resetCollision: function() {
            this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1;
        },
        isInteresting: function(a, b) {
            return a && b ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : a ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!b && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);
        },
        copy: function(a) {
            this.index = a.index, this.alpha = a.alpha, this.properties = a.properties, this.collideUp = a.collideUp, this.collideDown = a.collideDown, this.collideLeft = a.collideLeft, this.collideRight = a.collideRight, this.collisionCallback = a.collisionCallback, this.collisionCallbackContext = a.collisionCallbackContext;
        }
    }, c53.Tile.prototype.constructor = c53.Tile, Object.defineProperty(c53.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
        }
    }), Object.defineProperty(c53.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;
        }
    }), Object.defineProperty(c53.Tile.prototype, "left", {
        get: function() {
            return this.worldX;
        }
    }), Object.defineProperty(c53.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width;
        }
    }), Object.defineProperty(c53.Tile.prototype, "top", {
        get: function() {
            return this.worldY;
        }
    }), Object.defineProperty(c53.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height;
        }
    }), c53.Tilemap = function(a, b, d, e, f, g) {
        this.game = a, this.key = b;
        var h = c53.TilemapParser.parse(this.game, b, d, e, f, g);
        null !== h && (this.width = h.width, this.height = h.height, this.tileWidth = h.tileWidth, this.tileHeight = h.tileHeight, this.orientation = h.orientation, this.format = h.format, this.version = h.version, this.properties = h.properties, this.widthInPixels = h.widthInPixels, this.heightInPixels = h.heightInPixels, this.layers = h.layers, this.tilesets = h.tilesets, this.imagecollections = h.imagecollections, this.tiles = h.tiles, this.objects = h.objects, this.collideIndexes = [], this.collision = h.collision, this.images = h.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0);
    }, c53.Tilemap.CSV = 0, c53.Tilemap.TILED_JSON = 1, c53.Tilemap.NORTH = 0, c53.Tilemap.EAST = 1, c53.Tilemap.SOUTH = 2, c53.Tilemap.WEST = 3, c53.Tilemap.prototype = {
        create: function(a, b, c, d, e, f) {
            return void 0 === f && (f = this.game.world), this.width = b, this.height = c, this.setTileSize(d, e), this.layers.length = 0, this.createBlankLayer(a, b, c, d, e, f);
        },
        setTileSize: function(a, b) {
            this.tileWidth = a, this.tileHeight = b, this.widthInPixels = this.width * a, this.heightInPixels = this.height * b;
        },
        addTilesetImage: function(a, b, d, e, f, g, h) {
            if (void 0 === a) return null;
            void 0 === d && (d = this.tileWidth), void 0 === e && (e = this.tileHeight), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = 0), 0 === d && (d = 32), 0 === e && (e = 32);
            var i = null;
            if (void 0 !== b && null !== b || (b = a), b instanceof c53.BitmapData) i = b.canvas;
            else {
                if (!this.game.cache.checkImageKey(b)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + b + '"'), null;
                i = this.game.cache.getImage(b);
            }
            var j = this.getTilesetIndex(a);
            if (null === j && this.format === c53.Tilemap.TILED_JSON) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + a + '"'), null;
            if (this.tilesets[j]) return this.tilesets[j].setImage(i), this.tilesets[j];
            var k = new c53.Tileset(a, h, d, e, f, g, {});
            k.setImage(i), this.tilesets.push(k);
            for(var l = this.tilesets.length - 1, m = f, n = f, o = 0, p = 0, q = 0, r = h; r < h + k.total && (this.tiles[r] = [
                m,
                n,
                l
            ], m += d + g, ++o !== k.total) && (++p !== k.columns || (m = f, n += e + g, p = 0, ++q !== k.rows)); r++);
            return k;
        },
        createFromObjects: function(a, b, d, e, f, g, h, i, j) {
            if (void 0 === f && (f = !0), void 0 === g && (g = !1), void 0 === h && (h = this.game.world), void 0 === i && (i = c53.Sprite), void 0 === j && (j = !0), !this.objects[a]) return void console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + a);
            for(var k = 0; k < this.objects[a].length; k++){
                var l = !1, m = this.objects[a][k];
                if (void 0 !== m.gid && "number" == typeof b && m.gid === b ? l = !0 : void 0 !== m.id && "number" == typeof b && m.id === b ? l = !0 : void 0 !== m.name && "string" == typeof b && m.name === b && (l = !0), l) {
                    var n = new i(this.game, parseFloat(m.x, 10), parseFloat(m.y, 10), d, e);
                    n.name = m.name, n.visible = m.visible, n.autoCull = g, n.exists = f, m.width && (n.width = m.width), m.height && (n.height = m.height), m.rotation && (n.angle = m.rotation), j && (n.y -= n.height), h.add(n);
                    for(var o in m.properties)h.set(n, o, m.properties[o], !1, !1, 0, !0);
                }
            }
        },
        createFromTiles: function(a, b, d, e, f, g) {
            "number" == typeof a && (a = [
                a
            ]), void 0 === b || null === b ? b = [] : "number" == typeof b && (b = [
                b
            ]), e = this.getLayer(e), void 0 === f && (f = this.game.world), void 0 === g && (g = {}), void 0 === g.customClass && (g.customClass = c53.Sprite), void 0 === g.adjustY && (g.adjustY = !0);
            var h = this.layers[e].width, i = this.layers[e].height;
            if (this.copy(0, 0, h, i, e), this._results.length < 2) return 0;
            for(var j, k = 0, l = 1, m = this._results.length; l < m; l++)if (-1 !== a.indexOf(this._results[l].index)) {
                j = new g.customClass(this.game, this._results[l].worldX, this._results[l].worldY, d);
                for(var n in g)j[n] = g[n];
                f.add(j), k++;
            }
            if (1 === b.length) for(l = 0; l < a.length; l++)this.replace(a[l], b[0], 0, 0, h, i, e);
            else if (b.length > 1) for(l = 0; l < a.length; l++)this.replace(a[l], b[l], 0, 0, h, i, e);
            return k;
        },
        createLayer: function(a, b, d, e) {
            void 0 === b && (b = this.game.width), void 0 === d && (d = this.game.height), void 0 === e && (e = this.game.world);
            var f = a;
            if ("string" == typeof a && (f = this.getLayerIndex(a)), null === f || f > this.layers.length) return void console.warn('Tilemap.createLayer: Invalid layer ID given: "' + a + '"');
            void 0 === b || b <= 0 ? b = Math.min(this.game.width, this.layers[f].widthInPixels) : b > this.game.width && (b = this.game.width), void 0 === d || d <= 0 ? d = Math.min(this.game.height, this.layers[f].heightInPixels) : d > this.game.height && (d = this.game.height), this.enableDebug && (console.group("Tilemap.createLayer"), console.log("Name:", this.layers[f].name), console.log("Size:", b, "x", d), console.log("Tileset:", this.tilesets[0].name, "index:", f));
            var g = e.add(new c53.TilemapLayer(this.game, this, f, b, d));
            return this.enableDebug && console.groupEnd(), g;
        },
        createBlankLayer: function(a, b, d, e, f, g) {
            if (void 0 === g && (g = this.game.world), null !== this.getLayerIndex(a)) return void console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + a);
            for(var h, i = {
                name: a,
                x: 0,
                y: 0,
                width: b,
                height: d,
                widthInPixels: b * e,
                heightInPixels: d * f,
                alpha: 1,
                visible: !0,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: null
            }, j = [], k = 0; k < d; k++){
                h = [];
                for(var l = 0; l < b; l++)h.push(new c53.Tile(i, -1, l, k, e, f));
                j.push(h);
            }
            i.data = j, this.layers.push(i), this.currentLayer = this.layers.length - 1;
            var m = i.widthInPixels, n = i.heightInPixels;
            m > this.game.width && (m = this.game.width), n > this.game.height && (n = this.game.height);
            var j = new c53.TilemapLayer(this.game, this, this.layers.length - 1, m, n);
            return j.name = a, g.add(j);
        },
        getIndex: function(a, b) {
            for(var c = 0; c < a.length; c++)if (a[c].name === b) return c;
            return null;
        },
        getLayerIndex: function(a) {
            return this.getIndex(this.layers, a);
        },
        getTilesetIndex: function(a) {
            return this.getIndex(this.tilesets, a);
        },
        getImageIndex: function(a) {
            return this.getIndex(this.images, a);
        },
        setTileIndexCallback: function(a, b, c, d) {
            if (d = this.getLayer(d), "number" == typeof a) this.layers[d].callbacks[a] = {
                callback: b,
                callbackContext: c
            };
            else for(var e = 0, f = a.length; e < f; e++)this.layers[d].callbacks[a[e]] = {
                callback: b,
                callbackContext: c
            };
        },
        setTileLocationCallback: function(a, b, c, d, e, f, g) {
            if (g = this.getLayer(g), this.copy(a, b, c, d, g), !(this._results.length < 2)) for(var h = 1; h < this._results.length; h++)this._results[h].setCollisionCallback(e, f);
        },
        setCollision: function(a, b, c, d) {
            if (void 0 === b && (b = !0), void 0 === d && (d = !0), c = this.getLayer(c), "number" == typeof a) return this.setCollisionByIndex(a, b, c, !0);
            if (Array.isArray(a)) {
                for(var e = 0; e < a.length; e++)this.setCollisionByIndex(a[e], b, c, !1);
                d && this.calculateFaces(c);
            }
        },
        setCollisionBetween: function(a, b, c, d, e) {
            if (void 0 === c && (c = !0), void 0 === e && (e = !0), d = this.getLayer(d), !(a > b)) {
                for(var f = a; f <= b; f++)this.setCollisionByIndex(f, c, d, !1);
                e && this.calculateFaces(d);
            }
        },
        setCollisionByExclusion: function(a, b, c, d) {
            void 0 === b && (b = !0), void 0 === d && (d = !0), c = this.getLayer(c);
            for(var e = 0, f = this.tiles.length; e < f; e++)-1 === a.indexOf(e) && this.setCollisionByIndex(e, b, c, !1);
            d && this.calculateFaces(c);
        },
        setCollisionByIndex: function(a, b, c, d) {
            if (void 0 === b && (b = !0), void 0 === c && (c = this.currentLayer), void 0 === d && (d = !0), b) this.collideIndexes.push(a);
            else {
                var e = this.collideIndexes.indexOf(a);
                e > -1 && this.collideIndexes.splice(e, 1);
            }
            for(var f = 0; f < this.layers[c].height; f++)for(var g = 0; g < this.layers[c].width; g++){
                var h = this.layers[c].data[f][g];
                h && h.index === a && (b ? h.setCollision(!0, !0, !0, !0) : h.resetCollision(), h.faceTop = b, h.faceBottom = b, h.faceLeft = b, h.faceRight = b);
            }
            return d && this.calculateFaces(c), c;
        },
        getLayer: function(a) {
            return void 0 === a ? a = this.currentLayer : "string" == typeof a ? a = this.getLayerIndex(a) : a instanceof c53.TilemapLayer && (a = a.index), a;
        },
        setPreventRecalculate: function(a) {
            if (!0 === a && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === a && !0 === this.preventingRecalculate) {
                this.preventingRecalculate = !1;
                for(var b in this.needToRecalculate)this.calculateFaces(b);
                this.needToRecalculate = !1;
            }
        },
        calculateFaces: function(a) {
            if (this.preventingRecalculate) return void (this.needToRecalculate[a] = !0);
            for(var b = null, c = null, d = null, e = null, f = 0, g = this.layers[a].height; f < g; f++)for(var h = 0, i = this.layers[a].width; h < i; h++){
                var j = this.layers[a].data[f][h];
                j && (b = this.getTileAbove(a, h, f), c = this.getTileBelow(a, h, f), d = this.getTileLeft(a, h, f), e = this.getTileRight(a, h, f), j.collides && (j.faceTop = !0, j.faceBottom = !0, j.faceLeft = !0, j.faceRight = !0), b && b.collides && (j.faceTop = !1), c && c.collides && (j.faceBottom = !1), d && d.collides && (j.faceLeft = !1), e && e.collides && (j.faceRight = !1));
            }
        },
        getTileAbove: function(a, b, c) {
            return c > 0 ? this.layers[a].data[c - 1][b] : null;
        },
        getTileBelow: function(a, b, c) {
            return c < this.layers[a].height - 1 ? this.layers[a].data[c + 1][b] : null;
        },
        getTileLeft: function(a, b, c) {
            return b > 0 ? this.layers[a].data[c][b - 1] : null;
        },
        getTileRight: function(a, b, c) {
            return b < this.layers[a].width - 1 ? this.layers[a].data[c][b + 1] : null;
        },
        setLayer: function(a) {
            a = this.getLayer(a), this.layers[a] && (this.currentLayer = a);
        },
        hasTile: function(a, b, c) {
            return c = this.getLayer(c), void 0 !== this.layers[c].data[b] && void 0 !== this.layers[c].data[b][a] && this.layers[c].data[b][a].index > -1;
        },
        removeTile: function(a, b, d) {
            if (d = this.getLayer(d), a >= 0 && a < this.layers[d].width && b >= 0 && b < this.layers[d].height && this.hasTile(a, b, d)) {
                var e = this.layers[d].data[b][a];
                return this.layers[d].data[b][a] = new c53.Tile(this.layers[d], -1, a, b, this.tileWidth, this.tileHeight), this.layers[d].dirty = !0, this.calculateFaces(d), e;
            }
        },
        removeTileWorldXY: function(a, b, c, d, e) {
            return e = this.getLayer(e), a = this.game.math.snapToFloor(a, c) / c, b = this.game.math.snapToFloor(b, d) / d, this.removeTile(a, b, e);
        },
        putTile: function(a, b, d, e) {
            if (null === a) return this.removeTile(b, d, e);
            if (e = this.getLayer(e), b >= 0 && b < this.layers[e].width && d >= 0 && d < this.layers[e].height) {
                var f;
                return a instanceof c53.Tile ? (f = a.index, this.hasTile(b, d, e) ? this.layers[e].data[d][b].copy(a) : this.layers[e].data[d][b] = new c53.Tile(e, f, b, d, a.width, a.height)) : (f = a, this.hasTile(b, d, e) ? this.layers[e].data[d][b].index = f : this.layers[e].data[d][b] = new c53.Tile(this.layers[e], f, b, d, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(f) > -1 ? this.layers[e].data[d][b].setCollision(!0, !0, !0, !0) : this.layers[e].data[d][b].resetCollision(), this.layers[e].dirty = !0, this.calculateFaces(e), this.layers[e].data[d][b];
            }
            return null;
        },
        putTileWorldXY: function(a, b, c, d, e, f) {
            return f = this.getLayer(f), b = this.game.math.snapToFloor(b, d) / d, c = this.game.math.snapToFloor(c, e) / e, this.putTile(a, b, c, f);
        },
        searchTileIndex: function(a, b, c, d) {
            void 0 === b && (b = 0), void 0 === c && (c = !1), d = this.getLayer(d);
            var e = 0;
            if (c) {
                for(var f = this.layers[d].height - 1; f >= 0; f--)for(var g = this.layers[d].width - 1; g >= 0; g--)if (this.layers[d].data[f][g].index === a) {
                    if (e === b) return this.layers[d].data[f][g];
                    e++;
                }
            } else for(var f = 0; f < this.layers[d].height; f++)for(var g = 0; g < this.layers[d].width; g++)if (this.layers[d].data[f][g].index === a) {
                if (e === b) return this.layers[d].data[f][g];
                e++;
            }
            return null;
        },
        getTile: function(a, b, c, d) {
            return void 0 === d && (d = !1), c = this.getLayer(c), a >= 0 && a < this.layers[c].width && b >= 0 && b < this.layers[c].height ? -1 === this.layers[c].data[b][a].index ? d ? this.layers[c].data[b][a] : null : this.layers[c].data[b][a] : null;
        },
        getTileWorldXY: function(a, b, c, d, e, f) {
            return void 0 === c && (c = this.tileWidth), void 0 === d && (d = this.tileHeight), e = this.getLayer(e), a = this.game.math.snapToFloor(a, c) / c, b = this.game.math.snapToFloor(b, d) / d, this.getTile(a, b, e, f);
        },
        copy: function(a, b, c, d, e) {
            if (e = this.getLayer(e), !this.layers[e]) return void (this._results.length = 0);
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.layers[e].width), void 0 === d && (d = this.layers[e].height), a < 0 && (a = 0), b < 0 && (b = 0), c > this.layers[e].width && (c = this.layers[e].width), d > this.layers[e].height && (d = this.layers[e].height), this._results.length = 0, this._results.push({
                x: a,
                y: b,
                width: c,
                height: d,
                layer: e
            });
            for(var f = b; f < b + d; f++)for(var g = a; g < a + c; g++)this._results.push(this.layers[e].data[f][g]);
            return this._results;
        },
        paste: function(a, b, c, d) {
            if (void 0 === a && (a = 0), void 0 === b && (b = 0), d = this.getLayer(d), c && !(c.length < 2)) {
                for(var e = a - c[1].x, f = b - c[1].y, g = 1; g < c.length; g++)this.layers[d].data[f + c[g].y][e + c[g].x].copy(c[g]);
                this.layers[d].dirty = !0, this.calculateFaces(d);
            }
        },
        swap: function(a, b, c, d, e, f, g) {
            g = this.getLayer(g), this.copy(c, d, e, f, g), this._results.length < 2 || (this._tempA = a, this._tempB = b, this._results.forEach(this.swapHandler, this), this.paste(c, d, this._results, g));
        },
        swapHandler: function(a) {
            a.index === this._tempA ? a.index = this._tempB : a.index === this._tempB && (a.index = this._tempA);
        },
        forEach: function(a, b, c, d, e, f, g) {
            g = this.getLayer(g), this.copy(c, d, e, f, g), this._results.length < 2 || (this._results.forEach(a, b), this.paste(c, d, this._results, g));
        },
        replace: function(a, b, c, d, e, f, g) {
            if (g = this.getLayer(g), this.copy(c, d, e, f, g), !(this._results.length < 2)) {
                for(var h = 1; h < this._results.length; h++)this._results[h].index === a && (this._results[h].index = b);
                this.paste(c, d, this._results, g);
            }
        },
        random: function(a, b, c, d, e) {
            if (e = this.getLayer(e), this.copy(a, b, c, d, e), !(this._results.length < 2)) {
                for(var f = [], g = 1; g < this._results.length; g++)if (this._results[g].index) {
                    var h = this._results[g].index;
                    -1 === f.indexOf(h) && f.push(h);
                }
                for(var i = 1; i < this._results.length; i++)this._results[i].index = this.game.rnd.pick(f);
                this.paste(a, b, this._results, e);
            }
        },
        shuffle: function(a, b, d, e, f) {
            if (f = this.getLayer(f), this.copy(a, b, d, e, f), !(this._results.length < 2)) {
                for(var g = [], h = 1; h < this._results.length; h++)this._results[h].index && g.push(this._results[h].index);
                c53.ArrayUtils.shuffle(g);
                for(var i = 1; i < this._results.length; i++)this._results[i].index = g[i - 1];
                this.paste(a, b, this._results, f);
            }
        },
        fill: function(a, b, c, d, e, f) {
            if (f = this.getLayer(f), this.copy(b, c, d, e, f), !(this._results.length < 2)) {
                for(var g = 1; g < this._results.length; g++)this._results[g].index = a;
                this.paste(b, c, this._results, f);
            }
        },
        removeAllLayers: function() {
            this.layers.length = 0, this.currentLayer = 0;
        },
        dump: function() {
            for(var a = "", b = [
                ""
            ], c = 0; c < this.layers[this.currentLayer].height; c++){
                for(var d = 0; d < this.layers[this.currentLayer].width; d++)a += "%c  ", this.layers[this.currentLayer].data[c][d] > 1 ? this.debugMap[this.layers[this.currentLayer].data[c][d]] ? b.push("background: " + this.debugMap[this.layers[this.currentLayer].data[c][d]]) : b.push("background: #ffffff") : b.push("background: rgb(0, 0, 0)");
                a += "\n";
            }
            b[0] = a, console.log.apply(console, b);
        },
        destroy: function() {
            this.removeAllLayers(), this.data = [], this.game = null;
        }
    }, c53.Tilemap.prototype.constructor = c53.Tilemap, Object.defineProperty(c53.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer];
        },
        set: function(a) {
            a !== this.currentLayer && this.setLayer(a);
        }
    }), c53.TilemapLayer = function(a, b, d, e, f) {
        e |= 0, f |= 0, c53.Sprite.call(this, a, 0, 0), this.map = b, this.index = d, this.layer = b.layers[d], this.canvas = c53.CanvasPool.create(this, e, f), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas, null, this.game.resolution))), this.type = c53.TILEMAPLAYER, this.physicsType = c53.TILEMAPLAYER, this.renderSettings = {
            enableScrollDelta: !0,
            overdrawRatio: 0.2,
            copyCanvas: null
        }, this.debug = !1, this.exists = !0, this.debugSettings = {
            missingImageFill: "rgb(255,255,255)",
            debuggedTileOverfill: "rgba(0,255,0,0.4)",
            forceFullRedraw: !0,
            debugAlpha: 0.5,
            facingEdgeStroke: "rgba(0,255,0,1)",
            collidingTileOverfill: "rgba(0,255,0,0.2)"
        }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
            scrollX: 0,
            scrollY: 0,
            renderWidth: 0,
            renderHeight: 0,
            tileWidth: b.tileWidth,
            tileHeight: b.tileHeight,
            cw: b.tileWidth,
            ch: b.tileHeight,
            tilesets: []
        }, this._scrollX = 0, this._scrollY = 0, this.tileOffset = new c53.Point(this.layer.offsetX || 0, this.layer.offsetY || 0), this._results = [], a.device.canvasBitBltShift || (this.renderSettings.copyCanvas = c53.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0;
    }, c53.TilemapLayer.prototype = Object.create(c53.Sprite.prototype), c53.TilemapLayer.prototype.constructor = c53.TilemapLayer, c53.TilemapLayer.prototype.preUpdateCore = c53.Component.Core.preUpdate, c53.TilemapLayer.sharedCopyCanvas = null, c53.TilemapLayer.ensureSharedCopyCanvas = function() {
        return this.sharedCopyCanvas || (this.sharedCopyCanvas = c53.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas;
    }, c53.TilemapLayer.prototype.preUpdate = function() {
        return this.preUpdateCore();
    }, c53.TilemapLayer.prototype.postUpdate = function() {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x, this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y;
    }, c53.TilemapLayer.prototype._renderCanvas = function(a) {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x, this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, a);
    }, c53.TilemapLayer.prototype._renderWebGL = function(a) {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x, this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, a);
    }, c53.TilemapLayer.prototype.destroy = function() {
        c53.CanvasPool.remove(this), c53.Component.Destroy.prototype.destroy.call(this);
    }, c53.TilemapLayer.prototype.resize = function(a, b) {
        this.canvas.width = a, this.canvas.height = b, this.texture.frame.resize(a, b), this.texture.width = a, this.texture.height = b, this.texture.crop.width = a, this.texture.crop.height = b, this.texture.baseTexture.width = a, this.texture.baseTexture.height = b, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0;
    }, c53.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y);
    }, c53.TilemapLayer.prototype.getTileOffsetX = function() {
        return this.tileOffset.x || (this.fixedToCamera ? 0 : this.position.x);
    }, c53.TilemapLayer.prototype.getTileOffsetY = function() {
        return this.tileOffset.y || (this.fixedToCamera ? 0 : this.position.y);
    }, c53.TilemapLayer.prototype._fixX = function(a) {
        return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? a : 0 === this.scrollFactorX && 0 !== this.position.x ? a - this.position.x : this._scrollX + (a - this._scrollX / this.scrollFactorX);
    }, c53.TilemapLayer.prototype._unfixX = function(a) {
        return 1 === this.scrollFactorX ? a : this._scrollX / this.scrollFactorX + (a - this._scrollX);
    }, c53.TilemapLayer.prototype._fixY = function(a) {
        return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? a : 0 === this.scrollFactorY && 0 !== this.position.y ? a - this.position.y : this._scrollY + (a - this._scrollY / this.scrollFactorY);
    }, c53.TilemapLayer.prototype._unfixY = function(a) {
        return 1 === this.scrollFactorY ? a : this._scrollY / this.scrollFactorY + (a - this._scrollY);
    }, c53.TilemapLayer.prototype.getTileX = function(a) {
        return Math.floor(this._fixX(a) / this._mc.tileWidth);
    }, c53.TilemapLayer.prototype.getTileY = function(a) {
        return Math.floor(this._fixY(a) / this._mc.tileHeight);
    }, c53.TilemapLayer.prototype.getTileXY = function(a, b, c) {
        return c.x = this.getTileX(a), c.y = this.getTileY(b), c;
    }, c53.TilemapLayer.prototype.getRayCastTiles = function(a, b, c, d) {
        b || (b = this.rayStepRate), void 0 === c && (c = !1), void 0 === d && (d = !1);
        var e = this.getTiles(a.x, a.y, a.width, a.height, c, d);
        if (0 === e.length) return [];
        for(var f = a.coordinatesOnLine(b), g = [], h = 0; h < e.length; h++)for(var i = 0; i < f.length; i++){
            var j = e[h], k = f[i];
            if (j.containsPoint(k[0], k[1])) {
                g.push(j);
                break;
            }
        }
        return g;
    }, c53.TilemapLayer.prototype.getTiles = function(a, b, c, d, e, f) {
        void 0 === e && (e = !1), void 0 === f && (f = !1);
        var g = !(e || f);
        a = this._fixX(a), b = this._fixY(b);
        for(var h = Math.floor(a / (this._mc.cw * this.scale.x)), i = Math.floor(b / (this._mc.ch * this.scale.y)), j = Math.ceil((a + c) / (this._mc.cw * this.scale.x)) - h, k = Math.ceil((b + d) / (this._mc.ch * this.scale.y)) - i; this._results.length;)this._results.pop();
        for(var l = i; l < i + k; l++)for(var m = h; m < h + j; m++){
            var n = this.layer.data[l];
            n && n[m] && (g || n[m].isInteresting(e, f)) && this._results.push(n[m]);
        }
        return this._results.slice();
    }, c53.TilemapLayer.prototype.resolveTileset = function(a) {
        var b = this._mc.tilesets;
        if (a < 2000) for(; b.length < a;)b.push(void 0);
        var c = this.map.tiles[a] && this.map.tiles[a][2];
        if (null !== c) {
            var d = this.map.tilesets[c];
            if (d && d.containsTileIndex(a)) return b[a] = d;
        }
        return b[a] = null;
    }, c53.TilemapLayer.prototype.resetTilesetCache = function() {
        for(var a = this._mc.tilesets; a.length;)a.pop();
    }, c53.TilemapLayer.prototype.setScale = function(a, b) {
        a = a || 1, b = b || a;
        for(var c = 0; c < this.layer.data.length; c++)for(var d = this.layer.data[c], e = 0; e < d.length; e++){
            var f = d[e];
            f.width = this.map.tileWidth * a, f.height = this.map.tileHeight * b, f.worldX = f.x * f.width, f.worldY = f.y * f.height;
        }
        this.scale.setTo(a, b);
    }, c53.TilemapLayer.prototype.shiftCanvas = function(a, b, c) {
        var d = a.canvas, e = d.width - Math.abs(b), f = d.height - Math.abs(c), g = 0, h = 0, i = b, j = c;
        b < 0 && (g = -b, i = 0), c < 0 && (h = -c, j = 0);
        var k = this.renderSettings.copyCanvas;
        if (k) {
            (k.width < e || k.height < f) && (k.width = e, k.height = f);
            var l = k.getContext("2d");
            l.clearRect(0, 0, e, f), l.drawImage(d, g, h, e, f, 0, 0, e, f), a.clearRect(i, j, e, f), a.drawImage(k, 0, 0, e, f, i, j, e, f);
        } else a.save(), a.globalCompositeOperation = "copy", a.drawImage(d, g, h, e, f, i, j, e, f), a.restore();
    }, c53.TilemapLayer.prototype.renderRegion = function(a, b, c, d, e, f) {
        var g = this.context, h = this.layer.width, i = this.layer.height, j = this._mc.tileWidth, k = this._mc.tileHeight, l = this._mc.tilesets, m = NaN;
        this._wrap || (c <= e && (c = Math.max(0, c), e = Math.min(h - 1, e)), d <= f && (d = Math.max(0, d), f = Math.min(i - 1, f)));
        var n, o, p, q, r, s, t = c * j - a, u = d * k - b, v = (c + 1048576 * h) % h, w = (d + 1048576 * i) % i;
        for(q = w, s = f - d, o = u; s >= 0; q++, s--, o += k){
            q >= i && (q -= i);
            var x = this.layer.data[q];
            for(p = v, r = e - c, n = t; r >= 0; p++, r--, n += j){
                p >= h && (p -= h);
                var y = x[p];
                if (y && !(y.index < 0)) {
                    var z = y.index, A = l[z];
                    void 0 === A && (A = this.resolveTileset(z)), y.alpha === m || this.debug || (g.globalAlpha = y.alpha, m = y.alpha), A ? y.rotation || y.flipped ? (g.save(), g.translate(n + y.centerX, o + y.centerY), g.rotate(y.rotation), y.flipped && g.scale(-1, 1), A.draw(g, -y.centerX, -y.centerY, z), g.restore()) : A.draw(g, n, o, z) : this.debugSettings.missingImageFill && (g.fillStyle = this.debugSettings.missingImageFill, g.fillRect(n, o, j, k)), y.debug && this.debugSettings.debuggedTileOverfill && (g.fillStyle = this.debugSettings.debuggedTileOverfill, g.fillRect(n, o, j, k));
                }
            }
        }
    }, c53.TilemapLayer.prototype.renderDeltaScroll = function(a, b) {
        var c = this._mc.scrollX, d = this._mc.scrollY, e = this.canvas.width, f = this.canvas.height, g = this._mc.tileWidth, h = this._mc.tileHeight, i = 0, j = -g, k = 0, l = -h;
        if (a < 0 ? (i = e + a, j = e - 1) : a > 0 && (j = a), b < 0 ? (k = f + b, l = f - 1) : b > 0 && (l = b), this.shiftCanvas(this.context, a, b), i = Math.floor((i + c) / g), j = Math.floor((j + c) / g), k = Math.floor((k + d) / h), l = Math.floor((l + d) / h), i <= j) {
            this.context.clearRect(i * g - c, 0, (j - i + 1) * g, f);
            var m = Math.floor((0 + d) / h), n = Math.floor((f - 1 + d) / h);
            this.renderRegion(c, d, i, m, j, n);
        }
        if (k <= l) {
            this.context.clearRect(0, k * h - d, e, (l - k + 1) * h);
            var o = Math.floor((0 + c) / g), p = Math.floor((e - 1 + c) / g);
            this.renderRegion(c, d, o, k, p, l);
        }
    }, c53.TilemapLayer.prototype.renderFull = function() {
        var a = this._mc.scrollX, b = this._mc.scrollY, c = this.canvas.width, d = this.canvas.height, e = this._mc.tileWidth, f = this._mc.tileHeight, g = Math.floor(a / e), h = Math.floor((c - 1 + a) / e), i = Math.floor(b / f), j = Math.floor((d - 1 + b) / f);
        this.context.clearRect(0, 0, c, d), this.renderRegion(a, b, g, i, h, j);
    }, c53.TilemapLayer.prototype.render = function() {
        var a = !1;
        if (this.visible) {
            (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, a = !0);
            var b = this.canvas.width, c = this.canvas.height, d = 0 | this._scrollX, e = 0 | this._scrollY, f = this._mc, g = f.scrollX - d, h = f.scrollY - e;
            if (a || 0 !== g || 0 !== h || f.renderWidth !== b || f.renderHeight !== c) return this.context.save(), f.scrollX = d, f.scrollY = e, f.renderWidth === b && f.renderHeight === c || (f.renderWidth = b, f.renderHeight = c), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (a = !0)), !a && this.renderSettings.enableScrollDelta && Math.abs(g) + Math.abs(h) < Math.min(b, c) ? this.renderDeltaScroll(g, h) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0;
        }
    }, c53.TilemapLayer.prototype.renderDebug = function() {
        var a, b, c, d, e, f, g = this._mc.scrollX, h = this._mc.scrollY, i = this.context, j = this.canvas.width, k = this.canvas.height, l = this.layer.width, m = this.layer.height, n = this._mc.tileWidth, o = this._mc.tileHeight, p = Math.floor(g / n), q = Math.floor((j - 1 + g) / n), r = Math.floor(h / o), s = Math.floor((k - 1 + h) / o), t = p * n - g, u = r * o - h, v = (p + 1048576 * l) % l, w = (r + 1048576 * m) % m;
        for(i.strokeStyle = this.debugSettings.facingEdgeStroke, d = w, f = s - r, b = u; f >= 0; d++, f--, b += o){
            d >= m && (d -= m);
            var x = this.layer.data[d];
            for(c = v, e = q - p, a = t; e >= 0; c++, e--, a += n){
                c >= l && (c -= l);
                var y = x[c];
                !y || y.index < 0 || !y.collides || (this.debugSettings.collidingTileOverfill && (i.fillStyle = this.debugSettings.collidingTileOverfill, i.fillRect(a, b, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (i.beginPath(), y.faceTop && (i.moveTo(a, b), i.lineTo(a + this._mc.cw, b)), y.faceBottom && (i.moveTo(a, b + this._mc.ch), i.lineTo(a + this._mc.cw, b + this._mc.ch)), y.faceLeft && (i.moveTo(a, b), i.lineTo(a, b + this._mc.ch)), y.faceRight && (i.moveTo(a + this._mc.cw, b), i.lineTo(a + this._mc.cw, b + this._mc.ch)), i.closePath(), i.stroke()));
            }
        }
    }, Object.defineProperty(c53.TilemapLayer.prototype, "wrap", {
        get: function() {
            return this._wrap;
        },
        set: function(a) {
            this._wrap = a, this.dirty = !0;
        }
    }), Object.defineProperty(c53.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._scrollX;
        },
        set: function(a) {
            this._scrollX = a;
        }
    }), Object.defineProperty(c53.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._scrollY;
        },
        set: function(a) {
            this._scrollY = a;
        }
    }), Object.defineProperty(c53.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw;
        },
        set: function(a) {
            this._mc.cw = 0 | a, this.dirty = !0;
        }
    }), Object.defineProperty(c53.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch;
        },
        set: function(a) {
            this._mc.ch = 0 | a, this.dirty = !0;
        }
    }), c53.TilemapParser = {
        INSERT_NULL: !1,
        parse: function(a, b, d, e, f, g) {
            if (void 0 === d && (d = 32), void 0 === e && (e = 32), void 0 === f && (f = 10), void 0 === g && (g = 10), void 0 === b) return this.getEmptyData();
            if (null === b) return this.getEmptyData(d, e, f, g);
            var h = a.cache.getTilemapData(b);
            if (h) {
                if (h.format === c53.Tilemap.CSV) return this.parseCSV(b, h.data, d, e);
                if (!h.format || h.format === c53.Tilemap.TILED_JSON) return this.parseTiledJSON(h.data);
            } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + b);
        },
        parseCSV: function(a, b, d, e) {
            var f = this.getEmptyData();
            b = b.trim();
            for(var g = [], h = b.split("\n"), i = h.length, j = 0, k = 0; k < h.length; k++){
                g[k] = [];
                for(var l = h[k].split(","), m = 0; m < l.length; m++)g[k][m] = new c53.Tile(f.layers[0], parseInt(l[m], 10), m, k, d, e);
                0 === j && (j = l.length);
            }
            return f.format = c53.Tilemap.CSV, f.name = a, f.width = j, f.height = i, f.tileWidth = d, f.tileHeight = e, f.widthInPixels = j * d, f.heightInPixels = i * e, f.layers[0].width = j, f.layers[0].height = i, f.layers[0].widthInPixels = f.widthInPixels, f.layers[0].heightInPixels = f.heightInPixels, f.layers[0].data = g, f;
        },
        getEmptyData: function(a, b, c, d) {
            return {
                width: void 0 !== c && null !== c ? c : 0,
                height: void 0 !== d && null !== d ? d : 0,
                tileWidth: void 0 !== a && null !== a ? a : 0,
                tileHeight: void 0 !== b && null !== b ? b : 0,
                orientation: "orthogonal",
                version: "1",
                properties: {},
                widthInPixels: 0,
                heightInPixels: 0,
                layers: [
                    {
                        name: "layer",
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        widthInPixels: 0,
                        heightInPixels: 0,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: []
                    }
                ],
                images: [],
                objects: {},
                collision: {},
                tilesets: [],
                tiles: []
            };
        },
        parseTiledJSON: function(a90) {
            function b75(a, b) {
                var c = {};
                for(var d in b){
                    var e = b[d];
                    void 0 !== a[e] && (c[e] = a[e]);
                }
                return c;
            }
            if ("orthogonal" !== a90.orientation) return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"), null;
            for(var d48 = {
                width: a90.width,
                height: a90.height,
                tileWidth: a90.tilewidth,
                tileHeight: a90.tileheight,
                orientation: a90.orientation,
                format: c53.Tilemap.TILED_JSON,
                version: a90.version,
                properties: a90.properties,
                widthInPixels: a90.width * a90.tilewidth,
                heightInPixels: a90.height * a90.tileheight
            }, e31 = [], f = 0; f < a90.layers.length; f++)if ("tilelayer" === a90.layers[f].type) {
                var g = a90.layers[f];
                if (!g.compression && g.encoding && "base64" === g.encoding) {
                    for(var h = window.atob(g.data), i = h.length, j = new Array(i), k = 0; k < i; k += 4)j[k / 4] = (h.charCodeAt(k) | h.charCodeAt(k + 1) << 8 | h.charCodeAt(k + 2) << 16 | h.charCodeAt(k + 3) << 24) >>> 0;
                    g.data = j, delete g.encoding;
                } else if (g.compression) {
                    console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + g.name + "'");
                    continue;
                }
                var l = {
                    name: g.name,
                    x: g.x,
                    y: g.y,
                    width: g.width,
                    height: g.height,
                    widthInPixels: g.width * a90.tilewidth,
                    heightInPixels: g.height * a90.tileheight,
                    alpha: g.opacity,
                    offsetX: g.offsetx,
                    offsetY: g.offsety,
                    visible: g.visible,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: []
                };
                g.properties && (l.properties = g.properties);
                for(var m, n, o, p, q = 0, r = [], s = [], t = 0, i = g.data.length; t < i; t++){
                    if (m = 0, n = !1, p = g.data[t], o = 0, p > 536870912) switch(p > 2147483648 && (p -= 2147483648, o += 4), p > 1073741824 && (p -= 1073741824, o += 2), p > 536870912 && (p -= 536870912, o += 1), o){
                        case 5:
                            m = Math.PI / 2;
                            break;
                        case 6:
                            m = Math.PI;
                            break;
                        case 3:
                            m = 3 * Math.PI / 2;
                            break;
                        case 4:
                            m = 0, n = !0;
                            break;
                        case 7:
                            m = Math.PI / 2, n = !0;
                            break;
                        case 2:
                            m = Math.PI, n = !0;
                            break;
                        case 1:
                            m = 3 * Math.PI / 2, n = !0;
                    }
                    if (p > 0) {
                        var u = new c53.Tile(l, p, q, s.length, a90.tilewidth, a90.tileheight);
                        u.rotation = m, u.flipped = n, 0 !== o && (u.flippedVal = o), r.push(u);
                    } else c53.TilemapParser.INSERT_NULL ? r.push(null) : r.push(new c53.Tile(l, -1, q, s.length, a90.tilewidth, a90.tileheight));
                    q++, q === g.width && (s.push(r), q = 0, r = []);
                }
                l.data = s, e31.push(l);
            }
            d48.layers = e31;
            for(var v = [], f = 0; f < a90.layers.length; f++)if ("imagelayer" === a90.layers[f].type) {
                var w = a90.layers[f], x = {
                    name: w.name,
                    image: w.image,
                    x: w.x,
                    y: w.y,
                    alpha: w.opacity,
                    visible: w.visible,
                    properties: {}
                };
                w.properties && (x.properties = w.properties), v.push(x);
            }
            d48.images = v;
            for(var y = [], z = [], A = null, f = 0; f < a90.tilesets.length; f++){
                var B = a90.tilesets[f];
                if (B.source) console.warn("Phaser.TilemapParser - Phaser can't load external tilesets (%s). Use the Embed Tileset button and then export the map again.", B.source);
                else if (B.image) {
                    var C = new c53.Tileset(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
                    B.tileproperties && (C.tileProperties = B.tileproperties), C.updateTileData(B.imagewidth, B.imageheight), y.push(C);
                } else {
                    if (!B.tiles) throw new Error("Tileset " + B.name + " has no `image` or `tiles` property.");
                    var D = new c53.ImageCollection(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
                    for(var E in B.tiles){
                        var x = B.tiles[E].image, p = B.firstgid + parseInt(E, 10);
                        D.addImage(p, x);
                    }
                    z.push(D);
                }
                A && (A.lastgid = B.firstgid - 1), A = B;
            }
            if (0 === y.length && 0 === z.length) throw new Error("This tilemap has no tilesets.");
            d48.tilesets = y, d48.imagecollections = z;
            for(var F = {}, G = {}, f = 0; f < a90.layers.length; f++)if ("objectgroup" === a90.layers[f].type) {
                var H = a90.layers[f];
                F[H.name] = [], G[H.name] = [];
                for(var I = 0, i = H.objects.length; I < i; I++)if (H.objects[I].gid) {
                    var J = {
                        gid: H.objects[I].gid,
                        name: H.objects[I].name,
                        type: H.objects[I].hasOwnProperty("type") ? H.objects[I].type : "",
                        x: H.objects[I].x,
                        y: H.objects[I].y,
                        width: H.objects[I].width,
                        height: H.objects[I].height,
                        visible: H.objects[I].visible,
                        properties: H.objects[I].properties
                    };
                    H.objects[I].rotation && (J.rotation = H.objects[I].rotation), F[H.name].push(J);
                } else if (H.objects[I].polyline) {
                    var J = {
                        name: H.objects[I].name,
                        type: H.objects[I].type,
                        x: H.objects[I].x,
                        y: H.objects[I].y,
                        width: H.objects[I].width,
                        height: H.objects[I].height,
                        visible: H.objects[I].visible,
                        properties: H.objects[I].properties
                    };
                    H.objects[I].rotation && (J.rotation = H.objects[I].rotation), J.polyline = [];
                    for(var K = 0; K < H.objects[I].polyline.length; K++)J.polyline.push([
                        H.objects[I].polyline[K].x,
                        H.objects[I].polyline[K].y
                    ]);
                    G[H.name].push(J), F[H.name].push(J);
                } else if (H.objects[I].polygon) {
                    var J = b75(H.objects[I], [
                        "name",
                        "type",
                        "x",
                        "y",
                        "visible",
                        "rotation",
                        "properties"
                    ]);
                    J.polygon = [];
                    for(var K = 0; K < H.objects[I].polygon.length; K++)J.polygon.push([
                        H.objects[I].polygon[K].x,
                        H.objects[I].polygon[K].y
                    ]);
                    F[H.name].push(J);
                } else if (H.objects[I].ellipse) {
                    var J = b75(H.objects[I], [
                        "name",
                        "type",
                        "ellipse",
                        "x",
                        "y",
                        "width",
                        "height",
                        "visible",
                        "rotation",
                        "properties"
                    ]);
                    F[H.name].push(J);
                } else {
                    var J = b75(H.objects[I], [
                        "name",
                        "type",
                        "x",
                        "y",
                        "width",
                        "height",
                        "visible",
                        "rotation",
                        "properties"
                    ]);
                    J.rectangle = !0, F[H.name].push(J);
                }
            }
            d48.objects = F, d48.collision = G, d48.tiles = [];
            for(var f = 0; f < d48.tilesets.length; f++)for(var B = d48.tilesets[f], q = B.tileMargin, L = B.tileMargin, M = 0, N = 0, O = 0, t = B.firstgid; t < B.firstgid + B.total && (d48.tiles[t] = [
                q,
                L,
                f
            ], q += B.tileWidth + B.tileSpacing, ++M !== B.total) && (++N !== B.columns || (q = B.tileMargin, L += B.tileHeight + B.tileSpacing, N = 0, ++O !== B.rows)); t++);
            for(var l, u, P, B, f = 0; f < d48.layers.length; f++){
                l = d48.layers[f], B = null;
                for(var k = 0; k < l.data.length; k++){
                    r = l.data[k];
                    for(var Q = 0; Q < r.length; Q++)null === (u = r[Q]) || u.index < 0 || (P = d48.tiles[u.index][2], B = d48.tilesets[P], B.tileProperties && B.tileProperties[u.index - B.firstgid] && (u.properties = c53.Utils.mixin(B.tileProperties[u.index - B.firstgid], u.properties)));
                }
            }
            return d48;
        }
    }, c53.Tileset = function(a, b, c, d, e, f, g) {
        (void 0 === c || c <= 0) && (c = 32), (void 0 === d || d <= 0) && (d = 32), void 0 === e && (e = 0), void 0 === f && (f = 0), this.name = a, this.firstgid = 0 | b, this.tileWidth = 0 | c, this.tileHeight = 0 | d, this.tileMargin = 0 | e, this.tileSpacing = 0 | f, this.properties = g || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = [];
    }, c53.Tileset.prototype = {
        draw: function(a, b, c, d) {
            var e = d - this.firstgid << 1;
            e >= 0 && e + 1 < this.drawCoords.length && a.drawImage(this.image, this.drawCoords[e], this.drawCoords[e + 1], this.tileWidth, this.tileHeight, b, c, this.tileWidth, this.tileHeight);
        },
        containsTileIndex: function(a) {
            return a >= this.firstgid && a < this.firstgid + this.total;
        },
        setImage: function(a) {
            this.image = a, this.updateTileData(a.width, a.height);
        },
        setSpacing: function(a, b) {
            this.tileMargin = 0 | a, this.tileSpacing = 0 | b, this.image && this.updateTileData(this.image.width, this.image.height);
        },
        updateTileData: function(a, b) {
            var c = (b - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing), d = (a - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
            c % 1 == 0 && d % 1 == 0 || console.warn("Phaser.Tileset - " + this.name + " image tile area is not an even multiple of tile size"), c = Math.floor(c), d = Math.floor(d), (this.rows && this.rows !== c || this.columns && this.columns !== d) && console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"), this.rows = c, this.columns = d, this.total = c * d, this.drawCoords.length = 0;
            for(var e = this.tileMargin, f = this.tileMargin, g = 0; g < this.rows; g++){
                for(var h = 0; h < this.columns; h++)this.drawCoords.push(e), this.drawCoords.push(f), e += this.tileWidth + this.tileSpacing;
                e = this.tileMargin, f += this.tileHeight + this.tileSpacing;
            }
        }
    }, c53.Tileset.prototype.constructor = c53.Tileset, c53.Particle = function(a, b, d, e, f) {
        c53.Sprite.call(this, a, b, d, e, f), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0;
    }, c53.Particle.prototype = Object.create(c53.Sprite.prototype), c53.Particle.prototype.constructor = c53.Particle, c53.Particle.prototype.update = function() {
        this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1);
    }, c53.Particle.prototype.onEmit = function() {}, c53.Particle.prototype.setAlphaData = function(a) {
        this.alphaData = a, this._a = a.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0;
    }, c53.Particle.prototype.setScaleData = function(a) {
        this.scaleData = a, this._s = a.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0;
    }, c53.Particle.prototype.reset = function(a, b, d) {
        return c53.Component.Reset.prototype.reset.call(this, a, b, d), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this;
    }, c53.Particles = function(a) {
        this.game = a, this.emitters = {}, this.ID = 0;
    }, c53.Particles.prototype = {
        add: function(a) {
            return this.emitters[a.id] = a, a;
        },
        remove: function(a) {
            delete this.emitters[a.id];
        },
        update: function() {
            for(var a in this.emitters)this.emitters[a].exists && this.emitters[a].update();
        }
    }, c53.Particles.prototype.constructor = c53.Particles, c53.Particles.Arcade = {}, c53.Particles.Arcade.Emitter = function(a, b, d, e) {
        this.maxParticles = e || 50, c53.Group.call(this, a), this._id = this.game.particles.ID++, this.name = "emitter" + this.id, this.type = c53.EMITTER, this.physicsType = c53.GROUP, this.area = new c53.Rectangle(b, d, 1, 1), this.minAngle = null, this.maxAngle = null, this.minSpeed = 0, this.maxSpeed = 100, this.minParticleSpeed = new c53.Point(-100, -100), this.maxParticleSpeed = new c53.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.particleClass = c53.Particle, this.particleDrag = new c53.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2000, this.bounce = new c53.Point, this.on = !1, this.particleAnchor = new c53.Point(0.5, 0.5), this.blendMode = c53.blendModes.NORMAL, this.emitX = b, this.emitY = d, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this.count = {
            emitted: 0,
            failed: 0,
            totalEmitted: 0,
            totalFailed: 0
        }, this._gravity = new c53.Point(0, 100), this._minParticleScale = new c53.Point(1, 1), this._maxParticleScale = new c53.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null;
    }, c53.Particles.Arcade.Emitter.prototype = Object.create(c53.Group.prototype), c53.Particles.Arcade.Emitter.prototype.constructor = c53.Particles.Arcade.Emitter, c53.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.count.emitted = 0, this.count.failed = 0, this.on && this.game.time.time >= this._timer) {
            if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal) {
                if (this._flowQuantity > 0) {
                    for(var a = 0; a < this._flowQuantity; a++)if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                        this.on = !1;
                        break;
                    }
                } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
            } else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
        }
        for(var a = this.children.length; a--;)this.children[a].exists && this.children[a].update();
    }, c53.Particles.Arcade.Emitter.prototype.makeParticles = function(a, b, c, d, e, f) {
        void 0 === b && (b = 0), void 0 === c && (c = this.maxParticles), void 0 === d && (d = !1), void 0 === e && (e = !1), void 0 === f && (f = null);
        var g, h = 0, i = a, j = b;
        for(this._frames = b, c > this.maxParticles && (this.maxParticles = c); h < c;)Array.isArray(a) && (i = this.game.rnd.pick(a)), Array.isArray(b) && (j = this.game.rnd.pick(b)), g = new this.particleClass(this.game, 0, 0, i, j, f), this.game.physics.arcade.enable(g, !1), g.body.checkCollision.none = !d, g.body.collideWorldBounds = e, g.body.skipQuadTree = !0, g.exists = !1, g.visible = !1, g.anchor.copyFrom(this.particleAnchor), this.add(g), h++;
        return this;
    }, c53.Particles.Arcade.Emitter.prototype.kill = function() {
        return this.on = !1, this.alive = !1, this.exists = !1, this;
    }, c53.Particles.Arcade.Emitter.prototype.revive = function() {
        return this.alive = !0, this.exists = !0, this;
    }, c53.Particles.Arcade.Emitter.prototype.explode = function(a, b) {
        return void 0 === b && (b = this.maxParticles), this._flowTotal = 0, this.start(!0, a, 0, b, !1), this;
    }, c53.Particles.Arcade.Emitter.prototype.flow = function(a, b, c, d, e) {
        return void 0 !== b && null !== b || (b = 250), void 0 !== c && 0 !== c || (c = 1), void 0 === d && (d = -1), void 0 === e && (e = !0), c > this.maxParticles && (c = this.maxParticles), this._counter = 0, this._flowQuantity = c, this._flowTotal = d, e ? (this.start(!0, a, b, c), this._counter += c, this.on = !0, this._timer = this.game.time.time + b * this.game.time.slowMotion) : this.start(!1, a, b, c), this;
    }, c53.Particles.Arcade.Emitter.prototype.start = function(a, b, c, d, e) {
        if (void 0 === a && (a = !0), void 0 === b && (b = 0), void 0 !== c && null !== c || (c = 250), void 0 === d && (d = 0), void 0 === e && (e = !1), d > this.maxParticles && (d = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = b, this.frequency = c, a || e) for(var f = 0; f < d; f++)this.emitParticle();
        else this.on = !0, this._quantity = d, this._counter = 0, this._timer = this.game.time.time + c * this.game.time.slowMotion;
        return this;
    }, c53.Particles.Arcade.Emitter.prototype.emitParticle = function(a, b, c, d) {
        void 0 === a && (a = null), void 0 === b && (b = null);
        var e = this.getFirstExists(!1);
        if (null === e) return this.count.failed++, this.count.totalFailed++, !1;
        this.count.emitted++, this.count.totalEmitted++;
        var f = this.game.rnd;
        void 0 !== c && void 0 !== d ? e.loadTexture(c, d) : void 0 !== c && e.loadTexture(c);
        var g = this.emitX, h = this.emitY;
        null !== a ? g = a : this.width > 1 && (g = f.between(this.left, this.right)), null !== b ? h = b : this.height > 1 && (h = f.between(this.top, this.bottom)), e.reset(g, h), e.angle = 0, e.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(e) : this.particleSendToBack && this.sendToBack(e), this.autoScale ? e.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? e.scale.set(f.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y ? e.scale.set(f.realInRange(this._minParticleScale.x, this._maxParticleScale.x), f.realInRange(this._minParticleScale.y, this._maxParticleScale.y)) : e.scale.set(this._minParticleScale.x, this._minParticleScale.y), void 0 === d && (Array.isArray(this._frames) ? e.frame = this.game.rnd.pick(this._frames) : e.frame = this._frames), this.autoAlpha ? e.setAlphaData(this.alphaData) : e.alpha = f.realInRange(this.minParticleAlpha, this.maxParticleAlpha), e.blendMode = this.blendMode;
        var i = e.body;
        return i.updateBounds(), i.bounce.copyFrom(this.bounce), i.drag.copyFrom(this.particleDrag), null != this.minAngle && null != this.maxAngle ? this.game.physics.arcade.velocityFromAngle(this.minAngle === this.maxAngle ? this.minAngle : f.between(this.minAngle, this.maxAngle), this.minSpeed === this.maxSpeed ? this.minSpeed : f.between(this.minSpeed, this.maxSpeed), i.velocity) : (i.velocity.x = f.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), i.velocity.y = f.between(this.minParticleSpeed.y, this.maxParticleSpeed.y)), i.angularVelocity = f.between(this.minRotation, this.maxRotation), i.gravity.copyFrom(this.gravity), i.angularDrag = this.angularDrag, e.onEmit(), !0;
    }, c53.Particles.Arcade.Emitter.prototype.destroy = function() {
        this.game.particles.remove(this), c53.Group.prototype.destroy.call(this, !0, !1);
    }, c53.Particles.Arcade.Emitter.prototype.setSize = function(a, b) {
        return this.area.width = a, this.area.height = b, this;
    }, c53.Particles.Arcade.Emitter.prototype.setXSpeed = function(a, b) {
        return a = a || 0, b = b || 0, this.minParticleSpeed.x = a, this.maxParticleSpeed.x = b, this;
    }, c53.Particles.Arcade.Emitter.prototype.setYSpeed = function(a, b) {
        return a = a || 0, b = b || 0, this.minParticleSpeed.y = a, this.maxParticleSpeed.y = b, this;
    }, c53.Particles.Arcade.Emitter.prototype.setRotation = function(a, b) {
        return a = a || 0, b = b || 0, this.minRotation = a, this.maxRotation = b, this;
    }, c53.Particles.Arcade.Emitter.prototype.setAlpha = function(a, b, d, e, f) {
        if (void 0 === a && (a = 1), void 0 === b && (b = 1), void 0 === d && (d = 0), void 0 === e && (e = c53.Easing.Linear.None), void 0 === f && (f = !1), this.minParticleAlpha = a, this.maxParticleAlpha = b, this.autoAlpha = !1, d > 0 && a !== b) {
            var g = {
                v: a
            }, h = this.game.make.tween(g).to({
                v: b
            }, d, e);
            h.yoyo(f), this.alphaData = h.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0;
        }
        return this;
    }, c53.Particles.Arcade.Emitter.prototype.setScale = function(a, b, d, e, f, g, h) {
        if (void 0 === a && (a = 1), void 0 === b && (b = 1), void 0 === d && (d = 1), void 0 === e && (e = 1), void 0 === f && (f = 0), void 0 === g && (g = c53.Easing.Linear.None), void 0 === h && (h = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(a, d), this._maxParticleScale.set(b, e), this.autoScale = !1, f > 0 && (a !== b || d !== e)) {
            var i = {
                x: a,
                y: d
            }, j = this.game.make.tween(i).to({
                x: b,
                y: e
            }, f, g);
            j.yoyo(h), this.scaleData = j.generateData(60), this.scaleData.reverse(), this.autoScale = !0;
        }
        return this;
    }, c53.Particles.Arcade.Emitter.prototype.setAngle = function(a, b, c, d) {
        return this.minAngle = a, this.maxAngle = b, null != c && (this.minSpeed = c), null != d && (this.maxSpeed = d), this;
    }, c53.Particles.Arcade.Emitter.prototype.at = function(a) {
        return a.center ? (this.emitX = a.center.x, this.emitY = a.center.y) : (this.emitX = a.world.x + a.anchor.x * a.width, this.emitY = a.world.y + a.anchor.y * a.height), this;
    }, Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "gravity", {
        get: function() {
            return this._gravity;
        },
        set: function(a) {
            "number" == typeof a ? this._gravity.y = a : this._gravity = a;
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "id", {
        get: function() {
            return this._id;
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "width", {
        get: function() {
            return this.area.width;
        },
        set: function(a) {
            this.area.width = a;
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "height", {
        get: function() {
            return this.area.height;
        },
        set: function(a) {
            this.area.height = a;
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX;
        },
        set: function(a) {
            this.emitX = a;
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY;
        },
        set: function(a) {
            this.emitY = a;
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x - this.area.width / 2);
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.area.width / 2);
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.area.height / 2);
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.area.height / 2);
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "output", {
        get: function() {
            return 1000 * this._flowQuantity / this.frequency;
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "lifespanOutput", {
        get: function() {
            return (0 === this.lifespan ? 1 / 0 : this.lifespan) * this._flowQuantity / this.frequency;
        }
    }), Object.defineProperty(c53.Particles.Arcade.Emitter.prototype, "remainder", {
        get: function() {
            return this.maxParticles - this.lifespanOutput;
        }
    }), c53.Weapon = function(a, b) {
        c53.Plugin.call(this, a, b), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new c53.Rectangle(0, 0, 1, 1), this.fireAngle = c53.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new c53.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = c53.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = c53.Weapon.KILL_WORLD_BOUNDS, this._data = {
            customBody: !1,
            width: 0,
            height: 0,
            offsetX: 0,
            offsetY: 0
        }, this.bounds = new c53.Rectangle, this.bulletBounds = a.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new c53.Signal, this.onKill = new c53.Signal, this.onFireLimit = new c53.Signal, this.trackedSprite = null, this.trackedPointer = null, this.multiFire = !1, this._hasFired = !1, this.trackRotation = !1, this.trackOffset = new c53.Point, this._nextFire = 0, this._tempNextFire = 0, this._rotatedPoint = new c53.Point;
    }, c53.Weapon.prototype = Object.create(c53.Plugin.prototype), c53.Weapon.prototype.constructor = c53.Weapon, c53.Weapon.KILL_NEVER = 0, c53.Weapon.KILL_LIFESPAN = 1, c53.Weapon.KILL_DISTANCE = 2, c53.Weapon.KILL_WEAPON_BOUNDS = 3, c53.Weapon.KILL_CAMERA_BOUNDS = 4, c53.Weapon.KILL_WORLD_BOUNDS = 5, c53.Weapon.KILL_STATIC_BOUNDS = 6, c53.Weapon.prototype.createBullets = function(a, b, d, e) {
        return void 0 === a && (a = 1), void 0 === e && (e = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(c53.Physics.ARCADE, e), this.bullets.classType = this._bulletClass), 0 !== a && (-1 === a && (this.autoExpandBulletsGroup = !0, a = 1), this.bullets.createMultiple(a, b, d), this.bullets.setAll("data.bulletManager", this), this.bulletKey = b, this.bulletFrame = d), this;
    }, c53.Weapon.prototype.forEach = function(a, b) {
        return this.bullets.forEachExists(a, b, arguments), this;
    }, c53.Weapon.prototype.pauseAll = function() {
        return this.bullets.setAll("body.enable", !1), this;
    }, c53.Weapon.prototype.resumeAll = function() {
        return this.bullets.setAll("body.enable", !0), this;
    }, c53.Weapon.prototype.killAll = function() {
        return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this;
    }, c53.Weapon.prototype.resetShots = function(a) {
        return this.shots = 0, void 0 !== a && (this.fireLimit = a), this;
    }, c53.Weapon.prototype.destroy = function() {
        this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1;
    }, c53.Weapon.prototype.update = function() {
        this._bulletKillType === c53.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire();
    }, c53.Weapon.prototype.postRender = function() {
        this.multiFire && this._hasFired && (this._hasFired = !1, this._nextFire = this._tempNextFire);
    }, c53.Weapon.prototype.trackSprite = function(a, b, c, d) {
        return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = !1), this.trackedPointer = null, this.trackedSprite = a, this.trackRotation = d, this.trackOffset.set(b, c), this;
    }, c53.Weapon.prototype.trackPointer = function(a, b, c) {
        return void 0 === a && (a = this.game.input.activePointer), void 0 === b && (b = 0), void 0 === c && (c = 0), this.trackedPointer = a, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(b, c), this;
    }, c53.Weapon.prototype.fireMany = function(a91, b) {
        this.multiFire = !0;
        var c = [], d = this;
        return b || this.trackedSprite || this.trackedPointer ? a91.forEach(function(a) {
            c.push(d.fire(b, null, null, a.x, a.y));
        }) : a91.forEach(function(a) {
            c.push(d.fire(a));
        }), c;
    }, c53.Weapon.prototype.fireOffset = function(a, b) {
        return void 0 === a && (a = 0), void 0 === b && (b = 0), this.fire(null, null, null, a, b);
    }, c53.Weapon.prototype.fire = function(a, b, d, e, f) {
        if (void 0 === b && (b = null), void 0 === d && (d = null), this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return null;
        var g = this.bulletSpeed;
        0 !== this.bulletSpeedVariance && (g += c53.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), a ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(a.x, a.y) : (this.fireFrom.x = a.x, this.fireFrom.y = a.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.worldRotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (g += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y)), void 0 !== e && (this.fireFrom.x += e), void 0 !== f && (this.fireFrom.y += f);
        var h = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x, i = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y, j = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
        null !== b && null !== d && (j = this.game.math.radToDeg(Math.atan2(d - i, b - h))), 0 !== this.bulletAngleVariance && (j += c53.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
        var k = 0, l = 0;
        0 === j || 180 === j ? k = Math.cos(this.game.math.degToRad(j)) * g : 90 === j || 270 === j ? l = Math.sin(this.game.math.degToRad(j)) * g : (k = Math.cos(this.game.math.degToRad(j)) * g, l = Math.sin(this.game.math.degToRad(j)) * g);
        var m = null;
        if (this.autoExpandBulletsGroup ? (m = this.bullets.getFirstExists(!1, !0, h, i, this.bulletKey, this.bulletFrame), m.data.bulletManager = this) : m = this.bullets.getFirstExists(!1), m) {
            if (m.reset(h, i), m.data.fromX = h, m.data.fromY = i, m.data.killType = this.bulletKillType, m.data.killDistance = this.bulletKillDistance, m.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === c53.Weapon.KILL_LIFESPAN && (m.lifespan = this.bulletLifespan), m.angle = j + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                if (null === m.animations.getAnimation(this.bulletAnimation)) {
                    var n = this.anims[this.bulletAnimation];
                    m.animations.add(n.name, n.frames, n.frameRate, n.loop, n.useNumericIndex);
                }
                m.animations.play(this.bulletAnimation);
            } else this.bulletFrameCycle ? (m.frame = this.bulletFrames[this.bulletFrameIndex], ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (m.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
            m.data.bodyDirty && (this._data.customBody && m.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), m.body.collideWorldBounds = this.bulletCollideWorldBounds, m.data.bodyDirty = !1), m.body.velocity.set(k, l), m.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y);
            var o = 0;
            if (0 !== this.bulletSpeedVariance) {
                var p = this.fireRate;
                p += c53.Math.between(-this.fireRateVariance, this.fireRateVariance), p < 0 && (p = 0), o = this.game.time.now + p;
            } else o = this.game.time.now + this.fireRate;
            this.multiFire ? this._hasFired || (this._hasFired = !0, this._tempNextFire = o, this.shots++) : (this._nextFire = o, this.shots++), this.onFire.dispatch(m, this, g), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit);
        }
        return m;
    }, c53.Weapon.prototype.fireAtPointer = function(a) {
        return void 0 === a && (a = this.game.input.activePointer), this.fire(null, a.worldX, a.worldY);
    }, c53.Weapon.prototype.fireAtSprite = function(a) {
        return this.fire(null, a.world.x, a.world.y);
    }, c53.Weapon.prototype.fireAtXY = function(a, b) {
        return this.fire(null, a, b);
    }, c53.Weapon.prototype.setBulletBodyOffset = function(a, b, c, d) {
        return void 0 === c && (c = 0), void 0 === d && (d = 0), this._data.customBody = !0, this._data.width = a, this._data.height = b, this._data.offsetX = c, this._data.offsetY = d, this.bullets.callAll("body.setSize", "body", a, b, c, d), this.bullets.setAll("data.bodyDirty", !1), this;
    }, c53.Weapon.prototype.setBulletFrames = function(a, b, d, e) {
        return void 0 === d && (d = !0), void 0 === e && (e = !1), this.bulletFrames = c53.ArrayUtils.numberArray(a, b), this.bulletFrameIndex = 0, this.bulletFrameCycle = d, this.bulletFrameRandom = e, this;
    }, c53.Weapon.prototype.addBulletAnimation = function(a, b, c, d, e) {
        return this.anims[a] = {
            name: a,
            frames: b,
            frameRate: c,
            loop: d,
            useNumericIndex: e
        }, this.bullets.callAll("animations.add", "animations", a, b, c, d, e), this.bulletAnimation = a, this;
    }, c53.Weapon.prototype.debug = function(a, b, c) {
        void 0 === a && (a = 16), void 0 === b && (b = 32), void 0 === c && (c = !1), this.game.debug.text("Weapon Plugin", a, b), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, a, b + 24), c && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)");
    }, Object.defineProperty(c53.Weapon.prototype, "bulletClass", {
        get: function() {
            return this._bulletClass;
        },
        set: function(a) {
            this._bulletClass = a, this.bullets && (this.bullets.classType = this._bulletClass);
        }
    }), Object.defineProperty(c53.Weapon.prototype, "bulletKillType", {
        get: function() {
            return this._bulletKillType;
        },
        set: function(a) {
            switch(a){
                case c53.Weapon.KILL_STATIC_BOUNDS:
                case c53.Weapon.KILL_WEAPON_BOUNDS:
                    this.bulletBounds = this.bounds;
                    break;
                case c53.Weapon.KILL_CAMERA_BOUNDS:
                    this.bulletBounds = this.game.camera.view;
                    break;
                case c53.Weapon.KILL_WORLD_BOUNDS:
                    this.bulletBounds = this.game.world.bounds;
            }
            this._bulletKillType = a;
        }
    }), Object.defineProperty(c53.Weapon.prototype, "bulletCollideWorldBounds", {
        get: function() {
            return this._bulletCollideWorldBounds;
        },
        set: function(a) {
            this._bulletCollideWorldBounds = a, this.bullets.setAll("body.collideWorldBounds", a), this.bullets.setAll("data.bodyDirty", !1);
        }
    }), Object.defineProperty(c53.Weapon.prototype, "x", {
        get: function() {
            return this.fireFrom.x;
        },
        set: function(a) {
            this.fireFrom.x = a;
        }
    }), Object.defineProperty(c53.Weapon.prototype, "y", {
        get: function() {
            return this.fireFrom.y;
        },
        set: function(a) {
            this.fireFrom.y = a;
        }
    }), c53.Bullet = function(a, b, d, e, f) {
        c53.Sprite.call(this, a, b, d, e, f), this.anchor.set(0.5), this.data = {
            bulletManager: null,
            fromX: 0,
            fromY: 0,
            bodyDirty: !0,
            rotateToVelocity: !1,
            killType: 0,
            killDistance: 0
        };
    }, c53.Bullet.prototype = Object.create(c53.Sprite.prototype), c53.Bullet.prototype.constructor = c53.Bullet, c53.Bullet.prototype.kill = function() {
        return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this;
    }, c53.Bullet.prototype.update = function() {
        this.exists && (this.data.killType > c53.Weapon.KILL_LIFESPAN && (this.data.killType === c53.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding));
    }, c53.Video = function(a, b, d) {
        if (void 0 === b && (b = null), void 0 === d && (d = null), this.game = a, this.key = b, this.width = 0, this.height = 0, this.type = c53.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new c53.Signal, this.onChangeSource = new c53.Signal, this.onComplete = new c53.Signal, this.onAccess = new c53.Signal, this.onError = new c53.Signal, this.onTimeout = new c53.Signal, this.timeout = 15000, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._pendingChangeSource = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, b && this.game.cache.checkVideoKey(b)) {
            var e = this.game.cache.getVideo(b);
            e.isBlob ? this.createVideoFromBlob(e.data) : this.video = e.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight;
        } else d && this.createVideoFromURL(d, !1);
        this.video && !d ? (this.baseTexture = new PIXI.BaseTexture(this.video, null, this.game.resolution), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(c53.Cache.DEFAULT.baseTexture.source, null, this.game.resolution), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new c53.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== b && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, c53.BitmapData && (this.snapshot = new c53.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : e && (e.locked = !1);
    }, c53.Video.prototype = {
        connectToMediaStream: function(a, b) {
            return a && b && (this.video = a, this.videoStream = b, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this;
        },
        startMediaStream: function(a, b, c) {
            if (void 0 === a && (a = !1), void 0 === b && (b = null), void 0 === c && (c = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
            null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== b && (this.video.width = b), null !== c && (this.video.height = c), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
            try {
                navigator.getUserMedia({
                    audio: a,
                    video: !0
                }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this));
            } catch (a92) {
                this.getUserMediaError(a92);
            }
            return this;
        },
        getUserMediaTimeout: function() {
            clearTimeout(this._timeOutID), this.onTimeout.dispatch(this);
        },
        getUserMediaError: function(a) {
            clearTimeout(this._timeOutID), this.onError.dispatch(this, a);
        },
        getUserMediaSuccess: function(a93) {
            clearTimeout(this._timeOutID), this.videoStream = a93, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = a93 : this.video.src = window.URL && window.URL.createObjectURL(a93) || a93;
            var b = this;
            this.video.onloadeddata = function() {
                function a() {
                    if (c > 0) {
                        if (b.video.videoWidth > 0) {
                            var d = b.video.videoWidth, e = b.video.videoHeight;
                            isNaN(b.video.videoHeight) && (e = d / (4 / 3)), b.video.play(), b.isStreaming = !0, b.baseTexture.source = b.video, b.updateTexture(null, d, e), b.onAccess.dispatch(b);
                        } else window.setTimeout(a, 500);
                    } else console.warn("Unable to connect to video stream. Webcam error?");
                    c--;
                }
                var c = 10;
                a();
            };
        },
        createVideoFromBlob: function(a94) {
            var b = this;
            return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(a) {
                b.updateTexture(a);
            }, !0), this.video.src = window.URL.createObjectURL(a94), this.video.canplay = !0, this;
        },
        createVideoFromURL: function(a, b) {
            return void 0 === b && (b = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, b && this.video.setAttribute("autoplay", "autoplay"), this.video.src = a, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = a, this;
        },
        updateTexture: function(a, b, c) {
            var d = !1;
            void 0 !== b && null !== b || (b = this.video.videoWidth, d = !0), void 0 !== c && null !== c || (c = this.video.videoHeight), this.width = b, this.height = c, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(b, c), this.texture.frame.resize(b, c), this.texture.width = b, this.texture.height = c, this.texture.valid = !0, this.snapshot && this.snapshot.resize(b, c), d && null !== this.key && (this.onChangeSource.dispatch(this, b, c), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)));
        },
        complete: function() {
            this.onComplete.dispatch(this);
        },
        play: function(a, b) {
            return this._pendingChangeSource ? this : (void 0 === a && (a = !1), void 0 === b && (b = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = a ? "loop" : "", this.video.playbackRate = b, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, a, b)), this);
        },
        playHandler: function() {
            this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture();
        },
        stop: function() {
            return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(a) {
                a.stop();
            }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this;
        },
        add: function(a) {
            if (Array.isArray(a)) for(var b = 0; b < a.length; b++)a[b].loadTexture && a[b].loadTexture(this);
            else a.loadTexture(this);
            return this;
        },
        addToWorld: function(a, b, c, d, e, f) {
            e = e || 1, f = f || 1;
            var g = this.game.add.image(a, b, this);
            return g.anchor.set(c, d), g.scale.set(e, f), g;
        },
        render: function() {
            !this.disableTextureUpload && this.playing && this.baseTexture.dirty();
        },
        setMute: function() {
            this._muted || (this._muted = !0, this.video.muted = !0);
        },
        unsetMute: function() {
            this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1);
        },
        setPause: function() {
            this._paused || this.touchLocked || (this._paused = !0, this.video.pause());
        },
        setResume: function() {
            !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play());
        },
        changeSource: function(a, b) {
            return void 0 === b && (b = !0), this.texture.valid = !1, this.video.pause(), this._pendingChangeSource = !0, this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = a, this.video.load(), this._autoplay = b, b || (this.paused = !0), this;
        },
        checkVideoProgress: function() {
            4 === this.video.readyState ? (this._pendingChangeSource = !1, this.updateTexture()) : (this.retry--, this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming));
        },
        setTouchLock: function() {
            this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0;
        },
        unlock: function() {
            if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                var a = this.game.cache.getVideo(this.key);
                a && !a.isBlob && (a.locked = !1);
            }
            return !0;
        },
        grab: function(a, b, c) {
            return void 0 === a && (a = !1), void 0 === b && (b = 1), void 0 === c && (c = null), null === this.snapshot ? void console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable") : (a && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, b, c), this.snapshot);
        },
        removeVideoElement: function() {
            if (this.video) {
                for(this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();)this.video.removeChild(this.video.firstChild);
                this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null;
            }
        },
        destroy: function() {
            this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID);
        }
    }, Object.defineProperty(c53.Video.prototype, "currentTime", {
        get: function() {
            return this.video ? this.video.currentTime : 0;
        },
        set: function(a) {
            this.video.currentTime = a;
        }
    }), Object.defineProperty(c53.Video.prototype, "duration", {
        get: function() {
            return this.video ? this.video.duration : 0;
        }
    }), Object.defineProperty(c53.Video.prototype, "progress", {
        get: function() {
            return this.video ? this.video.currentTime / this.video.duration : 0;
        }
    }), Object.defineProperty(c53.Video.prototype, "mute", {
        get: function() {
            return this._muted;
        },
        set: function(a) {
            if (a = a || null) {
                if (this._muted) return;
                this._codeMuted = !0, this.setMute();
            } else {
                if (!this._muted) return;
                this._codeMuted = !1, this.unsetMute();
            }
        }
    }), Object.defineProperty(c53.Video.prototype, "paused", {
        get: function() {
            return this._paused;
        },
        set: function(a) {
            if (a = a || null, !this.touchLocked) {
                if (a) {
                    if (this._paused) return;
                    this._codePaused = !0, this.setPause();
                } else {
                    if (!this._paused) return;
                    this._codePaused = !1, this.setResume();
                }
            }
        }
    }), Object.defineProperty(c53.Video.prototype, "volume", {
        get: function() {
            return this.video ? this.video.volume : 1;
        },
        set: function(a) {
            a < 0 ? a = 0 : a > 1 && (a = 1), this.video && (this.video.volume = a);
        }
    }), Object.defineProperty(c53.Video.prototype, "playbackRate", {
        get: function() {
            return this.video ? this.video.playbackRate : 1;
        },
        set: function(a) {
            this.video && (this.video.playbackRate = a);
        }
    }), Object.defineProperty(c53.Video.prototype, "loop", {
        get: function() {
            return !!this.video && this.video.loop;
        },
        set: function(a) {
            a && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "");
        }
    }), Object.defineProperty(c53.Video.prototype, "playing", {
        get: function() {
            return !!this.video && !(this.video.paused && this.video.ended);
        }
    }), c53.Video.prototype.constructor = c53.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = c53.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = c53.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), PIXI.TextureSilentFail = !0, PIXI.canUseNewCanvasBlendModes = function() {
        return c53.Device.canUseMultiply;
    }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = c53), exports.Phaser = c53) : "undefined" != typeof define && define.amd ? define("Phaser", function() {
        return b54.Phaser = c53;
    }()) : b54.Phaser = c53, c53;
}).call(this); //# sourceMappingURL=phaser.map

//# sourceMappingURL=index.aac5946d.js.map
